{"version":3,"file":"[slug].ac212321.js","sources":["../../../../node_modules/@babel/runtime/helpers/esm/objectSpread.js","../../../../node_modules/svelte/easing/index.mjs","../../../../node_modules/structurae/lib/bit-field.js","../../../../node_modules/structurae/lib/binary-grid.js","../../../../node_modules/structurae/lib/binary-heap.js","../../../../node_modules/structurae/lib/graph.js","../../../../node_modules/structurae/lib/grid.js","../../../../node_modules/structurae/lib/bit-array.js","../../../../node_modules/structurae/lib/utilities.js","../../../../node_modules/structurae/lib/pool.js","../../../../node_modules/structurae/lib/ranked-bit-array.js","../../../../node_modules/structurae/lib/string-view.js","../../../../node_modules/structurae/lib/record-array.js","../../../../node_modules/structurae/lib/sorted-collection.js","../../../../node_modules/structurae/lib/sorted-array.js","../../../../node_modules/structurae/lib/symmetric-grid.js","../../../../node_modules/structurae/lib/unweighted-adjacency-list.js","../../../../node_modules/structurae/lib/unweighted-adjacency-matrix.js","../../../../node_modules/structurae/lib/weighted-adjacency-list.js","../../../../node_modules/structurae/lib/weighted-adjacency-matrix.js","../../../../node_modules/structurae/lib/array-view.js","../../../../node_modules/structurae/lib/typed-array-view.js","../../../../node_modules/structurae/lib/object-view.js","../../../../node_modules/structurae/index.js","../../../../src/components/Sokoban.svelte","../../../../src/routes/levels/[slug].svelte"],"sourcesContent":["import defineProperty from \"./defineProperty\";\nexport default function _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n    var ownKeys = Object.keys(source);\n\n    if (typeof Object.getOwnPropertySymbols === 'function') {\n      ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) {\n        return Object.getOwnPropertyDescriptor(source, sym).enumerable;\n      }));\n    }\n\n    ownKeys.forEach(function (key) {\n      defineProperty(target, key, source[key]);\n    });\n  }\n\n  return target;\n}","export { identity as linear } from '../internal';\n\n/*\nAdapted from https://github.com/mattdesl\nDistributed under MIT License https://github.com/mattdesl/eases/blob/master/LICENSE.md\n*/\nfunction backInOut(t) {\n    const s = 1.70158 * 1.525;\n    if ((t *= 2) < 1)\n        return 0.5 * (t * t * ((s + 1) * t - s));\n    return 0.5 * ((t -= 2) * t * ((s + 1) * t + s) + 2);\n}\nfunction backIn(t) {\n    const s = 1.70158;\n    return t * t * ((s + 1) * t - s);\n}\nfunction backOut(t) {\n    const s = 1.70158;\n    return --t * t * ((s + 1) * t + s) + 1;\n}\nfunction bounceOut(t) {\n    const a = 4.0 / 11.0;\n    const b = 8.0 / 11.0;\n    const c = 9.0 / 10.0;\n    const ca = 4356.0 / 361.0;\n    const cb = 35442.0 / 1805.0;\n    const cc = 16061.0 / 1805.0;\n    const t2 = t * t;\n    return t < a\n        ? 7.5625 * t2\n        : t < b\n            ? 9.075 * t2 - 9.9 * t + 3.4\n            : t < c\n                ? ca * t2 - cb * t + cc\n                : 10.8 * t * t - 20.52 * t + 10.72;\n}\nfunction bounceInOut(t) {\n    return t < 0.5\n        ? 0.5 * (1.0 - bounceOut(1.0 - t * 2.0))\n        : 0.5 * bounceOut(t * 2.0 - 1.0) + 0.5;\n}\nfunction bounceIn(t) {\n    return 1.0 - bounceOut(1.0 - t);\n}\nfunction circInOut(t) {\n    if ((t *= 2) < 1)\n        return -0.5 * (Math.sqrt(1 - t * t) - 1);\n    return 0.5 * (Math.sqrt(1 - (t -= 2) * t) + 1);\n}\nfunction circIn(t) {\n    return 1.0 - Math.sqrt(1.0 - t * t);\n}\nfunction circOut(t) {\n    return Math.sqrt(1 - --t * t);\n}\nfunction cubicInOut(t) {\n    return t < 0.5 ? 4.0 * t * t * t : 0.5 * Math.pow(2.0 * t - 2.0, 3.0) + 1.0;\n}\nfunction cubicIn(t) {\n    return t * t * t;\n}\nfunction cubicOut(t) {\n    const f = t - 1.0;\n    return f * f * f + 1.0;\n}\nfunction elasticInOut(t) {\n    return t < 0.5\n        ? 0.5 *\n            Math.sin(((+13.0 * Math.PI) / 2) * 2.0 * t) *\n            Math.pow(2.0, 10.0 * (2.0 * t - 1.0))\n        : 0.5 *\n            Math.sin(((-13.0 * Math.PI) / 2) * (2.0 * t - 1.0 + 1.0)) *\n            Math.pow(2.0, -10.0 * (2.0 * t - 1.0)) +\n            1.0;\n}\nfunction elasticIn(t) {\n    return Math.sin((13.0 * t * Math.PI) / 2) * Math.pow(2.0, 10.0 * (t - 1.0));\n}\nfunction elasticOut(t) {\n    return (Math.sin((-13.0 * (t + 1.0) * Math.PI) / 2) * Math.pow(2.0, -10.0 * t) + 1.0);\n}\nfunction expoInOut(t) {\n    return t === 0.0 || t === 1.0\n        ? t\n        : t < 0.5\n            ? +0.5 * Math.pow(2.0, 20.0 * t - 10.0)\n            : -0.5 * Math.pow(2.0, 10.0 - t * 20.0) + 1.0;\n}\nfunction expoIn(t) {\n    return t === 0.0 ? t : Math.pow(2.0, 10.0 * (t - 1.0));\n}\nfunction expoOut(t) {\n    return t === 1.0 ? t : 1.0 - Math.pow(2.0, -10.0 * t);\n}\nfunction quadInOut(t) {\n    t /= 0.5;\n    if (t < 1)\n        return 0.5 * t * t;\n    t--;\n    return -0.5 * (t * (t - 2) - 1);\n}\nfunction quadIn(t) {\n    return t * t;\n}\nfunction quadOut(t) {\n    return -t * (t - 2.0);\n}\nfunction quartInOut(t) {\n    return t < 0.5\n        ? +8.0 * Math.pow(t, 4.0)\n        : -8.0 * Math.pow(t - 1.0, 4.0) + 1.0;\n}\nfunction quartIn(t) {\n    return Math.pow(t, 4.0);\n}\nfunction quartOut(t) {\n    return Math.pow(t - 1.0, 3.0) * (1.0 - t) + 1.0;\n}\nfunction quintInOut(t) {\n    if ((t *= 2) < 1)\n        return 0.5 * t * t * t * t * t;\n    return 0.5 * ((t -= 2) * t * t * t * t + 2);\n}\nfunction quintIn(t) {\n    return t * t * t * t * t;\n}\nfunction quintOut(t) {\n    return --t * t * t * t * t + 1;\n}\nfunction sineInOut(t) {\n    return -0.5 * (Math.cos(Math.PI * t) - 1);\n}\nfunction sineIn(t) {\n    const v = Math.cos(t * Math.PI * 0.5);\n    if (Math.abs(v) < 1e-14)\n        return 1;\n    else\n        return 1 - v;\n}\nfunction sineOut(t) {\n    return Math.sin((t * Math.PI) / 2);\n}\n\nexport { backInOut, backIn, backOut, bounceOut, bounceInOut, bounceIn, circInOut, circIn, circOut, cubicInOut, cubicIn, cubicOut, elasticInOut, elasticIn, elasticOut, expoInOut, expoIn, expoOut, quadInOut, quadIn, quadOut, quartInOut, quartIn, quartOut, quintInOut, quintIn, quintOut, sineInOut, sineIn, sineOut };\n","/**\n * @private\n * Use Number if BigInt is not available.\n */\nconst BigInt = (global || window).BigInt || Number;\n\n/**\n * @private\n * @type {number} The largest safe integer for bitwise operations.\n */\nconst SIGN_BIT = 2147483647;\n\n/**\n * @private\n * @type {number} The maximum safe size for bitwise operations on standard numbers.\n */\nconst BITWISE_SIZE = 31;\n\n/**\n * @private\n * @type {number} The maximum safe size for standard numbers in bits.\n */\nconst MAX_SIZE = 53;\n\n/**\n * @private\n * @type {number} 2 ** 48\n */\nconst TWO_TO_48 = 281474976710656;\n\n/**\n * @private\n * @type {number} 2 ** 31\n */\nconst TWO_TO_31 = 2147483648;\n\n/**\n * @typedef {number | BigInt} AnyNumber\n */\n\n/**\n * @typedef {number | string} FieldName\n */\n\n/**\n * @typedef {Object<string, number>} UnpackedInt\n */\n\n/**\n * @typedef {Object} Field\n * @property {FieldName} name name of the field\n * @property {number} [size] size in bits\n */\n\n/**\n * @typedef {Array} Matcher\n * @property {AnyNumber} 0 value\n * @property {AnyNumber} 1 mask\n */\n\n/**\n * @typedef {Object<string, AnyNumber>} Masks\n */\n\n/**\n * Stores and operates on data in Numbers and BigInts treating them as bitfields.\n */\nclass BitField {\n  /**\n   * @param {AnyNumber|Array<number>} [data=0]\n   * @example\n   *\n   * class Person extends BitField {}\n   * Person.fields = [\n   *  { name: 'age', size: 7 },\n   *  { name: 'gender', size: 1 },\n   * ];\n   * new Person([20, 1]).value\n   * //=> 41\n   * new Person(41).value\n   * //=> 41\n   */\n  constructor(data = 0) {\n    const { isInitialized } = this.constructor;\n    if (!isInitialized) this.constructor.initialize();\n\n    const { isBigInt } = this.constructor;\n    const value = Array.isArray(data) ? this.constructor.encode(data) : data;\n\n    /** @type {number|BigInt} */\n    this.value = isBigInt ? BigInt(value) : value;\n  }\n\n  /**\n   * Returns the value of a given field.\n   *\n   * @param {Field} field name of the field\n   * @returns {number} value value of the field\n   * @example\n   *\n   * class Person extends BitField {}\n   * Person.fields = [\n   *  { name: 'age', size: 7 },\n   *  { name: 'gender', size: 1 },\n   * ];\n   * const person = new Person([20, 1]);\n   * person.get('age');\n   * //=> 20\n   * person.get('gender');\n   * //=> 1\n   */\n  get(field) {\n    const { offsets, masks } = this.constructor;\n    const value = (this.value >> offsets[field]) & masks[field];\n    return Number(value);\n  }\n\n  /**\n   * Stores a given value in a field.\n   *\n   * @param {Field} field name of the field\n   * @param {number} value value of the field\n   * @returns {BitField} the instance\n   * @example\n   *\n   * class Person extends BitField {}\n   * Person.fields = [\n   *  { name: 'age', size: 7 },\n   *  { name: 'gender', size: 1 },\n   * ];\n   * const person = new Person([20, 1]);\n   * person.get('age');\n   * //=> 20\n   * person.set('age', 30).get('age');\n   * //=> 30\n   */\n  set(field, value = this.constructor.one) {\n    const { offsets, masks, isBigInt } = this.constructor;\n    if (isBigInt) value = BigInt(value);\n    this.value = (this.value & ~(masks[field] << offsets[field])) | (value << offsets[field]);\n    return this;\n  }\n\n  /**\n   * Checks if an instance has all the specified fields set to 1. Useful for bit flags.\n   *\n   * @param {...Field} fields names of the fields to check\n   * @returns {boolean} whether all the specified fields are set in the instance\n   * @example\n   *\n   * const SettingsFlags = BinariusFactory(['notify', 'premium', 'moderator']);\n   * const settings = SettingsFlags([1, 0, 1]);\n   * settings.has('notify', 'moderator');\n   * //=> true\n   * settings.has('notify', 'premium');\n   * //=> false\n   */\n  has(...fields) {\n    const { offsets, zero, one } = this.constructor;\n    let mask = zero;\n    for (let i = 0; i < fields.length; i++) {\n      mask |= one << offsets[fields[i]];\n    }\n    mask |= this.value;\n    return this.value === mask;\n  }\n\n  /**\n   * Checks if the instance contains all the key-value pairs listed in matcher.\n   * Use `ParseInt.getMatcher` to get an array of precomputed values\n   * that you can use to efficiently compare multiple instances\n   * to the same key-value pairs as shown in the examples below.\n   *\n   * @param {UnpackedInt|Matcher} matcher an object with key-value pairs,\n   *                                                or an array of precomputed matcher values\n   * @returns {boolean} whether the instance matches with the provided fields\n   * @example\n   * class Person extends BitField {}\n   * Person.fields = [\n   *  { name: 'age', size: 7 },\n   *  { name: 'gender', size: 1 },\n   * ];\n   * const person = new Person([20, 1]);\n   * person.match({ age: 20 });\n   * //=> true\n   * person.match({ gender: 1 });\n   * //=> true\n   * person.match({ gender: 1, age: 20 });\n   * //=> true\n   * person.match({ gender: 1, age: 19 });\n   * //=> false\n   *\n   * // use precomputed matcher\n   * const matcher = Person.getMatcher({ age: 20});\n   * new Person([20, 0]).match(matcher);\n   * //=> true\n   * new Person([19, 0]).match(matcher);\n   * //=> false\n   */\n  match(matcher) {\n    return this.constructor.match(this.value, Array.isArray(matcher)\n      ? matcher : this.constructor.getMatcher(matcher));\n  }\n\n  /**\n   * Returns the object representation of the instance,\n   * with field names as properties with corresponding values.\n   * @returns {UnpackedInt} the object representation of the instance\n   * @example\n   *\n   * class Person extends BitField {}\n   * Person.fields = [\n   *  { name: 'age', size: 7 },\n   *  { name: 'gender', size: 1 },\n   * ];\n   * const person = new Person([20, 1]);\n   * person.toObject();\n   * //=> { age: 20, gender: 1 }\n   */\n  toObject() {\n    return this.constructor.decode(this.value);\n  }\n\n  /**\n   * Returns a string representing the value of the instance.\n   *\n   * @returns {string} a string representing the value of the instance\n   */\n  toString() {\n    return this.value.toString();\n  }\n\n  /**\n   * Returns the numerical value of an instance.\n   * Returns a BigInt if the total size exceeds 53 bits.\n   *\n   * @returns {AnyNumber} the numerical value of the instance\n   */\n  valueOf() {\n    const { isBigInt, isSafe } = this.constructor;\n    return (isBigInt && isSafe) ? Number(this.value) : this.value;\n  }\n\n  /**\n   * Encodes a given list of numbers into a single number according to the schema.\n   *\n   * @param {Array<AnyNumber>} data the list of numbers to encode\n   * @returns {AnyNumber} encoded number\n   * @example\n   *\n   * class Person extends BitField {}\n   * Person.fields = [\n   *  { name: 'age', size: 7 },\n   *  { name: 'gender', size: 1 },\n   * ];\n   * Person.encode([20, 1])\n   * //=> 41\n   */\n  static encode(data) {\n    const { zero, fields, isBigInt } = this;\n    let result = zero;\n    for (let i = data.length - 1; i >= 0; i--) {\n      const current = data[i];\n      result <<= fields[i].size;\n      result |= (isBigInt ? BigInt(current) : current);\n    }\n    return result;\n  }\n\n  /**\n   * Decodes an encoded number into it's object representation according to the schema.\n   *\n   * @param {AnyNumber} data encoded number\n   * @returns {UnpackedInt} object representation\n   * @example\n   *\n   * class Person extends BitField {}\n   * Person.fields = [\n   *  { name: 'age', size: 7 },\n   *  { name: 'gender', size: 1 },\n   * ];\n   * Person.decode(41);\n   * //=> { age: 20, gender: 1 }\n   */\n  static decode(data) {\n    const { fields, masks } = this;\n    const result = {};\n    let value = data;\n    for (let i = 0; i < fields.length; i++) {\n      const { name, size } = fields[i];\n      result[name] = Number(value & masks[name]);\n      value >>= size;\n    }\n    return result;\n  }\n\n  /**\n   * Checks if a given set of values or all given pairs of field name and value\n   * are valid according to the schema.\n   *\n   * @param {AnyNumber|UnpackedInt} data pairs of field name and value to check\n   * @returns {boolean} whether all pairs are valid\n   * @example\n   *\n   * class Person extends BitField {}\n   * Person.fields = [\n   *  { name: 'age', size: 7 },\n   *  { name: 'gender', size: 1 },\n   * ];\n   * Person.isValid({age: 100})\n   * //=> true\n   * Person.isValid({age: 100, gender: 3})\n   * //=> false\n   * Person.isValid([100, 1])\n   * //=> true\n   * Person.isValid([100, 3])\n   * //=> false\n   */\n  static isValid(data) {\n    const { masks, fields } = this;\n    const selectedFields = Array.isArray(data)\n      ? fields.map((field, i) => [field.name, data[i]])\n      : Object.entries(data);\n    for (let i = 0; i < selectedFields.length; i++) {\n      const [field, value] = selectedFields[i];\n      if (((value & SIGN_BIT) !== value) || value > masks[field]) return false;\n    }\n    return true;\n  }\n\n  /**\n   * Returns the minimum amount of bits necessary to hold a given number.\n   *\n   * @param {number} number\n   * @returns {number} the amount of bits\n   * @example\n   *\n   * BitField.getMinSize(100)\n   * //=> 7\n   *\n   * BitField.getMinSize(2000)\n   * //=> 11\n   *\n   * BitField.getMinSize(Number.MAX_SAFE_INTEGER)\n   * //=> 53\n   */\n  static getMinSize(number) {\n    if (number < TWO_TO_48) return (Math.log2(number) | 0) + 1;\n    const n = BigInt(number);\n    const [zero, one, two] = [BigInt(0), BigInt(1), BigInt(2)];\n    let high = BigInt(MAX_SIZE);\n    let low = BigInt(48);\n\n    while (high - low > one) {\n      const mid = (high + low) / two;\n      const maskHigh = (one << high) - (one << mid);\n      if ((maskHigh & n) > zero) {\n        low = mid;\n      } else {\n        high = mid;\n      }\n    }\n    return Number(low + one);\n  }\n\n  /**\n   * Prepares the class to handle data according to it's schema provided in `BitField.fields`.\n   * The method is called automatically the first time the constructor is used.\n   *\n   * @returns {void}\n   */\n  static initialize() {\n    // determine total size and if BigInts are required\n    const totalSize = this.fields.reduce((result, field) => result += (field.size || 1), 0);\n    const isBigInt = totalSize > BITWISE_SIZE;\n    const [zero, one, two] = isBigInt ? [BigInt(0), BigInt(1), BigInt(2)] : [0, 1, 2];\n\n    // normalize fields, set masks and offsets\n    const fields = [];\n    const masks = {};\n    const offsets = {};\n    let lastOffset = zero;\n    for (let i = 0; i < this.fields.length; i++) {\n      const field = this.fields[i];\n      const name = field.name || field;\n      const size = isBigInt ? BigInt(field.size || 1) : field.size || 1;\n      masks[name] = (two << size - one) - one;\n      offsets[name] = lastOffset;\n      lastOffset += size;\n      fields.push({ name, size });\n    }\n\n    this.fields = fields;\n    this.size = totalSize;\n    this.mask = two << ((isBigInt ? BigInt(totalSize) : totalSize) - one);\n    this.isBigInt = isBigInt;\n    this.isSafe = totalSize <= MAX_SIZE;\n    this.zero = zero;\n    this.one = one;\n    this.two = two;\n    this.masks = masks;\n    this.offsets = offsets;\n    this.isInitialized = true;\n  }\n\n  /**\n   * Creates an array of values to be used as a matcher\n   * to efficiently match against multiple instances.\n   *\n   * @param {UnpackedInt} matcher an object containing field names and their values\n   * @returns {Matcher} an array of precomputed values\n   */\n  static getMatcher(matcher) {\n    const {\n      masks, offsets, zero, isBigInt,\n    } = this;\n    const fields = Object.keys(matcher);\n    let mask = zero;\n    let value = zero;\n    for (let i = 0; i < fields.length; i++) {\n      const fieldName = fields[i];\n      const fieldMask = masks[fieldName] << offsets[fieldName];\n      const fieldValue = isBigInt ? BigInt(matcher[fieldName]) : matcher[fieldName];\n      value = (value & ~fieldMask) | (fieldValue << offsets[fieldName]);\n      mask |= fieldMask;\n    }\n    return [value, this.mask ^ mask];\n  }\n\n  /**\n   * The static version of `BitField#match`, matches a given value against a precomputed matcher.\n   *\n   * @param {AnyNumber} value a value to check\n   * @param {Matcher} matcher a precomputed set of values\n   * @returns {boolean}\n   *\n   */\n  static match(value, matcher) {\n    return (value & matcher[1]) === matcher[0];\n  }\n\n  /**\n   * Allows iterating over numbers stored in the instance.\n   *\n   * @yields {number}\n   */\n  * [Symbol.iterator]() {\n    const { fields } = this.constructor;\n    for (let i = 0; i < fields.length; i++) {\n      yield this.get(fields[i].name);\n    }\n  }\n}\n\n/** @type {Array<FieldName>|Array<Field>} */\nBitField.fields = Array.from({ length: BITWISE_SIZE }, (e, i) => i);\n\n/** @type {number} */\nBitField.size = BITWISE_SIZE;\n\n/** @type {AnyNumber} */\nBitField.zero = 0;\n\n/** @type {AnyNumber} */\nBitField.one = 1;\n\n/** @type {AnyNumber} */\nBitField.two = 2;\n\n/** @type {Masks} */\nBitField.masks = undefined;\n\n/** @type {AnyNumber} */\nBitField.mask = TWO_TO_31;\n\n/** @type {Masks} */\nBitField.offsets = undefined;\n\n/** @type {boolean} */\nBitField.isBigInt = false;\n\n/** @type {boolean} */\nBitField.isSafe = false;\n\n/** @type {boolean} */\nBitField.isInitialized = false;\n\nmodule.exports = BitField;\n","/**\n * @typedef {Object} BitCoordinates\n * @property {number} bucket row index\n * @property {number} position column index\n */\n\n/**\n * Implements a grid or 2D matrix of bits.\n *\n * @extends Uint16Array\n */\nclass BinaryGrid extends Uint16Array {\n  /**\n   * @param {Object} [options]\n   * @param {number} [options.rows=1] the number of rows\n   * @param {number} [options.columns=16] the number of columns\n   * @param {...*} [args]\n   */\n  constructor(options = {}, ...args) {\n    const { columns = 16, rows = 1 } = options;\n    const offset = BinaryGrid.getOffset(columns);\n    if (args.length) {\n      super(...args);\n    } else {\n      const length = (rows << offset) >> 4;\n      super(length || 1);\n    }\n    Object.defineProperties(this, {\n      offset: { value: offset },\n      columns: { value: columns },\n      rows: { value: rows },\n      lastPosition: { value: Object.seal({ bucket: 0, position: 0 }) },\n    });\n  }\n\n  /**\n   * Returns the value of a bit at given coordinates.\n   *\n   * @param {number} row\n   * @param {number} column\n   * @returns {number}\n   */\n  get(row, column) {\n    const { bucket, position } = this.getBitPosition(row, column);\n    return (this[bucket] >> position) & 1;\n  }\n\n  /**\n   * Sets the value of a bit at given coordinates.\n   * Proxies to TypedArray#set if the first parameter is Array-like.\n   *\n   * @param {number|Collection} row\n   * @param {number} [column]\n   * @param {number} [value]\n   * @returns {BinaryGrid}\n   */\n  set(row, column, value = 1) {\n    if (row.length) {\n      super.set(row, column);\n      return this;\n    }\n    const { bucket, position } = this.getBitPosition(row, column);\n    this[bucket] = (this[bucket] & ~(1 << position)) | (value << position);\n    return this;\n  }\n\n  /**\n   * @private\n   * @param {number} row\n   * @param {number} column\n   * @returns {BitCoordinates}\n   */\n  getBitPosition(row, column) {\n    const index = (row << this.offset) + column;\n    const bucket = index >> 4;\n    this.lastPosition.bucket = bucket;\n    this.lastPosition.position = index - (bucket << 4);\n    return this.lastPosition;\n  }\n\n  /**\n   * @type {Uint16ArrayConstructor}\n   */\n  static get [Symbol.species]() {\n    return Uint16Array;\n  }\n\n  /**\n   * Returns the length of underlying Array required to hold the grid.\n   *\n   * @param {number} rows\n   * @param {number} columns\n   * @returns {number}\n   */\n  static getLength(rows, columns) {\n    return (rows << this.getOffset(columns)) >> 4;\n  }\n\n  /**\n   * @private\n   * @param {number} columns\n   * @returns {number}\n   */\n  static getOffset(columns) {\n    return Math.ceil(Math.log2(columns));\n  }\n}\n\nmodule.exports = BinaryGrid;\n","/**\n * Extends Array to implement the Binary Heap data structure.\n *\n * @extends Array\n */\nclass BinaryHeap extends Array {\n  /**\n   * @param {...*} args\n   */\n  constructor(...args) {\n    super(...args);\n    this.heapify();\n  }\n\n  /**\n   * Restores the binary heap.\n   *\n   * @returns {BinaryHeap}\n   */\n  heapify() {\n    for (let i = this.length >> 1; i >= 0; i--) {\n      this.siftDown(i);\n    }\n    return this;\n  }\n\n  /**\n   * Checks whether the array is a valid binary heap.\n   *\n   * @returns {boolean} whether the array is a valid binary heap\n   */\n  isHeap() {\n    return this.constructor.isHeap(this);\n  }\n\n  /**\n   * Returns the left child of an element at a given index.\n   *\n   * @param {number} index\n   * @returns {*}\n   */\n  left(index) {\n    return this[this.constructor.getLeftIndex(index)];\n  }\n\n  /**\n   * Returns the parent of an element at a given index.\n   *\n   * @param {number} index\n   * @returns {*}\n   */\n  parent(index) {\n    return this[this.constructor.getParentIndex(index)];\n  }\n\n  /**\n   * Adds items to the heap.\n   *\n   * @param {...*} elements\n   * @returns {number}\n   */\n  push(...elements) {\n    for (let i = 0; i < elements.length; i++) {\n      super.push(elements[i]);\n      this.siftUp(this.length - 1);\n    }\n    return this.length;\n  }\n\n  /**\n   * Returns the first (min/max) element of the heap and replaces it with a given element.\n   *\n   * @param {*} element\n   * @returns {*}\n   */\n  replace(element) {\n    const first = this[0];\n    this[0] = element;\n    this.siftDown(0);\n    return first;\n  }\n\n  /**\n   * Returns the right child of an element at a given index.\n   *\n   * @param {number} index\n   * @returns {*}\n   */\n  right(index) {\n    return this[this.constructor.getRightIndex(index)];\n  }\n\n  /**\n   * Extracts the first element of the heap.\n   *\n   * @returns {*}\n   */\n  shift() { // extract min/max\n    if (this.length < 2) return this.pop();\n    const item = this[0];\n    this[0] = this.pop();\n    this.siftDown(0);\n    return item;\n  }\n\n  /**\n   * Changes elements of the heap.\n   *\n   * @param {...*} args\n   * @returns {Array<*>}\n   */\n  splice(...args) {\n    const deletedItems = super.splice(...args);\n    const isSingle = deletedItems.length < 2 && args.length < 4;\n    if (isSingle) {\n      const index = args[0];\n      const isReplacement = args.length === 3;\n      if (isReplacement) {\n        this.update(index);\n      } else {\n        const last = this.pop();\n        super.splice(index, 0, last);\n        this.siftDown(index);\n      }\n    } else {\n      this.heapify();\n    }\n    return deletedItems;\n  }\n\n  /**\n   * Adds elements to the heap.\n   *\n   * @param {...*} items\n   * @returns {number}\n   */\n  unshift(...items) {\n    return this.push(...items);\n  }\n\n  /**\n   * Updates the position of an element inside the heap.\n   *\n   * @param {number} index\n   * @returns {void}\n   */\n  update(index) {\n    const { compare, getLeftIndex } = this.constructor;\n    const parent = this.parent(index);\n    const leftIndex = getLeftIndex(index);\n    if (this.has(leftIndex) && (parent === undefined || compare(parent, this[index]))) {\n      this.siftDown(index);\n    } else {\n      this.siftUp(index);\n    }\n  }\n\n  /**\n   * @private\n   * @param {number} index\n   * @returns {boolean}\n   */\n  has(index) {\n    return index >= 0 && index < this.length;\n  }\n\n  /**\n   * @private\n   * @param {number} start\n   * @returns {void}\n   */\n  siftDown(start) {\n    const { getRightIndex, getLeftIndex, compare } = this.constructor;\n    let index = start;\n    let leftIndex = getLeftIndex(index);\n    let rightIndex = getRightIndex(index);\n    let nextIndex;\n    while (this.has(leftIndex)) {\n      if (this.has(rightIndex) && compare(this[rightIndex], this[leftIndex])) {\n        nextIndex = rightIndex;\n      } else {\n        nextIndex = leftIndex;\n      }\n\n      if (compare(this[index], this[nextIndex])) break;\n      [this[index], this[nextIndex]] = [this[nextIndex], this[index]];\n      index = nextIndex;\n      leftIndex = getLeftIndex(index);\n      rightIndex = getRightIndex(index);\n    }\n  }\n\n  /**\n   * @private\n   * @param {number} start\n   * @returns {void}\n   */\n  siftUp(start) {\n    const { getParentIndex, compare } = this.constructor;\n    let index = start;\n    let parentIndex = getParentIndex(index);\n    while (this.has(parentIndex) && !compare(this[parentIndex], this[index])) {\n      [this[index], this[parentIndex]] = [this[parentIndex], this[index]];\n      index = parentIndex;\n      parentIndex = getParentIndex(index);\n    }\n  }\n\n  /**\n   * @private\n   */\n  static get [Symbol.species]() {\n    return Array;\n  }\n\n  /**\n   * The comparator function used by the heap.\n   *\n   * @param {*} a\n   * @param {*} b\n   * @returns {boolean}\n   */\n  static compare(a, b) {\n    return a < b;\n  }\n\n  /**\n   * Creates a new BinaryHeap from a given array-like object.\n   *\n   * @param {*} arrayLike an array-like object to convert to a heap\n   * @param {Function} mapFn a map function to call on every element of the array\n   * @param {Object} thisArg the value to use as `this` when invoking the `mapFn`\n   * @returns {SortedCollection} a new BinaryHeap\n   */\n  static from(arrayLike, mapFn, thisArg) {\n    return super.from(arrayLike, mapFn, thisArg).heapify();\n  }\n\n  /**\n   * @private\n   * @param {number} index\n   * @returns {number}\n   */\n  static getLeftIndex(index) {\n    return (index << 1) + 1;\n  }\n\n  /**\n   * @private\n   * @param {number} index\n   * @returns {number}\n   */\n  static getParentIndex(index) {\n    return (index - 1) >> 1;\n  }\n\n  /**\n   * @private\n   * @param {number} index\n   * @returns {number}\n   */\n  static getRightIndex(index) {\n    return (index << 1) + 2;\n  }\n\n  /**\n   * Checks if a given collection is a valid binary heap.\n   *\n   * @param {Collection} heap\n   * @returns {boolean}\n   */\n  static isHeap(heap) {\n    for (let i = heap.length - 1; i > -1; i--) {\n      const parentIndex = this.getParentIndex(i);\n      if (parentIndex < 0) break;\n      if (!this.compare(heap[parentIndex], heap[i])) return false;\n    }\n    return true;\n  }\n\n  /**\n   * Creates a new BinaryHeap with a variable number of arguments,\n   * regardless of number or type of the arguments.\n   *\n   * @param {...*} elements the elements of which to create the heap\n   * @returns {SortedCollection} the new BinaryHeap\n   */\n  static of(...elements) {\n    return super.of(...elements).heapify();\n  }\n}\n\nmodule.exports = BinaryHeap;\n","const BinaryGrid = require('./binary-grid');\nconst BinaryHeap = require('./binary-heap');\n\n/**\n * @private\n * @extends BinaryHeap\n */\nclass VertexHeap extends BinaryHeap {\n  static compare(a, b) {\n    return a.w < b.w;\n  }\n}\n\n/**\n * @typedef {UnweightedAdjacencyList | UnweightedAdjacencyMatrix\n    | WeightedAdjacencyList | WeightedAdjacencyMatrix} AdjacencyStructure\n */\n\n/**\n * Creates a Graph class extending a given adjacency structure.\n *\n * @param {AdjacencyStructure} Base\n * @param {boolean} [undirected=false]\n * @returns {Graph}\n */\nfunction GraphMixin(Base, undirected = false) {\n  /**\n   * Extends an adjacency list/matrix structure and provides methods for traversal (BFS, DFS),\n   * pathfinding (Dijkstra, Bellman-Ford), spanning tree construction (BFS, Prim), etc.\n   *\n   * @extends AdjacencyStructure\n   */\n  class Graph extends Base {\n    /**\n     * @param {Object} options\n     * @param {number} options.vertices\n     * @param {number} [options.edges]\n     * @param {number} [options.pad]\n     * @param {...*} args\n     */\n    constructor(options, ...args) {\n      super(options, ...args);\n      const colors = new BinaryGrid({ rows: 2, columns: options.vertices });\n      Object.defineProperties(this, {\n        colors: { value: colors },\n      });\n    }\n\n    /**\n     * Checks if a vertex is entered during a traversal.\n     *\n     * @param {number} vertex the vertex\n     * @returns {boolean}\n     */\n    isGray(vertex) {\n      return !!this.colors.get(0, vertex);\n    }\n\n    /**\n     * Marks a vertex as entered during a traversal.\n     *\n     * @param {number} vertex the vertex\n     * @returns {Graph}\n     */\n    setGray(vertex) {\n      this.colors.set(0, vertex);\n      return this;\n    }\n\n    /**\n     * Checks if a vertex has been fully processed during a traversal.\n     *\n     * @param {number} vertex the vertex\n     * @returns {boolean}\n     */\n    isBlack(vertex) {\n      return !!this.colors.get(1, vertex);\n    }\n\n    /**\n     * Marks a vertex as fully processed during a traversal.\n     *\n     * @param {number} vertex the vertex\n     * @returns {Graph}\n     */\n    setBlack(vertex) {\n      this.colors.set(1, vertex);\n      return this;\n    }\n\n    /**\n     * Resets all coloring of vertices done during traversals.\n     *\n     * @private\n     * @returns {Graph}\n     */\n    resetColors() {\n      this.colors.fill(0);\n      return this;\n    }\n\n    /**\n     * Does a Breadth-First or Depth-First traversal of the graph.\n     *\n     * @generator\n     * @param {boolean} [isDFS=false] whether to do DFS traversal, does BFS otherwise\n     * @param {number} [start=0] the vertex to start at\n     * @param {boolean} [gray=true] whether to return vertices upon entering\n     * @param {boolean} [white=false] whether to return edges upon first encountering\n     * @param {boolean} [black=false] whether to return vertices after processing\n     * @yields {number} the vertex at each step\n     */\n    * traverse(isDFS, start = 0, gray = true, white, black) {\n      this.resetColors();\n      const processing = [start];\n      const [push, pull] = isDFS ? ['push', 'pop'] : ['push', 'shift'];\n      while (processing.length) {\n        const vertex = processing[pull]();\n        this.setGray(vertex);\n        if (gray) yield vertex;\n        for (const edge of this.outEdges(vertex)) {\n          if (!this.isGray(edge)) {\n            processing[push](edge);\n          }\n          if (white) yield edge;\n        }\n        this.setBlack(vertex);\n        if (black) yield vertex;\n      }\n    }\n\n    /**\n     * Checks whether the graph is acyclic.\n     *\n     * @returns {boolean}\n     */\n    isAcyclic() {\n      for (const vertex of this.traverse(true, 0, false, true)) {\n        if (this.isGray(vertex)) return false;\n      }\n      return true;\n    }\n\n    /**\n     * Returns a list of vertexes sorted topologically.\n     *\n     * @returns {Array<number>}\n     */\n    topologicalSort() {\n      return [...this.traverse(true, 0, false, false, true)];\n    }\n\n    /**\n     * Returns a list of vertices along the shortest path between two given vertices.\n     *\n     * @param {number} start the starting vertex\n     * @param {number} end the ending vertex\n     * @param {boolean} [isAcyclic=false] whether the graph is acyclic\n     * @param {boolean} [isNonNegative=false] whether all edges are non-negative\n     * @returns {Array<number>}\n     */\n    path(start, end, isAcyclic, isNonNegative) {\n      const { weighted } = this.constructor;\n      const { vertices } = this;\n      const predecessors = new Array(vertices).fill(-1);\n      const distances = new Array(vertices).fill(Infinity);\n      const isFound = !weighted ? this.searchUnweighted(start, end, predecessors)\n        : isAcyclic ? this.searchTopological(start, end, distances, predecessors)\n          : isNonNegative ? this.searchDijkstra(start, end, distances, predecessors)\n            : this.searchBellmanFord(start, end, distances, predecessors);\n      if (!isFound) return [];\n      const path = [];\n      let last = end;\n      while (~last) {\n        path.unshift(last);\n        last = predecessors[last];\n      }\n      return path;\n    }\n\n    /**\n     * For unweighted graphs.\n     *\n     * @private\n     * @param {number} start the starting vertex\n     * @param {number} [end] the ending vertex\n     * @param {Array<number>} predecessors\n     * @returns {boolean}\n     */\n    searchUnweighted(start, end, predecessors) {\n      let lastPredecessor = start;\n      let isFound = false;\n      for (const vertex of this.traverse(false, start, true, true)) {\n        if (!this.isGray(vertex)) {\n          predecessors[vertex] = lastPredecessor;\n        } else {\n          lastPredecessor = vertex;\n        }\n        if (vertex === end) {\n          isFound = true;\n          break;\n        }\n      }\n      return isFound;\n    }\n\n    /**\n     * For DAGs only.\n     *\n     * @private\n     * @param {number} start\n     * @param {number} end\n     * @param {Array<number>} distances\n     * @param {Array<number>} predecessors\n     * @returns {boolean}\n     */\n    searchTopological(start, end, distances, predecessors) {\n      distances[start] = 0;\n      let lastPredecessor = start;\n      let isFound = false;\n      for (const vertex of this.traverse(true, start, true, true)) {\n        if (!this.isGray(vertex)) {\n          const weight = this.getEdge(lastPredecessor, vertex);\n          if (distances[vertex] > distances[lastPredecessor] + weight) {\n            distances[vertex] = distances[lastPredecessor] + weight;\n            predecessors[vertex] = lastPredecessor;\n          }\n        } else if (!this.isBlack(vertex)) {\n          lastPredecessor = vertex;\n        }\n        if (vertex === end) {\n          isFound = true;\n        }\n      }\n      return isFound;\n    }\n\n    /**\n     * For non-negative edges.\n     *\n     * @private\n     * @param {number} start\n     * @param {number} end\n     * @param {Array<number>} distances\n     * @param {Array<number>} predecessors\n     * @returns {boolean}\n     */\n    searchDijkstra(start, end, distances, predecessors) {\n      this.resetColors();\n      const heap = new VertexHeap();\n      distances[start] = 0;\n      heap.push({ e: start, w: this[start] });\n      let isFound = false;\n      while (heap.length) {\n        const vertex = heap.shift();\n        if (this.isGray(vertex.e)) continue;\n        this.setGray(vertex.e);\n        for (const edge of this.outEdges(vertex.e)) {\n          const weight = this.getEdge(vertex.e, edge);\n          const distance = distances[vertex.e] + weight;\n          if (distance < distances[edge]) {\n            distances[edge] = distance;\n            predecessors[edge] = vertex.e;\n            heap.push({ e: edge, w: distance });\n          }\n          if (edge === end) {\n            isFound = true;\n          }\n        }\n      }\n      return isFound;\n    }\n\n    /**\n     * For all.\n     *\n     * @private\n     * @param {number} start\n     * @param {number} end\n     * @param {Array<number>} distances\n     * @param {Array<number>} predecessors\n     * @returns {boolean}\n     */\n    searchBellmanFord(start, end, distances, predecessors) {\n      const { vertices } = this;\n      distances[start] = 0;\n      let isFound = false;\n      for (let i = 0; i < vertices; i++) {\n        for (const edge of this.outEdges(i)) {\n          const weight = this.getEdge(i, edge);\n          const distance = distances[i] + weight;\n          if (distances[edge] > distance) {\n            distances[edge] = distance;\n            predecessors[edge] = i;\n            if (edge === end) {\n              isFound = true;\n            }\n          }\n        }\n      }\n      return isFound;\n    }\n\n    /**\n     * Returns a minimal spanning tree of the graph.\n     * Uses the Prim's algorithm for weighted graphs and BFS tree for unweighted graphs.\n     *\n     * @param {number} [start=0]\n     * @returns {Array<number>}\n     */\n    tree(start = 0) {\n      const { weighted } = this.constructor;\n      const { vertices } = this;\n      const predecessors = new Array(vertices).fill(-1);\n      if (!weighted) {\n        this.searchUnweighted(start, undefined, predecessors);\n        return predecessors;\n      }\n      this.resetColors();\n      const distances = new Array(vertices).fill(Infinity);\n      const heap = new VertexHeap();\n      distances[start] = 0;\n      heap.push({ e: start, w: this[0] });\n      while (heap.length) {\n        const vertex = heap.shift();\n        if (this.isGray(vertex.e)) continue;\n        this.setGray(vertex.e);\n        for (const edge of this.outEdges(vertex.e)) {\n          const weight = this.getEdge(vertex.e, edge);\n          if (this.isGray(edge) || weight > distances[edge]) continue;\n          distances[edge] = weight;\n          predecessors[edge] = vertex.e;\n          heap.push({ e: edge, w: weight });\n        }\n      }\n      return predecessors;\n    }\n  }\n\n  Graph.undirected = undirected;\n\n  return Graph;\n}\n\nmodule.exports = GraphMixin;\n","/**\n * @typedef {Int8ArrayConstructor |\n * Int8ArrayConstructor |\n * Uint8ArrayConstructor |\n * Uint8ClampedArrayConstructor |\n * Int16ArrayConstructor |\n * Uint16ArrayConstructor |\n * Int32ArrayConstructor |\n * Uint32ArrayConstructor |\n * Float32ArrayConstructor |\n * Float64ArrayConstructor} TypedArrayConstructor\n */\n\n/**\n * @typedef {ArrayConstructor|TypedArrayConstructor} CollectionConstructor\n */\n\n/**\n * @typedef {Int8Array |\n * Uint8Array |\n * Uint8ClampedArray |\n * Int16Array |\n * Uint16Array |\n * Int32Array |\n * Uint32Array |\n * Float32Array |\n * Float64Array} TypedArray\n */\n\n/**\n * @typedef {Array|TypedArray} Collection\n */\n\n/**\n * @typedef {Object} Coordinates\n * @property {number} row row index\n * @property {number} column column index\n */\n\n/**\n * Creates a Grid class extending a given Array-like class.\n *\n * @param {CollectionConstructor} Base\n * @returns {Grid}\n * @example\n *\n * const ArrayGrid = Grid(Array);\n */\nfunction GridMixin(Base) {\n  /**\n   * Extends built-in indexed collections to handle 2 dimensional data.\n   *\n   * @extends CollectionConstructor\n   */\n  class Grid extends Base {\n    /**\n     * Passes all arguments to the Base class except if called with a special set of grid options,\n     * in that case creates and empty grid of specified parameters.\n     *\n     * @param {Object} [options]\n     * @param {number} [options.rows=1] the number of rows\n     * @param {number} [options.columns=2] the number of columns\n     * @param {*} [options.pad=0] the initial value of cells\n     * @param {...*} [args]\n     * @example\n     *\n     * new ArrayGrid('a')\n     * //=> ArrayGrid ['a']\n     *\n     * new ArrayGrid(2)\n     * //=> ArrayGrid [undefined, undefined]\n     *\n     * new ArrayGrid({ rows: 3, columns: 2 })\n     * //=> ArrayGrid [0, 0, 0, 0, 0, 0]\n     *\n     * new ArrayGrid({ rows: 3, columns: 2, pad: 1 })\n     * //=> ArrayGrid [1, 1, 1, 1, 1, 1]\n     */\n    constructor(options = {}, ...args) {\n      const { columns = 2, rows = 1, pad = 0 } = options;\n      const offset = Grid.getOffset(columns);\n      if (args.length) {\n        super(...args);\n      } else {\n        const length = rows << offset;\n        super(length);\n        this.fill(pad);\n      }\n      Object.defineProperties(this, {\n        offset: { value: offset, writable: true },\n        pad: { value: pad, writable: true },\n        lastCoordinates: { value: Object.seal({ row: 0, column: 0 }) },\n      });\n    }\n\n    /**\n     * Specifies the number of columns of the grid.\n     *\n     * @param {number} columns\n     * @returns {void}\n     */\n    set columns(columns) {\n      this.offset = Grid.getOffset(columns);\n    }\n\n    /**\n     * Number of columns in the grid.\n     * @type {number}\n     */\n    get columns() {\n      return 1 << this.offset;\n    }\n\n    /**\n     * Number of rows in the grid.\n     * @type {number}\n     */\n    get rows() {\n      return this.length >> this.offset;\n    }\n\n    /**\n     * Returns an array index of an element at given coordinates.\n     *\n     * @param {number} row\n     * @param {number} column\n     * @returns {*}\n     * @example\n     *\n     * const a = ArrayGrid({ rows: 3, columns: 2, pad: 3});\n     * a.get(1, 0);\n     * //=> 2\n     */\n    getIndex(row, column) {\n      return (row << this.offset) + column;\n    }\n\n    /**\n     * Returns an element from given coordinates.\n     *\n     * @param {number} row\n     * @param {number} column\n     * @returns {*}\n     * @example\n     *\n     * const a = ArrayGrid({ rows: 3, columns: 2, pad: 3});\n     * a.get(0, 1);\n     * //=> 3\n     */\n    get(row, column) {\n      return this[this.getIndex(row, column)];\n    }\n\n    /**\n     * Sets the element at given coordinates.\n     * Proxies to TypedArray#set if the first parameter is Array-like\n     * and the grid is based on a TypedArray.\n     *\n     * @param {number|Collection} row\n     * @param {number} [column]\n     * @param {*} [value]\n     * @returns {Grid} the instance\n     * @example\n     *\n     * const a = ArrayGrid({ rows: 3, columns: 2, pad: 3});\n     * a.set(0, 1, 5);\n     * a.get(0, 1);\n     * //=> 5\n     */\n    set(row, column, value) {\n      if (row.length && super.set) {\n        super.set(row, column);\n        return this;\n      }\n      this[this.getIndex(row, column)] = value;\n      return this;\n    }\n\n    /**\n     * Implements in-place replacement of the grid elements if it's based on Array.\n     * Proxies to TypedArray#set if the grid is based on a TypedArray.\n     *\n     * @param {Collection} array\n     * @param {number} [offset]\n     * @returns {void}\n     */\n    setArray(array, offset) {\n      if (super.set) {\n        super.set(array, offset);\n      } else {\n        this.length = array.length;\n        for (let i = 0; i < array.length; i++) {\n          this[i] = array[i];\n        }\n      }\n    }\n\n    /**\n     * Gets coordinates of an element at specified index.\n     *\n     * @param {number} index\n     * @returns {Coordinates} coordinates\n     * @example\n     * const a = ArrayGrid({ rows: 3, columns: 2, pad: 3});\n     * a.getCoordinates(1);\n     * //=> [0, 1]\n     * a.getCoordinates(2);\n     * //=> [1, 0]\n     */\n    getCoordinates(index) {\n      this.lastCoordinates.row = index >> this.offset;\n      this.lastCoordinates.column = index - (this.lastCoordinates.row << this.offset);\n      return this.lastCoordinates;\n    }\n\n    /**\n     * Returns an array of arrays where each nested array correspond to a row in the grid.\n     *\n     * @param {boolean} [withPadding=false] whether to remove padding from the end of the rows\n     * @returns {Array<Array<*>>}\n     * @example\n     *\n     * const a = ArrayGrid({ rows: 3, columns: 2, pad: 3});\n     * a.toArrays();\n     * //=> [[3, 3], [3, 3], [3, 3]]\n     */\n    toArrays(withPadding) {\n      const { rows, columns } = this;\n      const begin = new Uint32Array(rows).map((b, i) => i << this.offset);\n      const result = new Array(rows);\n\n      for (let i = 0; i < rows; i++) {\n        const beginning = begin[i];\n        if (withPadding) {\n          result[i] = this.slice(beginning, beginning + columns);\n          continue;\n        }\n        for (let j = beginning + columns - 1; j >= beginning; j--) {\n          if (this[j] !== this.pad) {\n            result[i] = this.slice(beginning, j + 1);\n            break;\n          }\n        }\n      }\n\n      return result;\n    }\n\n    /**\n     * @type {CollectionConstructor}\n     */\n    static get [Symbol.species]() {\n      return Base;\n    }\n\n    /**\n     * Returns the length of underlying Array required to hold the grid.\n     *\n     * @param {number} rows\n     * @param {number} columns\n     * @returns {number}\n     */\n    static getLength(rows, columns) {\n      return rows << this.getOffset(columns);\n    }\n\n    /**\n     * @private\n     * @param {number} columns\n     * @returns {number}\n     */\n    static getOffset(columns) {\n      return Math.ceil(Math.log2(columns));\n    }\n\n    /**\n     * Creates a grid from an array of arrays.\n     *\n     * @param {Array<Array<*>>} arrays\n     * @param {*} [pad=0] the value to pad the arrays to create equal sized rows\n     * @returns {Grid}\n     *\n     * const a = ArrayGrid.from([[1, 2], [3], [4, 5, 6]])\n     * //=> ArrayGrid [1, 2, 0, 0, 3, 0, 0, 0, 4, 5, 6, 0]\n     * a.get(1, 0);\n     * //=> 3\n     * a.get(2, 1);\n     * //=> 5\n     */\n    static fromArrays(arrays, pad = 0) {\n      const rows = arrays.length;\n\n      // find longest array to get the column size\n      let columns = arrays[0].length; // if !arrays[0].length\n      for (let i = 0; i < rows; i++) {\n        if (arrays[i].length > columns) columns = arrays[i].length;\n      }\n      const offset = this.getOffset(columns);\n      columns = 1 << offset;\n\n      // create grid of the required length\n      const grid = new this({ rows, columns, pad });\n\n      // fill the grid with values from arrays\n      for (let i = 0; i < rows; i++) {\n        for (let j = 0; j < arrays[i].length; j++) {\n          grid.set(i, j, arrays[i][j]);\n        }\n      }\n\n      return grid;\n    }\n  }\n\n  return Grid;\n}\n\nmodule.exports = GridMixin;\n","/**\n * Uses Uint32Array as a vector or array of bits.\n *\n * @extends Uint32Array\n */\nclass BitArray extends Uint32Array {\n  /**\n   * @param {number} [size=32] the number of bits\n   * @param {...*} [args]\n   */\n  constructor(size = 32, ...args) {\n    if (size.length || size instanceof ArrayBuffer) {\n      super(size, ...args);\n    } else {\n      super(new.target.getLength(size));\n    }\n    Object.defineProperties(this, {\n      lastPosition: { value: Object.seal({ bucket: 0, position: 0 }) },\n    });\n  }\n\n  /**\n   * Returns the bit value at a given index.\n   *\n   * @param {number} index\n   * @returns {number}\n   */\n  getBit(index) {\n    const { bucket, position } = this.getBitPosition(index);\n    return (this[bucket] >> position) & 1;\n  }\n\n  /**\n   * Sets the bit value at a given index.\n   *\n   * @param {number} index\n   * @param {number} [value=1]\n   * @returns {BitArray}\n   */\n  setBit(index, value = 1) {\n    const { bucket, position } = this.getBitPosition(index);\n    this[bucket] = (this[bucket] & ~(1 << position)) | (value << position);\n    return this;\n  }\n\n  /**\n   * Returns the amount of available bits in the array.\n   *\n   * @type {number}\n   */\n  get size() {\n    return this.length << 5;\n  }\n\n  /**\n   * @protected\n   * @param {number} index\n   * @returns {BitCoordinates}\n   */\n  getBitPosition(index) {\n    const bucket = index >> 5;\n    this.lastPosition.bucket = bucket;\n    this.lastPosition.position = index - (bucket << 5);\n    return this.lastPosition;\n  }\n\n  /**\n   * Returns the length of underlying TypedArray required to hold the bit array.\n   *\n   * @param {number} size\n   * @returns {number}\n   */\n  static getLength(size) {\n    return Math.ceil(size / 32);\n  }\n\n  /**\n   * @type {Uint32ArrayConstructor}\n   */\n  static get [Symbol.species]() {\n    return Uint32Array;\n  }\n}\n\nmodule.exports = BitArray;\n","const log2 = {\n  1: 0,\n  2: 1,\n  4: 2,\n  8: 3,\n  16: 4,\n  32: 5,\n  64: 6,\n  128: 7,\n  256: 8,\n  512: 9,\n  1024: 10,\n  2048: 11,\n  4096: 12,\n  8192: 13,\n  16384: 14,\n  32768: 15,\n  65536: 16,\n  131072: 17,\n  262144: 18,\n  524288: 19,\n  1048576: 20,\n  2097152: 21,\n  4194304: 22,\n  8388608: 23,\n  16777216: 24,\n  33554432: 25,\n  67108864: 26,\n  134217728: 27,\n  268435456: 28,\n  536870912: 29,\n  1073741824: 30,\n  2147483648: 31,\n};\n\n/**\n * Counts set bits in a given number.\n *\n * @param {number} value\n * @returns {number}\n */\nfunction popCount32(value) {\n  const a = value - ((value >> 1) & 0x55555555);\n  const b = (a & 0x33333333) + ((a >> 2) & 0x33333333);\n  return ((b + (b >> 4) & 0xF0F0F0F) * 0x1010101) >> 24;\n}\n\n/**\n * Returns the index of the Least Significant Bit in a number.\n *\n * @param {number} value\n * @returns {number}\n */\nfunction getLSBIndex(value) {\n  if (value === 2147483648) return 31;\n  return log2[value & -value];\n}\n\n/**\n * Returns a multiple of a base number that is greater or equal to a given value.\n *\n * @param {number} value\n * @param {number} base\n * @returns {number}\n */\nfunction getGTEMultiple(value, base) {\n  return ((value - 1) | (base - 1)) + 1;\n}\n\nmodule.exports = {\n  log2,\n  popCount32,\n  getLSBIndex,\n  getGTEMultiple,\n};\n","const BitArray = require('./bit-array');\nconst utilities = require('./utilities');\n\n/**\n * Manages availability of objects in object pools.\n *\n * @extends BitArray\n */\nclass Pool extends BitArray {\n  /**\n   * @param {number} size the size of the pool\n   */\n  constructor(size) {\n    super(size);\n    this.fill(4294967295);\n    Object.defineProperties(this, {\n      nextAvailable: { value: 0, writable: true },\n    });\n  }\n\n  /**\n   * Gets the next available index in the pool.\n   *\n   * @returns {number} the next available index\n   */\n  get() {\n    const { nextAvailable } = this;\n    if (!~nextAvailable) return -1;\n    const record = this[nextAvailable];\n    const index = utilities.getLSBIndex(record);\n    this[nextAvailable] &= ~(1 << index);\n\n    // record is full, find next empty\n    if (this[nextAvailable] === 0) {\n      this.nextAvailable = -1;\n      for (let i = 0; i < this.length; i++) {\n        if (this[i] !== 0) {\n          this.nextAvailable = i;\n          break;\n        }\n      }\n    }\n\n    return (nextAvailable << 5) + index;\n  }\n\n  /**\n   * Makes a given index available.\n   *\n   * @param {number} index index to be freed\n   * @returns {void}\n   */\n  free(index) {\n    const { bucket, position } = this.getBitPosition(index);\n    this[bucket] |= 1 << position;\n    this.nextAvailable = bucket;\n  }\n}\n\nmodule.exports = Pool;\n","const BitArray = require('./bit-array');\nconst utilities = require('./utilities');\n\n/**\n * A bit array that supports constant time rank and O(logN) time select operations.\n *\n * @extends BitArray\n */\nclass RankedBitArray extends BitArray {\n  /**\n   * Sets the bit value at a given index.\n   *\n   * @param {number} index\n   * @param {number} [value=1]\n   * @returns {RankedBitArray}\n   */\n  setBit(index, value = 1) {\n    super.setBit(index, value);\n    const change = value || -1;\n    for (let i = (this.length >> 1) + this.lastPosition.bucket; i < this.length; i++) {\n      this[i] += change;\n    }\n    return this;\n  }\n\n  /**\n   * Returns the amount of available bits in the array.\n   *\n   * @type {number}\n   */\n  get size() {\n    return (this.length >> 1) << 5;\n  }\n\n  /**\n   * Returns the rank of a bit at a given index.\n   *\n   * @param {number} index\n   * @returns {number}\n   */\n  rank(index) {\n    const { bucket, position } = this.getBitPosition(index);\n    const value = this[bucket];\n    // mask out following bits\n    const masked = value & ((1 << position) - 1);\n    const localRank = utilities.popCount32(masked);\n    const bucketRank = bucket ? this[(this.length >> 1) + bucket - 1] : 0;\n    return bucketRank + localRank;\n  }\n\n  /**\n   * Returns the select of a bit at a given index.\n   *\n   * @param {number} index\n   * @returns {number}\n   */\n  select(index) {\n    const middle = this.length >> 1;\n    let left = middle;\n    let right = this.length - 1;\n    let bucketRankId = 0;\n    while (left <= right) {\n      bucketRankId = (right + left) >> 1;\n      if (index > this[bucketRankId]) {\n        left = bucketRankId + 1;\n      } else if (index < this[bucketRankId]) {\n        right = bucketRankId - 1;\n      } else if (index === this[bucketRankId - 1]) { // preceded by a duplicate\n        right = bucketRankId - 1;\n      } else {\n        break;\n      }\n    }\n    bucketRankId = index === this[bucketRankId] ? bucketRankId : left;\n\n    if (bucketRankId >= this.length) return -1;\n\n    let rank = bucketRankId > middle ? this[bucketRankId - 1] : 0;\n    const bucket = bucketRankId - middle;\n    let value = this[bucket];\n    while (value) {\n      const position = utilities.getLSBIndex(value);\n      value &= value - 1;\n      rank++;\n      if (rank === index) {\n        return (bucket << 5) + position;\n      }\n    }\n  }\n\n  /**\n   * Returns the length of underlying TypedArray required to hold the bit array.\n   *\n   * @param {number} size\n   * @returns {number}\n   */\n  static getLength(size) {\n    return Math.ceil(size / 32) << 1;\n  }\n}\n\nmodule.exports = RankedBitArray;\n","/**\n * @private\n */\nconst ZERO_CHAR = String.fromCharCode(0);\n\n/**\n * Extends Uint8Array to handle C-like representation of UTF-8 encoded strings.\n *\n * @extends Uint8Array\n */\nclass StringView extends Uint8Array {\n  /**\n   * Iterates over the characters in the StringView.\n   *\n   * @yields {string}\n   * @example\n   * const stringView = StringView.fromString('abc');\n   * [...stringView.characters()]\n   * //=> ['a', 'b', 'c', '']\n   */\n  * characters() {\n    for (let i = 0; i < this.length; i++) {\n      if (this[i] >> 6 !== 2) {\n        yield this.toChar(i);\n      }\n    }\n  }\n\n  /**\n   * Returns a new string consisting of the single UTF character\n   * located at the specified character index.\n   *\n   * @param {number} [index=0] a character index\n   * @returns {string} a string representing the character\n   * @example\n   * const stringView = StringView.fromString('abc');\n   * stringView.charAt(0);\n   * //=> 'a'\n   * stringView.charAt(3);\n   * //=> ''\n   */\n  charAt(index = 0) {\n    return this.toChar(this.getCharStart(index));\n  }\n\n  /**\n   * @private\n   * @param {number} index\n   * @returns {number}\n   */\n  getCharEnd(index) {\n    const point = this[index];\n    if (point < 0x80) return index;\n    switch ((point & 0xF0) >> 4) {\n      case 0xF: return index + 3;\n      case 0xE: return index + 2;\n      case 0xD:\n      case 0xC: return index + 1;\n      default: return -1;\n    }\n  }\n\n  /**\n   * @private\n   * @param {number} index\n   * @param {number} [startCharIndex=-1]\n   * @param {number} [startIndex=0]\n   * @returns {number}\n   */\n  getCharStart(index, startCharIndex = -1, startIndex = 0) {\n    let current = startCharIndex;\n    for (let i = startIndex; i < this.length; i++) {\n      if (this[i] >> 6 !== 2) current++;\n      if (current === index) return i;\n    }\n    return -1;\n  }\n\n  /**\n   * Performs an in-place replacement within the StringView\n   * of all occurrences of a given pattern with a given replacement.\n   *\n   * @param {Collection} pattern the pattern to be replaced\n   * @param {Collection} replacement the replacement\n   * @returns {StringView}\n   * @example\n   * const stringView = StringView.fromString('abca');\n   * const pattern = StringView.fromString('a');\n   * const replacement = StringView.fromString('d');\n   * stringView.replace(pattern, replacement).toString();\n   * //=> 'dbcd'\n   */\n  replace(pattern, replacement) {\n    let position = 0;\n    while (position < this.length) {\n      const currentIndex = this.search(pattern, position);\n      if (!~currentIndex) break;\n      this.set(replacement, currentIndex);\n      position = currentIndex + replacement.length;\n    }\n    return this;\n  }\n\n  /**\n   * Reverses the characters of the StringView in-place.\n   *\n   * @returns {StringView}\n   * @example\n   * const stringView = StringView.fromString('abca');\n   * stringView.reverse().toString();\n   * //=> 'acba'\n   */\n  reverse() {\n    const last = this.length - 1;\n    for (let i = 0, j = last; i < j; i++, j--) {\n      [this[i], this[j]] = [this[j], this[i]];\n    }\n    let j = this.length;\n    while (--j > 0) {\n      switch ((this[j] & 0xF0) >> 4) {\n        case 0xF:\n          [this[j], this[j - 3]] = [this[j - 3], this[j]];\n          [this[j - 1], this[j - 2]] = [this[j - 2], this[j - 1]];\n          j -= 3;\n          break;\n        case 0xE:\n          [this[j], this[j - 2]] = [this[j - 2], this[j]];\n          j -= 2;\n          break;\n        case 0xC:\n        case 0xD:\n          [this[j], this[j - 1]] = [this[j - 1], this[j]];\n          j--;\n          break;\n        default:\n          break;\n      }\n    }\n    return this;\n  }\n\n  /**\n   * Returns the index within the calling StringView\n   * of the first occurrence of the specified value, starting the search at start.\n   * Returns -1 if the value is not found.\n   *\n   * @param {Collection} searchValue the value to search for\n   * @param {number} [fromIndex=0] the index at which to start the search\n   * @returns {number} the index of the first occurrence of the specified value\n   * @example\n   * const stringView = StringView.fromString('abca');\n   * const searchValue = StringView.fromString('');\n   * stringView.search(searchValue);\n   * //=> 3\n   */\n  search(searchValue, fromIndex = 0) {\n    if (this.length > 256 && searchValue.length < 32) {\n      return this.searchShiftOr(searchValue, fromIndex);\n    }\n    return this.searchNaive(searchValue, fromIndex);\n  }\n\n  /**\n   * @private\n   * @param {Collection} searchValue\n   * @param {number} start\n   * @returns {number}\n   */\n  searchNaive(searchValue, start) {\n    const wordLength = searchValue.length;\n    const max = this.length - wordLength;\n    outer: for (let i = start; i <= max; i++) {\n      for (let j = 0; j < wordLength; j++) {\n        if (this[i + j] !== searchValue[j]) {\n          continue outer;\n        }\n      }\n      return i;\n    }\n    return -1;\n  }\n\n  /**\n   * @private\n   * @param {Collection} searchValue\n   * @param {number} start\n   * @returns {number}\n   */\n  searchShiftOr(searchValue, start) {\n    const { masks } = this.constructor;\n    const m = searchValue.length;\n    const m1 = 1 << m;\n    masks.fill(-1);\n    let r = -2;\n    for (let i = 0; i < m; i++) {\n      masks[searchValue[i]] &= ~(1 << i);\n    }\n    for (let i = start; i < this.length; i++) {\n      r |= masks[this[i]];\n      r <<= 1;\n      if ((r & m1) === 0) {\n        return (i - m) + 1;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * The amount of UTF characters in the StringView.\n   *\n   * @type {number}\n   * @example\n   * const stringView = StringView.fromString('abca');\n   * stringView.size\n   * //=> 5\n   * stringView.length\n   * //=> 8\n   */\n  get size() {\n    let size = 0;\n    for (let i = 0; i < this.length; i++) {\n      if ((this[i] >> 6) !== 2) size++;\n    }\n    return size;\n  }\n\n  /**\n   * Returns a string of characters between the start and end\n   * character indexes, or to the end of the string.\n   *\n   * @param {number} indexStart the character index of the first character to include\n   * @param {number} [indexEnd] the character index of the first character to exclude\n   * @returns {string} a new string containing the specified part of the given string\n   * @example\n   * const stringView = StringView.fromString('abca');\n   * stringView.substring(0, 4);\n   * //=> 'abc'\n   * stringView.substring(2);\n   * //=> 'ca'\n   */\n  substring(indexStart, indexEnd = this.size) {\n    const start = this.getCharStart(indexStart);\n    const end = this.getCharStart(indexEnd, indexStart, start);\n    const sub = this.subarray(start, this.getCharEnd(end) + 1);\n    return this.constructor.decoder.decode(sub);\n  }\n\n  /**\n   * @private\n   * @param {number} index\n   * @returns {string}\n   */\n  toChar(index) {\n    const point = this[index];\n    if (point < 0x80) return String.fromCodePoint(point);\n    switch ((point & 0xF0) >> 4) {\n      case 0xF: return String.fromCodePoint(((point & 0x07) << 18)\n        | ((this[index + 1] & 0x3F) << 12)\n        | ((this[index + 2] & 0x3F) << 6)\n        | ((this[index + 3] & 0x3F)));\n      case 0xE: return String.fromCodePoint(((point & 0x0F) << 12)\n        | ((this[index + 1] & 0x3F) << 6)\n        | ((this[index + 2] & 0x3F)));\n      case 0xD:\n      case 0xC: return String.fromCodePoint(((point & 0x1F) << 6)\n        | ((this[index + 1] & 0x3F)));\n      default: return '';\n    }\n  }\n\n  /**\n   * Returns a string representation of the StringView.\n   *\n   * @returns {string}\n   * @example\n   * const stringView = StringView.fromString('abca');\n   * stringView.toString();\n   * //=> 'abca'\n   * stringView == 'abca'\n   * //=> true\n   */\n  toString() {\n    const decoded = this.constructor.decoder.decode(this);\n    const end = decoded.indexOf(ZERO_CHAR);\n    return ~end ? decoded.slice(0, end) : decoded;\n  }\n\n  /**\n   * Returns a StringView without trailing zeros.\n   *\n   * @returns {StringView}\n   * @example\n   * const stringView = StringView.fromString('abca', 10);\n   * stringView\n   * //=> StringView [ 97, 98, 99, 240, 159, 152, 128, 97, 0, 0 ]\n   * stringView.trim();\n   * //=> StringView [ 97, 98, 99, 240, 159, 152, 128, 97 ]\n   */\n  trim() {\n    const end = this.indexOf(0);\n    return (~end) ? this.subarray(0, end) : this;\n  }\n\n  /**\n   * Creates a StringView from a string.\n   * todo use TextEncoder.encodeInto when supported by Node.js (FF supports already)\n   *\n   * @param {string} string the string to encode\n   * @param {number} [size] the size of the StringView in bytes\n   * @returns {StringView} a new StringView\n   * @example\n   * const stringView = StringView.fromString('abca');\n   * stringView\n   * //=> StringView [ 97, 98, 99, 240, 159, 152, 128, 97 ]\n   *\n   * const stringView = StringView.fromString('abca', 10);\n   * stringView\n   * //=> StringView [ 97, 98, 99, 240, 159, 152, 128, 97, 0, 0 ]\n   */\n  static fromString(string, size) {\n    const encoded = this.encoder.encode(string);\n    if (size) {\n      const view = new this(size);\n      view.set(encoded);\n      return view;\n    }\n    return new this(encoded.buffer);\n  }\n\n  /**\n   * Returns the size in bytes of a given string without encoding it.\n   *\n   * @param {string} string the string to check\n   * @returns {number} the size in bytes\n   * @example\n   * const stringView = StringView.getByteSize('abca');\n   * //=> 8\n   */\n  static getByteSize(string) {\n    let size = 0;\n    for (let i = 0; i < string.length; i++) {\n      const code = string.codePointAt(i);\n      if (code < 0x0080) size += 1; // 1-byte\n      else if (code < 0x0800) size += 2; // 2-byte\n      else if (code < 0x10000) size += 3; // 3-byte\n      else { // 4-byte\n        size += 4;\n        i++;\n      }\n    }\n    return size;\n  }\n}\n\n/**\n * @type Int8Array\n * @private\n */\nStringView.masks = new Int8Array(256).fill(-1);\n\n/**\n * @type TextEncoder\n */\nStringView.encoder = new TextEncoder();\n\n/**\n * @type TextDecoder\n */\nStringView.decoder = new TextDecoder();\n\nmodule.exports = StringView;\n","const utilities = require('./utilities');\n\n/**\n* @typedef {('Int8' | 'Uint8' | 'Int16' | 'Uint16'\n * | 'Int32' | 'Uint32' | 'Float32' | 'Float64'\n * | 'BigInt64' | 'BigUint64' | 'String' )} RecordFieldType\n*/\n\n/**\n * @typedef {Object} RecordField\n * @property {string} name\n * @property {RecordFieldType} type\n * @property {number} [size] the maximum size in bytes for a string type\n * @property {boolean} [littleEndian]\n */\n\nconst StringView = require('./string-view');\n\n/**\n * @private\n */\nconst fieldSizes = {\n  Int8: 1,\n  Uint8: 1,\n  Int16: 2,\n  Uint16: 2,\n  Int32: 4,\n  Uint32: 4,\n  Float32: 4,\n  Float64: 8,\n  BigInt64: 8,\n  BigUint64: 8,\n  String: 0,\n  Int8Array: 0,\n  Uint8Array: 0,\n  Uint8ClampedArray: 0,\n  Int16Array: 0,\n  Uint16Array: 0,\n  Int32Array: 0,\n  Uint32Array: 0,\n  Float32Array: 0,\n  Float64Array: 0,\n  BigInt64Array: 0,\n  BigUint64Array: 0,\n};\n\n/**\n * @private\n */\nconst typedArrays = {\n  Int8Array,\n  Uint8Array,\n  Uint8ClampedArray,\n  Int16Array,\n  Uint16Array,\n  Int32Array,\n  Uint32Array,\n  Float32Array,\n  Float64Array,\n  BigInt64Array,\n  BigUint64Array,\n};\n\n/**\n * Extends DataView to use ArrayBuffer as an array of records or C-like structs.\n *\n * @deprecated\n * @extends DataView\n */\nclass RecordArray extends DataView {\n  /**\n   * @param {Array<RecordField>} fields an array field descriptions\n   * @param {number} [size] the amount of structs in the array,\n   *                        optional if an existing ArrayBuffer is used\n   * @param {ArrayBuffer} [buffer] an existing ArrayBuffer to use for structs\n   * @param {number} [byteOffset] the byteOffset in an existing ArrayBuffer\n   * @param {number} [byteLength] the byteLength in an existing ArrayBuffer\n   * @example\n   * const people = new RecordArray([\n   *   { name: 'age', type: 'Uint8' },\n   *   { name: 'score', type: 'Float32' },\n   * ], 20);\n   *\n   * const cars = new RecordArray([\n   *   { name: 'name', type: 'String', size: 10 },\n   *   { name: 'speed', type: 'Float32' }\n   * ], 100)\n   */\n  constructor(fields, size = 1, buffer, byteOffset, byteLength) {\n    const lastField = fields[fields.length - 1];\n    if (!lastField.end) new.target.initialize(fields);\n    const lastOffset = lastField.end;\n    const offset = Math.ceil(Math.log2(lastOffset));\n    const data = buffer || new ArrayBuffer(size << offset);\n    super(data, byteOffset, byteLength);\n\n    const schema = {};\n    for (let i = 0; i < fields.length; i++) {\n      schema[fields[i].name] = fields[i];\n    }\n\n    Object.defineProperties(this, {\n      fields: { value: fields },\n      offset: { value: offset },\n      schema: { value: schema },\n      byteView: { value: new StringView(this.buffer, this.byteOffset, this.byteLength) },\n    });\n  }\n\n  /**\n   * Returns the value of a given field of a record at the given index.\n   *\n   * @param {number} index the index of a record\n   * @param {string} field the name of the field\n   * @returns {*} value of the field\n   * @example\n   * const people = new RecordArray([\n   *   { name: 'age', type: 'Uint8' },\n   *   { name: 'score', type: 'Float32' },\n   * ], 20);\n   *\n   * person.get(0, 'age');\n   */\n  get(index, field) {\n    const { type, size, littleEndian } = this.schema[field];\n    const offset = this.getByteOffset(index, field);\n    switch (type) {\n      case 'Int8':\n        return this.getInt8(offset);\n      case 'Uint8':\n        return this.getUint8(offset);\n      case 'Int16':\n        return this.getInt16(offset, littleEndian);\n      case 'Uint16':\n        return this.getUint16(offset, littleEndian);\n      case 'Int32':\n        return this.getInt32(offset, littleEndian);\n      case 'Uint32':\n        return this.getUint32(offset, littleEndian);\n      case 'Float32':\n        return this.getFloat32(offset, littleEndian);\n      case 'Float64':\n        return this.getFloat64(offset, littleEndian);\n      case 'BigInt64':\n        return this.getBigInt64(offset, littleEndian);\n      case 'BigUint64':\n        return this.getBigUint64(offset, littleEndian);\n      case 'String':\n        return this.getString(offset, size);\n      default:\n        return this.getArray(offset, size, type);\n    }\n  }\n\n  /**\n   * @param {number} offset\n   * @param {number} size\n   * @param {string} type\n   * @returns {RecordArray}\n   */\n  getArray(offset, size, type) {\n    return new typedArrays[type](this.buffer, this.byteOffset + offset, size);\n  }\n\n  /**\n   * @param {number} offset\n   * @param {number} size\n   * @returns {StringView}\n   */\n  getString(offset, size) {\n    return this.byteView.subarray(offset, offset + size);\n  }\n\n  /**\n   * Sets a value to a field of a record at a given index.\n   *\n   * @param {number} index the index of a record\n   * @param {string} field the name of the field\n   * @param {*} value the value to be set\n   * @returns {this}\n   * @example\n   * const people = new RecordArray([\n   *   { name: 'age', type: 'Uint8' },\n   *   { name: 'score', type: 'Float32' },\n   * ], 20);\n   *\n   * person.set(0, 'age', 10);\n   * person.get(0, 'age');\n   * //=> 10\n   */\n  set(index, field, value) {\n    const { type, littleEndian, size } = this.schema[field];\n    const offset = this.getByteOffset(index, field);\n    switch (type) {\n      case 'Int8':\n        this.setInt8(offset, value);\n        break;\n      case 'Uint8':\n        this.setUint8(offset, value);\n        break;\n      case 'Int16':\n        this.setInt16(offset, value, littleEndian);\n        break;\n      case 'Uint16':\n        this.setUint16(offset, value, littleEndian);\n        break;\n      case 'Int32':\n        this.setInt32(offset, value, littleEndian);\n        break;\n      case 'Uint32':\n        this.setUint32(offset, value, littleEndian);\n        break;\n      case 'Float32':\n        this.setFloat32(offset, value, littleEndian);\n        break;\n      case 'Float64':\n        this.setFloat64(offset, value, littleEndian);\n        break;\n      case 'BigInt64':\n        this.setBigInt64(offset, value, littleEndian);\n        break;\n      case 'BigUint64':\n        this.setBigUint64(offset, value, littleEndian);\n        break;\n      case 'String':\n        this.setString(offset, value, size);\n        break;\n      default:\n        this.setArray(offset, value, size, type);\n        break;\n    }\n    return this;\n  }\n\n  /**\n   * @param {number} offset\n   * @param {ArrayLike} value\n   * @param {number} size\n   * @param {string} type\n   * @returns {RecordArray}\n   */\n  setArray(offset, value, size, type) {\n    const array = new typedArrays[type](this.buffer, this.byteOffset + offset, size);\n    if (value.length < array.length) array.fill(0);\n    array.set(value);\n    return this;\n  }\n\n  /**\n   * @param {number} offset\n   * @param {Collection} value\n   * @param {number} size\n   * @returns {void}\n   */\n  setString(offset, value, size) {\n    if (value.length === size) {\n      this.byteView.set(value, offset);\n    } else {\n      this.byteView.subarray(offset, offset + size)\n        .fill(0)\n        .set(value);\n    }\n  }\n\n  /**\n   * @type {number} The amount of structs in the array.\n   * @example\n   * const people = new RecordArray([\n   *   { name: 'age', type: 'Uint8' },\n   *   { name: 'score', type: 'Float32' },\n   * ], 20);\n   *\n   * people.size\n   * //=> 20\n   */\n  get size() {\n    return this.buffer.byteLength >> this.offset;\n  }\n\n  /**\n   * Returns the byte offset in the ArrayBuffer of a given field.\n   *\n   * @param {number} index the index of the record\n   * @param {string} field the name of the field\n   * @returns {number} the byte offset\n   */\n  getByteOffset(index, field) {\n    return (index << this.offset) + this.schema[field].start;\n  }\n\n  /**\n   * The object representation of a given record.\n   *\n   * @param {number} index the index of the record\n   * @returns {Object}\n   * @example\n   * const people = new RecordArray([\n   *   { name: 'age', type: 'Uint8' },\n   *   { name: 'score', type: 'Float32' },\n   * ], 20);\n   *\n   * person.set(0, 'age', 10).set(0, 'score', 5.0).toObject(0);\n   * //=> { age: 10, score: 5.0 }\n   */\n  toObject(index) {\n    const { fields } = this;\n    const result = {};\n    for (let i = 0; i < fields.length; i++) {\n      const { name } = fields[i];\n      result[name] = this.get(index, name);\n    }\n    return result;\n  }\n\n  /**\n   * Stores a given object as a record at a given index.\n   *\n   * @param {number} index the index of the record\n   * @param {Object} object the object to be stored\n   * @returns {RecordArray}\n   * @example\n   * const people = new RecordArray([\n   *   { name: 'age', type: 'Uint8' },\n   *   { name: 'score', type: 'Float32' },\n   * ], 20);\n   *\n   * person.set(0, 'age', 10).set(0, 'score', 5.0).toObject(0);\n   * //=> { age: 10, score: 5.0 }\n   */\n  fromObject(index, object) {\n    const { fields } = this;\n    for (let i = 0; i < fields.length; i++) {\n      const { name } = fields[i];\n      if (Reflect.has(object, name)) this.set(index, name, object[name]);\n    }\n    return this;\n  }\n\n  /**\n   * Returns the length of underlying ArrayBuffer required to hold the given amount of records.\n   *\n   * @param {Array<RecordField>} fields an array field descriptions\n   * @param {number} [size] the amount of structs in the array\n   * @returns {number}\n   */\n  static getLength(fields, size) {\n    const lastField = fields[fields.length - 1];\n    if (!lastField.end) this.initialize(fields);\n    return size << Math.ceil(Math.log2(lastField.end));\n  }\n\n  /**\n   * @private\n   * @param {Array} fields\n   * @returns {void}\n   */\n  static initialize(fields) {\n    let lastOffset = 0;\n    for (let i = 0; i < fields.length; i++) {\n      const field = fields[i];\n      const { type } = field;\n      let fieldSize = field.size;\n      if (!Reflect.has(fieldSizes, type)) {\n        throw TypeError(`Type \"${type}\" is not a valid type.`);\n      }\n      const isArray = Reflect.has(typedArrays, type);\n      if (isArray) {\n        const bytesPerElement = typedArrays[type].BYTES_PER_ELEMENT;\n        lastOffset = utilities.getGTEMultiple(lastOffset, bytesPerElement);\n        fieldSize *= bytesPerElement;\n      }\n      field.start = lastOffset;\n      lastOffset += (fieldSize || fieldSizes[type]);\n      field.end = lastOffset;\n    }\n  }\n}\n\nmodule.exports = RecordArray;\n","/**\n * @name Comparator\n * @function\n * @param {*} a\n * @param {*} b\n * @returns {number}\n */\n\n/**\n * Creates a SortedCollection class extending a given Array-like class.\n *\n * @param {CollectionConstructor} Base\n * @returns {SortedCollection}\n * @example\n *\n * const SortedCollection = Grid(Uint32Array);\n */\nfunction SortedMixin(Base) {\n  /**\n   * Extends TypedArrays  to handle sorted data.\n   *\n   * @extends CollectionConstructor\n   */\n  class SortedCollection extends Base {\n    /**\n     * Uses binary search to quickly check if the element is the array.\n     *\n     * @private\n     * @param {*} element the element to check\n     * @returns {boolean} whether the element is in the array\n     */\n    includes(element) {\n      return !!~this.indexOf(element);\n    }\n\n    /**\n     * Looks for the index of a given element in the array or -1\n     *\n     * @private\n     * @param {*} element the element to look for\n     * @returns {number} the element's index in the array or -1\n     */\n    indexOf(element) {\n      return this.constructor.getIndex(this, element);\n    }\n\n    /**\n     * Checks if the array is sorted.\n     *\n     * @returns {boolean} whether the array is sorted\n     * @example\n     *\n     * //=> SortedCollection [ 2, 3, 4, 5, 9 ];\n     * sortedCollection.isSorted();\n     * //=> true\n     * sortedCollection.reverse();\n     * sortedCollection.isSorted();\n     * //=> false;\n     */\n    isSorted() {\n      return this.constructor.isSorted(this);\n    }\n\n    /**\n     * Checks if the array has duplicating elements.\n     *\n     * @returns {boolean} whether the array has duplicating elements\n     * @example\n     *\n     * //=> SortedCollection [ 2, 3, 3, 4, 5, 9 ];\n     * sortedCollection.isUnique();\n     * //=> false;\n     */\n    isUnique() {\n      return this.constructor.isUnique(this);\n    }\n\n    /**\n     * Returns a range of elements of the array that are greater or equal to the provided\n     * starting element and less or equal to the provided ending element.\n     *\n     * @param {*} start the starting element\n     * @param {*} end the ending element\n     * @param {boolean} [subarray=false] return a subarray\n     *                                   instead of copying resulting value with slice\n     * @returns {SortedCollection} the resulting range of elements\n     * @example\n     *\n     * //=> SortedCollection [ 2, 3, 4, 5, 9 ];\n     * sortedCollection.range(3, 5);\n     * // => [ 3, 4, 5 ]\n     * sortedCollection.range(undefined, 4);\n     * // => [ 2, 3, 4 ]\n     * sortedCollection.range(4);\n     * // => [ 4, 5, 8 ]\n     */\n    range(start, end, subarray) {\n      return this.constructor.getRange(this, start, end, this.constructor.compare, subarray);\n    }\n\n    /**\n     * Returns the rank of an element in the array.\n     *\n     * @param {*} element the element to look for\n     * @returns {number} the rank in the array\n     * @example\n     *\n     * //=> SortedCollection [ 2, 3, 4, 5, 9 ];\n     * sortedCollection.rank(1);\n     * // => 0\n     * sortedCollection.rank(6);\n     * // => 4\n     */\n    rank(element) {\n      return this.constructor.getIndex(this, element, this.constructor.compare, true);\n    }\n\n    /**\n     * The default comparator.\n     *\n     * @param {*} a the first value\n     * @param {*} b the second value\n     * @throws {RangeError} if the comparison is unstable\n     * @returns {number}\n     */\n    static compare(a, b) {\n      if (a > b) return 1;\n      if (a < b) return -1;\n      if (a === b) return 0;\n      throw new RangeError('Unstable comparison.');\n    }\n\n    /**\n     * Creates a new SortedCollection from a given array-like object.\n     *\n     * @private\n     * @param {*} arrayLike an array-like object to convert to a SortedCollection\n     * @param {Function} mapFn a map function to call on every element of the array\n     * @param {Object} thisArg the value to use as `this` when invoking the `mapFn`\n     * @returns {SortedCollection} a new SortedCollection\n     */\n    static from(arrayLike, mapFn, thisArg) {\n      const result = super.from(arrayLike, mapFn, thisArg);\n      result.sort();\n      return result;\n    }\n\n    /**\n     * Returns the difference of two sorted arrays,\n     * i.e. elements present in the first array but not in the second array.\n     * If `symmetric=true` finds the symmetric difference of two arrays, that is,\n     * the elements that are absent in one or another array.\n     *\n     * @param {Collection} a the first array\n     * @param {Collection} b the second array\n     * @param {boolean} [symmetric=false] whether to get symmetric difference.\n     * @param {Comparator} [comparator] the comparator static used to sort the arrays\n     * @param {Collection} [container] an array-like object to hold the results\n     * @returns {Array} the difference of the arrays\n     * @example\n     *\n     * SortedCollection.getDifference([1, 2, 3, 4, 8], [2, 4, 6, 7, 9]);\n     * //=> [ 1, 3, 8 ]\n     *\n     * // symmetric difference of sorted arrays:\n     * SortedCollection.getDifference(first, second, true);\n     * //=> [ 1, 3, 6, 7, 8, 9 ]\n\n     * // difference using a custom comparator:\n     * const customComparator = (a, b) => (a > b ? -1 : a < b ? 1 : 0);\n     * SortedCollection.getDifference([8, 4, 3, 2, 1], [9, 7, 6, 4, 2], false, customComparator);\n     * //=> [ 8, 3, 1 ]\n     */\n    static getDifference(a, b, symmetric, comparator = this.compare, container = []) {\n      let i = 0;\n      let j = 0;\n      while (i < a.length && j < b.length) {\n        const compared = comparator(a[i], b[j]);\n        if (compared > 0) {\n          if (symmetric) container[container.length] = b[j];\n          j++;\n        } else if (compared < 0) {\n          container[container.length] = a[i];\n          i++;\n        } else {\n          i++;\n          j++;\n        }\n      }\n      while (i < a.length) {\n        container[container.length] = a[i];\n        i++;\n      }\n      if (symmetric) {\n        while (j < b.length) {\n          container[container.length] = b[j];\n          j++;\n        }\n      }\n      return container;\n    }\n\n    /**\n     * Returns the amount of differing elements in the first array.\n     *\n     * @param {Collection} a the first array\n     * @param {Collection} b the second array\n     * @param {boolean} [symmetric=false] whether to use symmetric difference\n     * @param {Comparator} [comparator] the comparator static used to sort the arrays\n     * @returns {number} the amount of differing elements\n     * @example\n     *\n     * SortedCollection.getDifferenceScore([1, 2, 3, 4, 8], [2, 4, 6, 7, 9]);\n     * //=> 3\n     */\n    static getDifferenceScore(a, b, symmetric, comparator) {\n      const score = this.getIntersectionScore(a, b, comparator);\n      return symmetric ? (a.length + b.length) - (2 * score) : a.length - score;\n    }\n\n    /**\n     * Uses binary search to find the index of an element inside a sorted array.\n     *\n     * @param {Collection} arr the array to search\n     * @param {*} target the target value to search for\n     * @param {Comparator} [comparator] a custom comparator\n     * @param {boolean} [rank=false] whether to return the element's rank if the element isn't found\n     * @param {number} [start] the start position of the search\n     * @param {number} [end] the end position of the search\n     * @returns {number} the index of the searched element or it's rank\n     * @example\n     *\n     * SortedCollection.getIndex([1, 2, 3, 4, 8], 4);\n     * //=> 3\n     */\n    static getIndex(\n      arr, target, comparator = this.compare,\n      rank = false, start = 0, end = arr.length - 1,\n    ) {\n      let left = start;\n      let right = end;\n      let m;\n      while (left <= right) {\n        m = (left + right) >> 1;\n        const compared = comparator(arr[m], target);\n        if (compared < 0) {\n          left = m + 1;\n        } else if (compared > 0) {\n          right = m - 1;\n        } else {\n          return m;\n        }\n      }\n      return rank ? left : -1;\n    }\n\n    /**\n     * Returns the intersection of two sorted arrays.\n     *\n     * @param {Collection} a the first array\n     * @param {Collection} b the second array\n     * @param {Comparator} [comparator] the comparator static used to sort the arrays\n     * @param {Collection} [container] an array-like object to hold the results\n     * @returns {Array} the intersection of the arrays\n     * @example\n     *\n     * SortedCollection.getIntersection([1, 2, 3, 4, 8], [2, 4, 6, 7, 9]);\n     * //=> [ 2, 4 ]\n     *\n     * // intersection using a custom comparator:\n     * const customComparator = (a, b) => (a > b ? -1 : a < b ? 1 : 0);\n     * SortedCollection.getIntersection([8, 4, 3, 2, 1], [9, 7, 6, 4, 2], customComparator);\n     * //=> [ 4, 2 ]\n     */\n    static getIntersection(a, b, comparator = this.compare, container = []) {\n      let i = 0;\n      let j = 0;\n      while (i < a.length && j < b.length) {\n        const compared = comparator(a[i], b[j]);\n        if (compared > 0) {\n          j++;\n        } else if (compared < 0) {\n          i++;\n        } else {\n          container[container.length] = a[i];\n          i++;\n          j++;\n        }\n      }\n      return container;\n    }\n\n    /**\n     * Returns the amount of common elements in two sorted arrays.\n     *\n     * @param {Collection} a the first array\n     * @param {Collection} b the second array\n     * @param {Comparator} [comparator] the comparator static used to sort the arrays\n     * @returns {number} the amount of different elements\n     * @example\n     *\n     * SortedCollection.getIntersection([1, 2, 3, 4, 8], [2, 4, 6, 7, 9]);\n     * //=> 2\n     */\n    static getIntersectionScore(a, b, comparator = this.compare) {\n      let score = 0;\n      let i = 0;\n      let j = 0;\n      while (i < a.length && j < b.length) {\n        const compared = comparator(a[i], b[j]);\n        if (compared > 0) {\n          j++;\n        } else if (compared < 0) {\n          i++;\n        } else {\n          score++;\n          i++;\n          j++;\n        }\n      }\n      return score;\n    }\n\n    /**\n     * Returns a range of elements of a sorted array from the start through the end inclusively.\n     *\n     * @param {Collection} arr the array\n     * @param {number} [start] the starting item\n     * @param {number} [end] the ending item\n     * @param {Comparator} [comparator] a custom comparator\n     * @param {boolean} [subarray] return a subarray instead of copying resulting value with slice\n     * @returns {Collection} the range of items\n     * @example\n     *\n     * SortedCollection.getRange([1, 2, 3, 4, 8], 2, 4);\n     * //=> [ 2, 3, 4 ]\n     *\n     * const customComparator = (a, b) => (a > b ? -1 : a < b ? 1 : 0);\n     * SortedCollection.getRange([8, 4, 3, 2, 1], 8, 3, customComparator);\n     * //=> [ 8, 4, 3 ]\n     */\n    static getRange(arr, start, end, comparator, subarray) {\n      const startIndex = start === undefined ? 0 : this.getIndex(arr, start, comparator, true);\n      const endIndex = end === undefined ? arr.length\n        : this.getIndex(arr, end, comparator, true, startIndex) + 1;\n      const method = subarray ? 'subarray' : 'slice';\n      return arr[method](startIndex, endIndex);\n    }\n\n    /**\n     * Returns the union of two sorted arrays as a sorted array.\n     *\n     * @param {Collection} a the first array\n     * @param {Collection} b the second array\n     * @param {boolean} [unique=false] whether to avoid duplicating items when merging unique arrays\n     * @param {Comparator} [comparator] the comparator static used to sort the arrays\n     * @param {Collection} [container] an array-like object to hold the results\n     * @returns {Array} the union of the arrays\n     * @example\n     *\n     * SortedCollection.getUnion([1, 2, 3, 4, 8], [2, 4, 6, 7, 9]);\n     * //=> [ 1, 2, 2, 3, 4, 4, 6, 7, 8, 9 ]\n     *\n     * // union of sorted arrays without duplicates:\n     * SortedCollection.getUnion([1, 2, 3, 4, 8], [2, 4, 6, 7, 9], true);\n     * //=> [ 1, 2, 3, 4, 6, 7, 8, 9 ]\n     *\n     * //union using a custom comparator:\n     * SortedCollection.getUnion([8, 4, 3, 2, 1], [9, 7, 6, 4, 2], true, customComparator);\n     * //=> [ 9, 8, 7, 6, 4, 3, 2, 1 ]\n     */\n    static getUnion(a, b, unique, comparator = this.compare, container = []) {\n      let i = 0;\n      let j = 0;\n      while (i < a.length && j < b.length) {\n        const compared = comparator(a[i], b[j]);\n        if (compared > 0) {\n          container[container.length] = b[j];\n          j++;\n        } else if (compared < 0) {\n          container[container.length] = a[i];\n          i++;\n        } else {\n          container[container.length] = a[i];\n          if (!unique) container[container.length] = b[j];\n          i++;\n          j++;\n        }\n      }\n      while (i < a.length) {\n        container[container.length] = a[i];\n        i++;\n      }\n      while (j < b.length) {\n        container[container.length] = b[j];\n        j++;\n      }\n      return container;\n    }\n\n\n    /**\n     * Returns an array of unique elements from a sorted array.\n     *\n     * @param {Collection} arr the sorted array\n     * @param {Comparator} [comparator] a custom comparator\n     * @param {Collection} [container] an array-like object to hold the results\n     * @returns {Array} the sorted array without duplicates\n     * @example\n     *\n     * SortedCollection.getUnique([1, 1, 2, 2, 3, 4]);\n     * //=> [ 1, 2, 3, 4 ]\n     */\n    static getUnique(arr, comparator = this.compare, container = []) {\n      container[0] = arr[0];\n      for (let i = 1; i < arr.length; i++) {\n        if (comparator(arr[i - 1], arr[i]) !== 0) {\n          container[container.length] = arr[i];\n        }\n      }\n      return container;\n    }\n\n    /**\n     * Creates a new SortedCollection instance with a variable number of arguments,\n     * regardless of number or type of the arguments\n     *\n     * @private\n     * @param {...*} elements the elements of which to create the array\n     * @returns {SortedCollection} the new SortedCollection\n     */\n    static of(...elements) {\n      const result = super.of(...elements);\n      result.sort();\n      return result;\n    }\n\n    /**\n     * Checks whether an array is sorted according to a provided comparator.\n     *\n     * @param {Array} arr the array to check\n     * @param {Comparator} [comparator] a custom comparator\n     * @returns {boolean} whether the array is sorted\n     *\n     * @example\n     *\n     * SortedCollection.isSorted([1, 2, 3, 4, 8]);\n     * //=> true\n     */\n    static isSorted(arr, comparator = this.compare) {\n      for (let i = 1; i < arr.length; i++) {\n        if (comparator(arr[i - 1], arr[i]) > 0) return false;\n      }\n      return true;\n    }\n\n    /**\n     * Checks whether an array has any duplicating elements.\n     *\n     * @param {Array} arr the array to check\n     * @param {Comparator} [comparator] a custom comparator\n     * @returns {boolean} whether the array has duplicating elements\n     * @example\n     *\n     * SortedCollection.isUnique([1, 2, 2, 3, 4]);\n     * //=> false\n     */\n    static isUnique(arr, comparator = this.compare) {\n      for (let i = 1; i < arr.length; i++) {\n        if (comparator(arr[i - 1], arr[i]) === 0) return false;\n      }\n      return true;\n    }\n  }\n\n  return SortedCollection;\n}\n\nmodule.exports = SortedMixin;\n","const SortedMixin = require('./sorted-collection');\n\n/**\n * Extends Array to handle sorted data.\n *\n * @extends SortedCollection\n */\nclass SortedArray extends SortedMixin(Array) {\n  /**\n   * Returns a merger of the array with one or more provided sorted arrays.\n   *\n   * @private\n   * @param {...Array} arrays sorted array(s) to merge\n   * @returns {SortedArray} a new SortedArray\n   */\n  concat(...arrays) {\n    let result = this;\n    for (let i = 0; i < arrays.length; i++) {\n      result = this.constructor.getUnion(\n        result, arrays[i], this.unique, this.constructor.compare, new this.constructor(),\n      );\n    }\n    return result;\n  }\n\n  /**\n   * Adds provided elements to the array preserving the sorted order of the array.\n   *\n   * @private\n   * @param {...*} elements the elements to add to the array\n   * @returns {number} the new length of the array\n   */\n  push(...elements) {\n    const { compare } = this.constructor;\n    const m = this.length;\n    if (!m) return super.push(...elements.sort(compare));\n    const toAdd = this.unique ? elements.filter(el => !~this.indexOf(el)) : elements;\n    const n = toAdd.length;\n    if (!n) return m;\n    toAdd.sort(compare);\n    for (let i = n - 1; i >= 0; i--) {\n      let j;\n      const last = this[m - 1];\n      for (j = m - 2; j >= 0 && compare(this[j], toAdd[i]) === 1; j--) {\n        this[j + 1] = this[j];\n      }\n      if (j !== m - 2 || compare(last, toAdd[i]) === 1) {\n        this[j + 1] = toAdd[i];\n        toAdd[i] = last;\n      }\n    }\n    return super.push(...toAdd);\n  }\n\n  /**\n   * Implements in-place replacement of the array elements.\n   *\n   * @param {Collection} arr an array of new elements to use\n   * @returns {SortedArray}\n   * @example\n   *\n   * //=> SortedArray [ 2, 3, 4, 5, 9 ];\n   * sortedArray.set([1, 2, 3]);\n   * //=> SortedArray [ 1, 2, 3 ]\n   */\n  set(arr) {\n    this.length = arr.length;\n    for (let i = 0; i < arr.length; i++) {\n      this[i] = arr[i];\n    }\n    return this;\n  }\n\n  /**\n   * Sorts the array with a provided compare function.\n   *\n   * @private\n   * @param {Comparator} compareFunction the function to use for comparison\n   * @returns {this}\n   */\n  sort(compareFunction = this.constructor.compare) {\n    return super.sort(compareFunction);\n  }\n\n  /**\n   * Changes the array by removing existing elements and adding new ones.\n   *\n   * @private\n   * @param {number} start the index at which to start changing the array\n   * @param {number} deleteCount the amount of old elements to delete\n   * @param {...*} elements the elements to add to the array\n   * @returns {SortedArray} an array of deleted elements\n   */\n  splice(start, deleteCount, ...elements) {\n    const deletedElements = super.splice(start, deleteCount);\n    this.push(...elements);\n    return deletedElements;\n  }\n\n  /**\n   * Removes duplicating elements from the array.\n   *\n   * @returns {SortedArray}\n   * @example\n   *\n   * //=> SortedArray [ 2, 2, 3, 4, 5, 5, 9 ];\n   * sortedArray.uniquify();\n   * // => SortedArray [ 2, 3, 4, 5, 9 ]\n   */\n  uniquify() {\n    return this.set(this.constructor.getUnique(this, this.constructor.compare,\n      new this.constructor()));\n  }\n\n  /**\n   * Adds provided elements to the array preserving the sorted order of the array.\n   *\n   * @private\n   * @param {...*} elements the elements to add to the array\n   * @returns {number} the new length of the array\n   */\n  unshift(...elements) {\n    return this.push(...elements);\n  }\n}\n\nmodule.exports = SortedArray;\n","/**\n * Creates a SymmetricGrid class extending a given Array-like class.\n *\n * @param {CollectionConstructor} Base\n * @returns {SymmetricGrid}\n * @example\n *\n * const SymmetricGrid = SymmetricGridMixin(Array);\n */\nfunction SymmetricGridMixin(Base) {\n  /**\n   * A grid to handle symmetric or triangular matrices\n   * using half the space required for a normal grid.\n   *\n   * @extends CollectionConstructor\n   */\n  class SymmetricGrid extends Base {\n    /**\n     * Passes all arguments to the Base class except if called with a special set of grid options,\n     * in that case creates and empty grid of specified parameters.\n     *\n     * @param {Object} [options]\n     * @param {number} [options.rows=2] the number of rows\n     * @param {*} [options.pad=0] the initial value of cells\n     * @param {...*} [args]\n     * @example\n     *\n     * new SymmetricGrid('a')\n     * //=> SymmetricGrid ['a']\n     *\n     * new SymmetricGrid(2)\n     * //=> SymmetricGrid [undefined, undefined]\n     *\n     * new SymmetricGrid({ rows: 3 })\n     * //=> SymmetricGrid [0, 0, 0, 0]\n     *\n     * new SymmetricGrid({ rows: 3, pad: 1 })\n     * //=> SymmetricGrid [1, 1, 1, 1]\n     */\n    constructor(options = {}, ...args) {\n      const { rows = 2, pad = 0 } = options;\n      if (args.length) {\n        super(...args);\n      } else {\n        super(SymmetricGrid.getLength(rows));\n        this.fill(pad);\n      }\n      Object.defineProperties(this, {\n        pad: { value: pad, writable: true },\n        columns: { value: rows },\n        rows: { value: rows },\n        lastCoordinates: { value: Object.seal({ row: 0, column: 0 }) },\n      });\n    }\n\n    /**\n     * Returns an element from given coordinates.\n     *\n     * @param {number} row\n     * @param {number} column\n     * @returns {*}\n     * @example\n     *\n     * const a = SymmetricGrid({ rows: 3, pad: 3});\n     * a.get(0, 1);\n     * //=> 3\n     */\n    get(row, column) {\n      return this[this.constructor.getIndex(row, column)];\n    }\n\n    /**\n     * Sets the element at given coordinates.\n     * Proxies to TypedArray#set if the first parameter is Array-like\n     * and the grid is based on a TypedArray.\n     *\n     * @param {number|Collection} row\n     * @param {number} [column]\n     * @param {*} [value]\n     * @returns {SymmetricGrid} the instance\n     * @example\n     *\n     * const a = SymmetricGrid({ rows: 3, pad: 3});\n     * a.set(0, 1, 5);\n     * a.get(0, 1);\n     * //=> 5\n     */\n    set(row, column, value) {\n      if (row.length && super.set) {\n        super.set(row, column);\n        return this;\n      }\n      this[this.constructor.getIndex(row, column)] = value;\n      return this;\n    }\n\n    /**\n     * Implements in-place replacement of the grid elements if it's based on Array.\n     * Proxies to TypedArray#set if the grid is based on a TypedArray.\n     *\n     * @param {Collection} array\n     * @param {number} [offset]\n     * @returns {void}\n     */\n    setArray(array, offset) {\n      if (super.set) {\n        super.set(array, offset);\n      } else {\n        this.length = array.length;\n        for (let i = 0; i < array.length; i++) {\n          this[i] = array[i];\n        }\n      }\n    }\n\n    /**\n     * Gets coordinates of an element at specified index.\n     *\n     * @param {number} index\n     * @returns {Coordinates} coordinates\n     * @example\n     * const a = SymmetricGrid({ rows: 3, pad: 3});\n     * a.getCoordinates(1);\n     * //=> [0, 1]\n     * a.getCoordinates(2);\n     * //=> [1, 1]\n     */\n    getCoordinates(index) {\n      const row = (Math.sqrt((index << 3) + 1) - 1) >> 1;\n      this.lastCoordinates.row = row;\n      this.lastCoordinates.column = index - ((row * (row + 1)) >> 1);\n      return this.lastCoordinates;\n    }\n\n    /**\n     * Returns an array of arrays where each nested array correspond to a row in the grid.\n     *\n     * @returns {Array<Array<*>>}\n     * @example\n     *\n     * const a = SymmetricGrid.from([[1, 2, 4], [2, 3, 5], [4, 5, 6]])\n     * //=> SymmetricGrid [1, 2, 3, 4, 5, 6]\n     * a.toArrays();\n     * //=> Array [[1, 2, 4], [2, 3, 5], [4, 5, 6]]\n     */\n    toArrays() {\n      const { rows } = this;\n      const arrays = new Array(rows).fill(0).map(() => []);\n      let k = 0;\n      for (let i = 0; i < rows; i++) {\n        for (let j = 0; j <= i; j++) {\n          arrays[i][j] = this[k];\n          arrays[j][i] = this[k];\n          k++;\n        }\n      }\n      return arrays;\n    }\n\n    /**\n     * @type {CollectionConstructor}\n     */\n    static get [Symbol.species]() {\n      return Base;\n    }\n\n    /**\n     * Returns an array index of an element at given coordinates.\n     *\n     * @param {number} row\n     * @param {number} column\n     * @returns {*}\n     * @example\n     *\n     * const a = SymmetricGrid({ rows: 3 });\n     * a.get(1, 0);\n     * //=> 1\n     * a.get(0, 1);\n     * //=> 1\n     */\n    static getIndex(row, column) {\n      const [x, y] = row >= column ? [column, row] : [row, column];\n      return x + (((y + 1) * y) >> 1);\n    }\n\n    /**\n     * Returns the length of underlying Array required to hold the grid.\n     *\n     * @param {number} rows\n     * @returns {number}\n     */\n    static getLength(rows) {\n      return ((rows + 1) * rows) >> 1;\n    }\n\n    /**\n     * Creates a grid from an array of arrays.\n     *\n     * @param {Array<Array<*>>} arrays\n     * @param {*} [pad=0] the value to pad the arrays to create equal sized rows\n     * @returns {SymmetricGrid}\n     *\n     * const a = SymmetricGrid.from([[1, 2, 4], [2, 3, 5], [4, 5, 6]])\n     * //=> SymmetricGrid [1, 2, 3, 4, 5, 6]\n     * a.get(1, 0);\n     * //=> 2\n     * a.get(2, 1);\n     * //=> 4\n     */\n    static fromArrays(arrays, pad = 0) {\n      const rows = arrays.length;\n      const grid = new this({ rows, pad });\n      let k = 0;\n      for (let i = 0; i < rows; i++) {\n        for (let j = 0; j <= i; j++) {\n          grid[k] = arrays[i][j];\n          k++;\n        }\n      }\n      return grid;\n    }\n  }\n\n  return SymmetricGrid;\n}\n\nmodule.exports = SymmetricGridMixin;\n","/**\n * Implements Adjacency List data structure for unweighted graphs.\n *\n * @extends Uint32Array\n */\nclass UnweightedAdjacencyList extends Uint32Array {\n  /**\n   * @param {Object} [options]\n   * @param {number} [options.vertices=2] the maximum amount of vertices in the graph\n   * @param {number} [options.edges=2] the maximum amount of edges in the graph\n   * @param {...*} args\n   */\n  constructor(options = {}, ...args) {\n    let { vertices, edges } = options;\n    if (args.length) {\n      if (!vertices && args[0].length) {\n        vertices = UnweightedAdjacencyList.getVertexCount(args[0]);\n        edges = args[0].length - vertices - 1;\n      }\n      super(...args);\n    } else {\n      vertices = vertices || 2;\n      edges = edges || 2;\n      super((vertices + edges) + 1);\n    }\n    Object.defineProperties(this, {\n      vertices: { value: vertices },\n      edges: { value: edges },\n    });\n\n    if (!args.length) this.setOffsets();\n  }\n\n  /**\n   * Adds an edge between two vertices.\n   *\n   * @param {number} x the starting vertex\n   * @param {number} y the ending vertex\n   * @throws {RangeError} if the list is full\n   * @returns {UnweightedAdjacencyList}\n   */\n  addEdge(x, y) {\n    const { undirected } = this.constructor;\n    if (this.hasEdge(x, y)) return this;\n    // the list is full\n    if (this.isFull()) throw new RangeError('The list is full.');\n    this.setEdge(x, y);\n    if (undirected) this.setEdge(y, x);\n    return this;\n  }\n\n  /**\n   * Removes an edge between two vertices.\n   *\n   * @param {number} x the starting vertex\n   * @param {number} y the ending vertex\n   * @returns {UnweightedAdjacencyList}\n   */\n  removeEdge(x, y) {\n    const { undirected } = this.constructor;\n    this.unsetEdge(x, y);\n    if (undirected) this.unsetEdge(y, x);\n    return this;\n  }\n\n  /**\n   * Checks if there is an edge between two vertices.\n   *\n   * @param {number} x the starting vertex\n   * @param {number} y the ending vertex\n   * @returns {boolean}\n   */\n  hasEdge(x, y) {\n    return !!this.getEdge(x, y);\n  }\n\n  /**\n   * Returns 1 if the edge between the given vertices exists, 0 otherwise.\n   *\n   * @param {number} x the starting vertex\n   * @param {number} y the ending vertex\n   * @returns {number}\n   */\n  getEdge(x, y) {\n    const offset = this[x];\n    const nextOffset = this[x + 1];\n    // no out edges from x\n    if (offset === nextOffset) return 0;\n    for (let i = offset; i < nextOffset; i++) {\n      if (this[i] === y) return 1;\n    }\n    return 0;\n  }\n\n  /**\n   * @private\n   * @param {number} x the starting vertex\n   * @param {number} y the ending vertex\n   * @returns {UnweightedAdjacencyList}\n   */\n  setEdge(x, y) {\n    const { vertices } = this;\n\n    // shift values\n    for (let i = this[vertices]; i > this[x]; i--) {\n      [this[i], this[i - 1]] = [this[i - 1], this[i]];\n    }\n    // set edge\n    this[this[x]] = y;\n\n    // update offsets\n    for (let i = x + 1; i <= vertices; i++) {\n      this[i] += 1;\n    }\n    return this;\n  }\n\n  /**\n   * @private\n   * @param {number} x the starting vertex\n   * @param {number} y the ending vertex\n   * @returns {UnweightedAdjacencyList}\n   */\n  unsetEdge(x, y) {\n    const offset = this[x];\n    const nextOffset = this[x + 1];\n    // no out edges from x\n    if (offset === nextOffset) return this;\n    let edgeIndex = 0;\n    for (let i = offset; i < nextOffset; i++) {\n      if (this[i] === y) {\n        edgeIndex = i;\n        break;\n      }\n    }\n    // there is no such edge\n    if (!edgeIndex) return this;\n    // shift value\n    for (let i = edgeIndex; i < this[this.vertices]; i++) {\n      this[i] = this[i + 1];\n    }\n\n    // update offsets\n    for (let i = x + 1; i <= this.vertices; i++) {\n      this[i] -= 1;\n    }\n\n    return this;\n  }\n\n  /**\n   * Iterates over outgoing edges of a vertex.\n   *\n   * @generator\n   * @param {number} vertex the vertex\n   * @yields {number}\n   */\n  * outEdges(vertex) {\n    const offset = this[vertex];\n    const nextOffset = this[vertex + 1];\n    if (offset !== nextOffset) {\n      for (let i = nextOffset - 1; i >= offset; i--) {\n        yield this[i];\n      }\n    }\n  }\n\n  /**\n   * Iterates over incoming edges of a vertex.\n   *\n   * @generator\n   * @param {number} vertex the vertex\n   * @yields {number}\n   */\n  * inEdges(vertex) {\n    const { vertices } = this;\n    let edge = 0;\n    let nextVertex = 1;\n    for (let i = vertices + 1; i < this[vertices]; i++) {\n      while (i >= this[nextVertex]) {\n        edge++;\n        nextVertex++;\n      }\n      if (this[i] === vertex) yield edge;\n    }\n  }\n\n  /**\n   * @private\n   * @returns {void}\n   */\n  setOffsets() {\n    const lastElement = this.vertices + 1;\n    for (let i = 0; i < lastElement; i++) {\n      this[i] = lastElement;\n    }\n  }\n\n  /**\n   * Checks whether the list is full--all available edges are set.\n   *\n   * @returns {boolean}\n   */\n  isFull() {\n    return this[this.vertices] >= this.length;\n  }\n\n  /**\n   * Creates a larger copy of the graph with a space\n   * for a specified amount of additional vertices and edges.\n   *\n   * @param {number} [vertices=0] the amount of additional vertices\n   * @param {number} [edges=1] the amount of additional edges\n   * @returns {UnweightedAdjacencyList}\n   */\n  grow(vertices = 0, edges = 1) {\n    const copy = new this.constructor({\n      vertices: this.vertices + vertices,\n      edges: this.edges + edges,\n    });\n\n    if (!vertices) {\n      copy.set(this);\n    } else {\n      const offset = this[this.vertices];\n      const newSize = this.vertices + vertices;\n      const newOffset = offset + vertices;\n      for (let i = 0; i <= newSize; i++) {\n        copy[i] = i < this.vertices ? this[i] + vertices : newOffset;\n      }\n      copy.set(this.subarray(this.vertices + 1), newSize + 1);\n    }\n    return copy;\n  }\n\n  /**\n   * Returns the length of underlying TypedArray required to hold the graph.\n   *\n   * @param {number} vertices\n   * @param {number} edges\n   * @returns {number}\n   */\n  static getLength(vertices, edges) {\n    return vertices + edges + 1;\n  }\n\n  /**\n   * Derives the vertex count of an adjacency list stored as an array-like object.\n   *\n   * @param {Collection} array\n   * @returns {number}\n   */\n  static getVertexCount(array) {\n    let vertices = 0;\n    while (array[vertices] <= array[vertices + 1]) {\n      vertices++;\n    }\n    return vertices;\n  }\n\n  /**\n   * @type {CollectionConstructor}\n   */\n  static get [Symbol.species]() {\n    return Uint32Array;\n  }\n\n  /**\n   * Creates an adjacency list from a given grid or adjacency matrix.\n   *\n   * @param {Grid|BinaryGrid|SymmetricGrid} grid\n   * @returns {UnweightedAdjacencyList}\n   */\n  static fromGrid(grid) {\n    const vertices = grid.rows;\n    const offset = vertices + 1;\n    const empty = grid.pad || 0;\n    const array = new Array(offset).fill(offset);\n    let edges = 0;\n    for (let i = 0; i < vertices; i++) {\n      array[i + 1] = i === 0 ? offset : array[i];\n      for (let j = 0; j < vertices; j++) {\n        if (grid.get(i, j) !== empty) {\n          array.push(j);\n          array[i + 1] += 1;\n          edges++;\n        }\n      }\n    }\n    const graph = new this({ vertices, edges });\n    graph.set(array);\n    return graph;\n  }\n}\n\n/**\n * Whether the graph is undirected.\n * @type {boolean}\n */\nUnweightedAdjacencyList.undirected = false;\n\n/**\n * Whether the graph is weighted.\n * @type {boolean}\n */\nUnweightedAdjacencyList.weighted = false;\n\nmodule.exports = UnweightedAdjacencyList;\n","const BinaryGrid = require('./binary-grid');\n\n/**\n * Implements Adjacency Matrix for unweighted graphs.\n *\n * @extends BinaryGrid\n */\nclass UnweightedAdjacencyMatrix extends BinaryGrid {\n  /**\n   * @param {Object} [options]\n   * @param {number} [options.vertices=2] the maximum number of vertices\n   * @param {...*} [args]\n   */\n  constructor(options = {}, ...args) {\n    const { vertices = 2 } = options;\n    super({ rows: vertices, columns: vertices }, ...args);\n    Object.defineProperties(this, {\n      vertices: { value: vertices },\n    });\n  }\n\n  /**\n   * Adds an edge between two vertices.\n   *\n   * @param {number} x the starting vertex\n   * @param {number} y the ending vertex\n   * @returns {UnweightedAdjacencyMatrix}\n   */\n  addEdge(x, y) {\n    const { undirected } = this.constructor;\n    this.set(x, y);\n    if (undirected) this.set(y, x);\n    return this;\n  }\n\n  /**\n   * Removes an edge between two vertices.\n   *\n   * @param {number} x the starting vertex\n   * @param {number} y the ending vertex\n   * @returns {UnweightedAdjacencyMatrix}\n   */\n  removeEdge(x, y) {\n    const { undirected } = this.constructor;\n    this.set(x, y, 0);\n    if (undirected) this.set(y, x, 0);\n    return this;\n  }\n\n  /**\n   * Checks if there is an edge between two vertices.\n   *\n   * @param {number} x the starting vertex\n   * @param {number} y the ending vertex\n   * @returns {boolean}\n   */\n  hasEdge(x, y) {\n    return !!this.get(x, y);\n  }\n\n  /**\n   * Returns 1 if the edge between the given vertices exists, 0 otherwise.\n   *\n   * @param {number} x the starting vertex\n   * @param {number} y the ending vertex\n   * @returns {number}\n   */\n  getEdge(x, y) {\n    return this.get(x, y);\n  }\n\n  /**\n   * Iterates over outgoing edges of a vertex.\n   *\n   * @generator\n   * @param {number} vertex the vertex\n   * @yields {number}\n   */\n  * outEdges(vertex) {\n    const { columns, offset } = this;\n    const start = vertex << offset;\n    const end = start + columns;\n    for (let i = start; i < end; i++) {\n      const bucket = i >> 4;\n      const position = i - (bucket << 4);\n      const value = (this[bucket] >> position) & 1;\n      if (value) yield i - start;\n    }\n  }\n\n  /**\n   * Iterates over incoming edges of a vertex.\n   *\n   * @generator\n   * @param {number} vertex the vertex\n   * @yields {number}\n   */\n  * inEdges(vertex) {\n    const { rows, offset } = this;\n    for (let i = 0; i < rows; i++) {\n      const index = (i << offset) + vertex;\n      const bucket = index >> 4;\n      const position = index - (bucket << 4);\n      const value = (this[bucket] >> position) & 1;\n      if (value) yield i;\n    }\n  }\n\n  /**\n   * Returns the length of underlying TypedArray required to hold the graph.\n   *\n   * @param {number} vertices\n   * @returns {number}\n   */\n  static getLength(vertices) {\n    return super.getLength(vertices, vertices);\n  }\n\n  /**\n   * Creates an adjacency matrix from a given adjacency list.\n   *\n   * @param {UnweightedAdjacencyList} list\n   * @returns {UnweightedAdjacencyMatrix}\n   */\n  static fromList(list) {\n    const { vertices } = list;\n    const graph = new this({ vertices });\n    for (let i = 0; i < vertices; i++) {\n      const offset = list[i];\n      const nextOffset = list[i + 1];\n      if (offset === nextOffset) continue;\n      for (let j = nextOffset - 1; j >= offset; j--) {\n        graph.addEdge(i, list[j]);\n      }\n    }\n    return graph;\n  }\n}\n\n/**\n * Whether the graph is undirected.\n * @type {boolean}\n */\nUnweightedAdjacencyMatrix.undirected = false;\n\n/**\n * Whether the graph is weighted.\n * @type {boolean}\n */\nUnweightedAdjacencyMatrix.weighted = false;\n\nmodule.exports = UnweightedAdjacencyMatrix;\n","/**\n * Creates a WeightedAdjacencyList class extending a given TypedArray class.\n *\n * @param {CollectionConstructor} Base\n * @returns {WeightedAdjacencyList}\n */\nfunction WeightedAdjacencyListMixin(Base) {\n  /**\n   * Implements Adjacency List data structure for weighted graphs.\n   *\n   * @extends CollectionConstructor\n   */\n  class WeightedAdjacencyList extends Base {\n    /**\n     * @param {Object} [options]\n     * @param {number} [options.vertices=2] the maximum amount of vertices in the graph\n     * @param {number} [options.edges=2] the maximum amount of edges in the graph\n     * @param {...*} args\n     */\n    constructor(options = {}, ...args) {\n      let { vertices, edges } = options;\n      if (args.length) {\n        if (!vertices && args[0].length) {\n          vertices = WeightedAdjacencyList.getVertexCount(args[0]);\n          edges = args[0].length - vertices - 1;\n        }\n        super(...args);\n      } else {\n        vertices = vertices || 2;\n        edges = edges || 4;\n        super((vertices + (edges << 1)) + 1);\n      }\n      Object.defineProperties(this, {\n        vertices: { value: vertices },\n        edges: { value: edges },\n      });\n\n      if (!args.length) this.setOffsets();\n    }\n\n    /**\n     * Adds an edge between two vertices.\n     *\n     * @param {number} x the starting vertex\n     * @param {number} y the ending vertex\n     * @param {number} weight the weight\n     * @throws {RangeError} if the list is full\n     * @returns {WeightedAdjacencyList}\n     */\n    addEdge(x, y, weight) {\n      const { undirected } = this.constructor;\n      if (this.hasEdge(x, y)) return this;\n      // the list is full\n      if (this.isFull()) throw new RangeError('The list is full.');\n      this.setEdge(x, y, weight);\n      if (undirected) this.setEdge(y, x, weight);\n      return this;\n    }\n\n    /**\n     * Removes an edge between two vertices.\n     *\n     * @param {number} x the starting vertex\n     * @param {number} y the ending vertex\n     * @returns {WeightedAdjacencyList}\n     */\n    removeEdge(x, y) {\n      const { undirected } = this.constructor;\n      this.unsetEdge(x, y);\n      if (undirected) this.unsetEdge(y, x);\n      return this;\n    }\n\n    /**\n     * Checks if there is an edge between two vertices.\n     *\n     * @param {number} x the starting vertex\n     * @param {number} y the ending vertex\n     * @returns {boolean}\n     */\n    hasEdge(x, y) {\n      return !Number.isNaN(this.getEdge(x, y));\n    }\n\n\n    /**\n     * Returns the weight of the edge between given vertices\n     * or NaN if the edge doesn't exist.\n     *\n     * @param {number} x the starting vertex\n     * @param {number} y the ending vertex\n     * @returns {number}\n     */\n    getEdge(x, y) {\n      const offset = this[x];\n      const nextOffset = this[x + 1];\n      // no out edges from x\n      if (offset === nextOffset) return NaN;\n      for (let i = offset; i < nextOffset; i += 2) {\n        if (this[i] === y) return this[i + 1];\n      }\n      return NaN;\n    }\n\n    /**\n     * @private\n     * @param {number} x the starting vertex\n     * @param {number} y the ending vertex\n     * @param {number} weight the weight\n     * @returns {WeightedAdjacencyList}\n     */\n    setEdge(x, y, weight) {\n      const { vertices } = this;\n\n      // shift values\n      for (let i = this[vertices]; i > this[x]; i -= 2) {\n        [this[i], this[i + 1], this[i - 1], this[i - 2]] = [this[i - 2], this[i - 1], this[i], this[i + 1]];\n      }\n      // set edge\n      this[this[x]] = y;\n      this[this[x] + 1] = weight;\n\n      // update offsets\n      for (let i = x + 1; i <= vertices; i++) {\n        this[i] += 2;\n      }\n      return this;\n    }\n\n    /**\n     * @private\n     * @param {number} x the starting vertex\n     * @param {number} y the ending vertex\n     * @returns {WeightedAdjacencyList}\n     */\n    unsetEdge(x, y) {\n      const offset = this[x];\n      const nextOffset = this[x + 1];\n      // no out edges from x\n      if (offset === nextOffset) return this;\n      let edgeIndex = 0;\n      for (let i = offset; i < nextOffset; i += 2) {\n        if (this[i] === y) {\n          edgeIndex = i;\n          break;\n        }\n      }\n      // there is no such edge\n      if (!edgeIndex) return this;\n      // shift value\n      for (let i = edgeIndex; i < this[this.vertices]; i += 2) {\n        this[i] = this[i + 2];\n        this[i + 1] = this[i + 3];\n      }\n\n      // update offsets\n      for (let i = x + 1; i <= this.vertices; i++) {\n        this[i] -= 2;\n      }\n\n      return this;\n    }\n\n    /**\n     * Iterates over outgoing edges of a vertex.\n     *\n     * @generator\n     * @param {number} vertex the vertex\n     * @yields {number}\n     */\n    * outEdges(vertex) {\n      const offset = this[vertex];\n      const nextOffset = this[vertex + 1];\n      if (offset !== nextOffset) {\n        for (let i = nextOffset - 2; i >= offset; i -= 2) {\n          yield this[i];\n        }\n      }\n    }\n\n    /**\n     * Iterates over incoming edges of a vertex.\n     *\n     * @generator\n     * @param {number} vertex the vertex\n     * @yields {number}\n     */\n    * inEdges(vertex) {\n      const { vertices } = this;\n      let edge = 0;\n      let nextVertex = 1;\n      for (let i = vertices + 1; i < this[vertices]; i += 2) {\n        while (i >= this[nextVertex]) {\n          edge++;\n          nextVertex++;\n        }\n        if (this[i] === vertex) yield edge;\n      }\n    }\n\n    /**\n     * @private\n     * @returns {void}\n     */\n    setOffsets() {\n      const lastElement = this.vertices + 1;\n      for (let i = 0; i < lastElement; i++) {\n        this[i] = lastElement;\n      }\n    }\n\n    /**\n     * Checks whether the list is full--all available edges are set.\n     *\n     * @returns {boolean}\n     */\n    isFull() {\n      return this[this.vertices] >= this.length;\n    }\n\n    /**\n     * Creates a larger copy of the graph with a space\n     * for a specified amount of additional vertices and edges.\n     *\n     * @param {number} [vertices=0] the amount of additional vertices\n     * @param {number} [edges=1] the amount of additional edges\n     * @returns {WeightedAdjacencyList}\n     */\n    grow(vertices = 0, edges = 1) {\n      const copy = new this.constructor({\n        vertices: this.vertices + vertices,\n        edges: this.edges + edges,\n      });\n\n      if (!vertices) {\n        copy.set(this);\n      } else {\n        const offset = this[this.vertices];\n        const newSize = this.vertices + vertices;\n        const newOffset = offset + vertices;\n        for (let i = 0; i <= newSize; i++) {\n          copy[i] = i < this.vertices ? this[i] + vertices : newOffset;\n        }\n        copy.set(this.subarray(this.vertices + 1), newSize + 1);\n      }\n      return copy;\n    }\n\n    /**\n     * Returns the length of underlying TypedArray required to hold the graph.\n     *\n     * @param {number} vertices\n     * @param {number} edges\n     * @returns {number}\n     */\n    static getLength(vertices, edges) {\n      return vertices + (edges << 1) + 1;\n    }\n\n    /**\n     * Derives the vertex count of an adjacency list stored as an array-like object.\n     *\n     * @param {Collection} array\n     * @returns {number}\n     */\n    static getVertexCount(array) {\n      let vertices = 0;\n      while (array[vertices] <= array[vertices + 1]) {\n        vertices++;\n      }\n      return vertices;\n    }\n\n    /**\n     * @type {CollectionConstructor}\n     */\n    static get [Symbol.species]() {\n      return Base;\n    }\n\n    /**\n     * Creates an adjacency list from a given grid or adjacency matrix.\n     *\n     * @param {Grid|BinaryGrid|SymmetricGrid} grid\n     * @returns {WeightedAdjacencyList}\n     */\n    static fromGrid(grid) {\n      const vertices = grid.rows;\n      const offset = vertices + 1;\n      const empty = grid.pad || 0;\n      const array = new Array(offset).fill(offset);\n      let edges = 0;\n      for (let i = 0; i < vertices; i++) {\n        array[i + 1] = i === 0 ? offset : array[i];\n        for (let j = 0; j < vertices; j++) {\n          const weight = grid.get(i, j);\n          if (weight !== empty) {\n            array.push(j, weight);\n            array[i + 1] += 2;\n            edges++;\n          }\n        }\n      }\n      const graph = new this({ vertices, edges });\n      graph.set(array);\n      return graph;\n    }\n  }\n\n  /**\n   * Whether the graph is undirected.\n   * @type {boolean}\n   */\n  WeightedAdjacencyList.undirected = false;\n\n  /**\n   * Whether the graph is weighted.\n   * @type {boolean}\n   */\n  WeightedAdjacencyList.weighted = true;\n\n  return WeightedAdjacencyList;\n}\n\n\nmodule.exports = WeightedAdjacencyListMixin;\n","const GridMixin = require('./grid');\nconst SymmetricGridMixin = require('./symmetric-grid');\n\n/**\n * Creates a WeightedAdjacencyMatrix class extending a given Array-like class.\n *\n * @param {CollectionConstructor} Base\n * @param {boolean} [undirected=false]\n * @returns {WeightedAdjacencyMatrix}\n */\nfunction WeightedAdjacencyMatrixMixin(Base, undirected = false) {\n  const Grid = undirected ? SymmetricGridMixin(Base) : GridMixin(Base);\n\n  /**\n   * Implements Adjacency Matrix for weighted graphs.\n   *\n   * @extends Grid\n   */\n  class WeightedAdjacencyMatrix extends Grid {\n    /**\n     * @param {Object} [options]\n     * @param {number} [options.vertices=2] the maximum number of vertices\n     * @param {*} [options.pad=0] the initial value of all edges\n     * @param {...*} [args]\n     */\n    constructor(options = {}, ...args) {\n      const { vertices = 2, pad = 0 } = options;\n      super({ rows: vertices, columns: vertices, pad }, ...args);\n      Object.defineProperties(this, {\n        vertices: { value: vertices },\n      });\n    }\n\n    /**\n     * Adds an edge between two vertices.\n     *\n     * @param {number} x the starting vertex\n     * @param {number} y the ending vertex\n     * @param {number} weight\n     * @returns {WeightedAdjacencyMatrix}\n     */\n    addEdge(x, y, weight) {\n      this.set(x, y, weight);\n      return this;\n    }\n\n    /**\n     * Removes an edge between two vertices.\n     *\n     * @param {number} x the starting vertex\n     * @param {number} y the ending vertex\n     * @returns {WeightedAdjacencyMatrix}\n     */\n    removeEdge(x, y) {\n      this.set(x, y, this.pad);\n      return this;\n    }\n\n    /**\n     * Checks if there is an edge between two vertices.\n     *\n     * @param {number} x the starting vertex\n     * @param {number} y the ending vertex\n     * @returns {boolean}\n     */\n    hasEdge(x, y) {\n      return this.get(x, y) !== this.pad;\n    }\n\n    /**\n     * Returns the weight of the edge between given vertices if it exists.\n     *\n     * @param {number} x the starting vertex\n     * @param {number} y the ending vertex\n     * @returns {number}\n     */\n    getEdge(x, y) {\n      return this.get(x, y);\n    }\n\n    /**\n     * Iterates over outgoing edges of a vertex.\n     *\n     * @generator\n     * @param {number} vertex the vertex\n     * @yields {number}\n     */\n    * outEdges(vertex) {\n      const { vertices } = this;\n      for (let i = 0; i < vertices; i++) {\n        if (this.hasEdge(vertex, i)) yield i;\n      }\n    }\n\n    /**\n     * Iterates over incoming edges of a vertex.\n     *\n     * @generator\n     * @param {number} vertex the vertex\n     * @yields {number}\n     */\n    * inEdges(vertex) {\n      const { vertices } = this;\n      for (let i = 0; i < vertices; i++) {\n        if (this.hasEdge(i, vertex)) yield i;\n      }\n    }\n\n    /**\n     * Returns the length of underlying Array required to hold the graph.\n     *\n     * @param {number} vertices\n     * @returns {number}\n     */\n    static getLength(vertices) {\n      return super.getLength(vertices, vertices);\n    }\n\n    /**\n     * Creates an adjacency matrix from a given adjacency list.\n     *\n     * @param {WeightedAdjacencyList} list\n     * @param {number} [pad=0]\n     * @returns {WeightedAdjacencyMatrix}\n     */\n    static fromList(list, pad = 0) {\n      const { vertices } = list;\n      const graph = new this({ vertices, pad });\n      for (let i = 0; i < vertices; i++) {\n        const offset = list[i];\n        const nextOffset = list[i + 1];\n        if (offset === nextOffset) continue;\n        for (let j = nextOffset - 2; j >= offset; j -= 2) {\n          graph.addEdge(i, list[j], list[j + 1]);\n        }\n      }\n      return graph;\n    }\n  }\n\n  /**\n   * Whether the graph is undirected.\n   * @type {boolean}\n   */\n  WeightedAdjacencyMatrix.undirected = undirected;\n\n  /**\n   * Whether the graph is weighted.\n   * @type {boolean}\n   */\n  WeightedAdjacencyMatrix.weighted = true;\n\n  return WeightedAdjacencyMatrix;\n}\n\n\nmodule.exports = WeightedAdjacencyMatrixMixin;\n","/**\n * @param {Class<ObjectView>} ObjectViewClass\n * @returns {Class<ArrayView>}\n */\nfunction ArrayViewMixin(ObjectViewClass) {\n  if (!ObjectViewClass.isInitialized) ObjectViewClass.initialize();\n\n  /**\n   * @extends ObjectView\n   */\n  class ArrayView extends ObjectViewClass {\n    /**\n     * Returns an object at a given index.\n     *\n     * @param {number} index\n     * @returns {ObjectView}\n     */\n    get(index) {\n      const { objectLength } = this.constructor;\n      return new ObjectViewClass(\n        this.buffer, this.byteOffset + (index * objectLength), objectLength,\n      );\n    }\n\n    /**\n     * Sets an object at a given index.\n     *\n     * @param {number} index\n     * @param {Object} value\n     * @returns {ArrayView}\n     */\n    set(index, value) {\n      this.setObject(index * this.constructor.objectLength, value, this.constructor);\n      return this;\n    }\n\n    /**\n     * Sets an object view at a given index.\n     *\n     * @param {number} index\n     * @param {ObjectView} value\n     * @returns {ArrayView}\n     */\n    setView(index, value) {\n      const { objectLength } = this.constructor;\n      new Uint8Array(this.buffer, this.byteOffset + (index * objectLength), objectLength)\n        .set(new Uint8Array(value.buffer, value.byteOffset, value.length));\n      return this;\n    }\n\n    /**\n     * Returns the amount of available objects in the array.\n     *\n     * @type {number}\n     */\n    get size() {\n      return this.byteLength / this.constructor.objectLength;\n    }\n\n\n    /**\n     * Allows iterating over numbers stored in the instance.\n     *\n     * @yields {number}\n     */\n    * [Symbol.iterator]() {\n      const { size } = this;\n      for (let i = 0; i < size; i++) {\n        yield this.get(i);\n      }\n    }\n\n    /**\n     * Returns an array representation of the array view.\n     *\n     * @returns {Array<Object>}\n     */\n    toObject() {\n      return this.getArray(0, this.constructor, this.size);\n    }\n\n    /**\n     * Creates an array view from a given array of objects.\n     *\n     * @param {ArrayLike<Object>} value\n     * @param {ArrayView} [array]\n     * @returns {ArrayView}\n     */\n    static from(value, array) {\n      const arrayView = array || this.of(value.length);\n      const { size } = arrayView;\n      for (let i = 0; i < size; i++) {\n        arrayView.set(i, value[i]);\n      }\n      return arrayView;\n    }\n\n    /**\n     * Returns the byte length of an array view to hold a given amount of objects.\n     *\n     * @param {number} size\n     * @returns {number}\n     */\n    static getLength(size) {\n      return size * this.objectLength;\n    }\n\n    /**\n     * Creates an empty array view of specified size.\n     *\n     * @param {number} size\n     * @returns {ArrayView}\n     */\n    static of(size = 1) {\n      const buffer = new ArrayBuffer(this.getLength(size));\n      return new this(buffer);\n    }\n  }\n\n  return ArrayView;\n}\n\n\nmodule.exports = ArrayViewMixin;\n","/**\n * @private\n */\nconst getters = {\n  int8: 'getInt8',\n  uint8: 'getUint8',\n  int16: 'getInt16',\n  uint16: 'getUint16',\n  int32: 'getInt32',\n  uint32: 'getUint32',\n  float32: 'getFloat32',\n  float64: 'getFloat64',\n  bigint64: 'getBigInt64',\n  biguint64: 'getBigUint64',\n};\n\n/**\n * @private\n */\nconst setters = {\n  int8: 'setInt8',\n  uint8: 'setUint8',\n  int16: 'setInt16',\n  uint16: 'setUint16',\n  int32: 'setInt32',\n  uint32: 'setUint32',\n  float32: 'setFloat32',\n  float64: 'setFloat64',\n  bigint64: 'setBigInt64',\n  biguint64: 'setBigUint64',\n};\n\n/**\n * @private\n */\nconst offsets = {\n  int8: 0,\n  uint8: 0,\n  int16: 1,\n  uint16: 1,\n  int32: 2,\n  uint32: 2,\n  float32: 2,\n  float64: 3,\n  bigint64: 3,\n  biguint64: 3,\n};\n\n/**\n * @param {string} type\n * @param {boolean} [littleEndian]\n * @returns {Class<TypedArrayView>}\n */\nfunction TypedArrayViewMixin(type, littleEndian) {\n  /**\n   * @extends DataView\n   */\n  class TypedArrayView extends DataView {\n    /**\n     * Returns a number at a given index.\n     *\n     * @param {number} index\n     * @returns {number}\n     */\n    get(index) {\n      const { typeGetter, offset, littleEndian: le } = this.constructor;\n      return this[typeGetter](index << offset, le);\n    }\n\n    /**\n     * Sets a number at a given index.\n     *\n     * @param {number} index\n     * @param {number} value\n     * @returns {TypedArrayView}\n     */\n    set(index, value) {\n      const { typeSetter, offset, littleEndian: le } = this.constructor;\n      this[typeSetter](index << offset, value, le);\n      return this;\n    }\n\n    /**\n     * Returns the amount of available numbers in the array.\n     *\n     * @type {number}\n     */\n    get size() {\n      return this.byteLength >> this.constructor.offset;\n    }\n\n\n    /**\n     * Allows iterating over numbers stored in the instance.\n     *\n     * @yields {number}\n     */\n    * [Symbol.iterator]() {\n      const { size } = this;\n      for (let i = 0; i < size; i++) {\n        yield this.get(i);\n      }\n    }\n\n    /**\n     * Returns an array representation of the array view.\n     *\n     * @returns {Array<number>}\n     */\n    toObject() {\n      return [...this];\n    }\n\n    /**\n     * Returns the byte length of an array view to hold a given amount of numbers.\n     *\n     * @param {number} size\n     * @returns {number}\n     */\n    static getLength(size) {\n      return size << this.offset;\n    }\n\n    /**\n     * Creates an array view from a given array of numbers.\n     *\n     * @param {ArrayLike<number>} value\n     * @param {TypedArrayView} [array]\n     * @returns {TypedArrayView}\n     */\n    static from(value, array) {\n      const dataArray = array || this.of(value.length);\n      const { size } = dataArray;\n      for (let i = 0; i < size; i++) {\n        dataArray.set(i, value[i]);\n      }\n      return dataArray;\n    }\n\n    /**\n     * Creates an empty array view of specified size.\n     *\n     * @param {number} size\n     * @returns {TypedArrayView}\n     */\n    static of(size = 1) {\n      const buffer = new ArrayBuffer(this.getLength(size));\n      return new this(buffer);\n    }\n  }\n\n  /**\n   * @private\n   * @type {string}\n   */\n  TypedArrayView.typeGetter = getters[type];\n\n  /**\n   * @private\n   * @type {string}\n   */\n  TypedArrayView.typeSetter = setters[type];\n\n  /**\n   * @private\n   * @type {number}\n   */\n  TypedArrayView.offset = offsets[type];\n\n  /**\n   * @private\n   * @type {boolean}\n   */\n  TypedArrayView.littleEndian = !!littleEndian;\n\n  return TypedArrayView;\n}\n\nmodule.exports = TypedArrayViewMixin;\n","const StringView = require('./string-view');\nconst DataArrayMixin = require('./array-view');\nconst TypedArrayViewMixin = require('./typed-array-view');\n\n/**\n * @typedef {('int8' | 'uint8' | 'int16' | 'uint16'\n * | 'int32' | 'uint32' | 'float32' | 'float64'\n * | 'bigint64' | 'biguint64' | 'string' | 'array' | 'object' | 'typedarray'\n * | Class<ArrayView>|Class<ObjectView>|Class<TypedArrayView>)} ObjectViewFieldType\n */\n\n/**\n * @typedef {Object} ObjectViewField\n * @property {ObjectViewFieldType} type\n * @property {number} [size] the maximum size in bytes for a string type\n * @property {boolean} [littleEndian]\n * @property {number} [start]\n * @property {number} [length]\n * @property {Class<ArrayView>|Class<ObjectView>|Class<TypedArrayView>} [ctor]\n */\n\n/**\n * @private\n */\nconst fieldSizes = {\n  int8: 1,\n  uint8: 1,\n  int16: 2,\n  uint16: 2,\n  int32: 4,\n  uint32: 4,\n  float32: 4,\n  float64: 8,\n  bigint64: 8,\n  biguint64: 8,\n  string: 0,\n};\n\n/**\n * @extends DataView\n */\nclass ObjectView extends DataView {\n  /**\n   * Returns the value of a given field.\n   *\n   * @param {string} field the name of the field\n   * @returns {*} value of the field\n   */\n  get(field) {\n    const {\n      type, littleEndian, start, ctor, length,\n    } = this.constructor.schema[field];\n    switch (type) {\n      case 'int8': return this.getInt8(start);\n      case 'uint8': return this.getUint8(start);\n      case 'int16': return this.getInt16(start, littleEndian);\n      case 'uint16': return this.getUint16(start, littleEndian);\n      case 'int32': return this.getInt32(start, littleEndian);\n      case 'uint32': return this.getUint32(start, littleEndian);\n      case 'float32': return this.getFloat32(start, littleEndian);\n      case 'float64': return this.getFloat64(start, littleEndian);\n      case 'bigint64': return this.getBigInt64(start, littleEndian);\n      case 'biguint64': return this.getBigUint64(start, littleEndian);\n      default: return this.getView(start, length, ctor);\n    }\n  }\n\n  /**\n   * @private\n   * @param {number} position\n   * @param {Class<ArrayView>|Class<ObjectView>} ctor\n   * @param {number} size\n   * @returns {Array<Object>}\n   */\n  getArray(position, ctor, size) {\n    const { schema, objectLength } = ctor;\n    const result = new Array(size);\n    for (let i = 0; i < size; i++) {\n      result[i] = this.getObject(schema, position + (i * objectLength));\n    }\n    return result;\n  }\n\n  /**\n   * @private\n   * @param {number} position\n   * @param {Class<TypedArrayView>} ctor\n   * @param {number} size\n   * @returns {Array<number>}\n   */\n  getTypedArray(position, ctor, size) {\n    const { typeGetter, offset, littleEndian } = ctor;\n    const result = new Array(size);\n    for (let i = 0; i < size; i++) {\n      result[i] = this[typeGetter](position + (i << offset), littleEndian);\n    }\n    return result;\n  }\n\n  /**\n   * @private\n   * @param {object} schema\n   * @param {number} offset\n   * @returns {Object}\n   */\n  getObject(schema, offset) {\n    const fields = Object.keys(schema);\n    const result = {};\n    for (let i = 0; i < fields.length; i++) {\n      const name = fields[i];\n      const {\n        type, littleEndian, start, ctor: Ctor, length, size,\n      } = schema[name];\n      let value;\n      const position = offset + start;\n      switch (type) {\n        case 'int8': value = this.getInt8(position); break;\n        case 'uint8': value = this.getUint8(position); break;\n        case 'int16': value = this.getInt16(position, littleEndian); break;\n        case 'uint16': value = this.getUint16(position, littleEndian); break;\n        case 'int32': value = this.getInt32(position, littleEndian); break;\n        case 'uint32': value = this.getUint32(position, littleEndian); break;\n        case 'float32': value = this.getFloat32(position, littleEndian); break;\n        case 'float64': value = this.getFloat64(position, littleEndian); break;\n        case 'bigint64': value = this.getBigInt64(position, littleEndian); break;\n        case 'biguint64': value = this.getBigUint64(position, littleEndian); break;\n        case 'string': value = new StringView(this.buffer, this.byteOffset + position, length).toString(); break;\n        case 'typedarray': value = this.getTypedArray(position, Ctor, size); break;\n        case 'array': value = this.getArray(position, Ctor, size); break;\n        default: value = this.getObject(Ctor.schema, position);\n      }\n      result[name] = value;\n    }\n    return result;\n  }\n\n  /**\n   * @private\n   * @param {number} position\n   * @param {number} length\n   * @param {Class<ArrayView>|Class<TypedArrayView>\n   *   |Class<ObjectView>|Class<StringView>} [Ctor=StringView]\n   * @returns {ArrayView|TypedArrayView|ObjectView|StringView}\n   */\n  getView(position, length, Ctor = StringView) {\n    return new Ctor(this.buffer, this.byteOffset + position, length);\n  }\n\n  /**\n   * Sets a value to a field.\n   *\n   * @param {string} field the name of the field\n   * @param {*} value the value to be set\n   * @returns {ObjectView}\n   */\n  set(field, value) {\n    return this.setValue(field, value);\n  }\n\n  /**\n   * @private\n   * @param {number} position\n   * @param {ArrayLike<object>} value\n   * @param {Class<ArrayView>|Class<ObjectView>} ctor\n   * @param {number} size\n   * @returns {void}\n   */\n  setArray(position, value, ctor, size) {\n    const { fields, schema } = ctor;\n    const max = (size < value.length ? size : value.length);\n    for (let i = 0; i < max; i++) {\n      for (let j = 0; j < fields.length; j++) {\n        const name = fields[j];\n        this.setValue(name, value[i][name], schema, position + (i * ctor.objectLength));\n      }\n    }\n  }\n\n  /**\n   * @private\n   * @param {number} position\n   * @param {Object} value\n   * @param {Class<ObjectView>} ctor\n   * @returns {void}\n   */\n  setObject(position, value, ctor) {\n    const { fields, schema } = ctor;\n    for (let i = 0; i < fields.length; i++) {\n      const name = fields[i];\n      if (Reflect.has(value, name)) this.setValue(name, value[name], schema, position);\n    }\n  }\n\n  /**\n   * @private\n   * @param {number} position\n   * @param {string} value\n   * @param {number} length\n   * @returns {void}\n   */\n  setString(position, value, length) {\n    new Uint8Array(this.buffer, this.byteOffset + position, length)\n      .fill(0)\n      .set(StringView.fromString(value));\n  }\n\n  /**\n   * @private\n   * @param {number} position\n   * @param {ArrayLike<number>} value\n   * @param {Class<TypedArrayView>} ctor\n   * @param {number} size\n   * @returns {void}\n   */\n  setTypedArray(position, value, ctor, size) {\n    const { typeSetter, offset, littleEndian } = ctor;\n    const max = (size < value.length ? size : value.length);\n    for (let i = 0; i < max; i++) {\n      this[typeSetter](position + (i << offset), value[i], littleEndian);\n    }\n  }\n\n  /**\n   * @private\n   * @param {string} field\n   * @param {*} value\n   * @param {*} [schema]\n   * @param {number} [offset=0]\n   * @returns {ObjectView}\n   */\n  setValue(field, value, schema = this.constructor.schema, offset = 0) {\n    const {\n      type, littleEndian, start, ctor, length, size,\n    } = schema[field];\n    const position = offset + start;\n    switch (type) {\n      case 'int8':\n        this.setInt8(position, value);\n        break;\n      case 'uint8':\n        this.setUint8(position, value);\n        break;\n      case 'int16':\n        this.setInt16(position, value, littleEndian);\n        break;\n      case 'uint16':\n        this.setUint16(position, value, littleEndian);\n        break;\n      case 'int32':\n        this.setInt32(position, value, littleEndian);\n        break;\n      case 'uint32':\n        this.setUint32(position, value, littleEndian);\n        break;\n      case 'float32':\n        this.setFloat32(position, value, littleEndian);\n        break;\n      case 'float64':\n        this.setFloat64(position, value, littleEndian);\n        break;\n      case 'bigint64':\n        this.setBigInt64(position, value, littleEndian);\n        break;\n      case 'biguint64':\n        this.setBigUint64(position, value, littleEndian);\n        break;\n      case 'string':\n        this.setString(position, value, length);\n        break;\n      case 'typedarray':\n        this.setTypedArray(position, value, ctor, size);\n        break;\n      case 'array':\n        this.setArray(position, value, ctor, size);\n        break;\n      default:\n        this.setObject(position, value, ctor);\n        break;\n    }\n    return this;\n  }\n\n  /**\n   * Sets an ObjectView value to a field.\n   *\n   * @param {string} field\n   * @param {ObjectView|ArrayView|TypedArrayView|StringView} value\n   * @returns {ObjectView}\n   */\n  setView(field, value) {\n    const { start } = this.constructor.schema[field];\n    new Uint8Array(this.buffer, this.byteOffset, this.byteLength)\n      .set(\n        new Uint8Array(value.buffer, value.byteOffset, value.byteLength),\n        start,\n      );\n    return this;\n  }\n\n  /**\n   * Returns an Object corresponding to the object view.\n   *\n   * @returns {Object}\n   */\n  toObject() {\n    return this.getObject(this.constructor.schema, 0);\n  }\n\n  /**\n   * Assigns fields of a given object to the provided object view\n   * or a new object view.\n   *\n   * @param {Object} object the object to take data from\n   * @param {ObjectView} [view] the object view to assign fields to\n   * @returns {ObjectView}\n   */\n  static from(object, view) {\n    const objectView = view || new this(new ArrayBuffer(this.getLength()));\n    objectView.setObject(0, object, objectView.constructor);\n    return objectView;\n  }\n\n  /**\n   * Returns the byte length of an object view.\n   *\n   * @returns {number}\n   */\n  static getLength() {\n    if (!this.isInitialized) this.initialize();\n    return this.objectLength;\n  }\n\n  /**\n   * @private\n   * @returns {void}\n   */\n  static initialize() {\n    const { schema } = this;\n    const fields = Object.keys(schema);\n    let lastOffset = 0;\n    for (let i = 0; i < fields.length; i++) {\n      const name = fields[i];\n      const field = schema[name];\n      const { type, size, littleEndian } = field;\n      let byteSize = 0;\n      const isPrimitive = typeof type === 'string';\n      const isTypedArray = isPrimitive && !!size;\n      const isArray = !isTypedArray && !!size;\n      // account for wrong primitive type\n      if (isPrimitive && !Reflect.has(fieldSizes, type)) {\n        throw TypeError(`Type \"${type}\" is not a valid type.`);\n      }\n      if (isTypedArray) {\n        field.ctor = TypedArrayViewMixin(type, littleEndian);\n        field.type = 'typedarray';\n        byteSize = field.ctor.getLength(size);\n      } else if (isArray) {\n        field.ctor = DataArrayMixin(type);\n        field.type = 'array';\n        byteSize = field.ctor.getLength(size);\n      } else if (!isPrimitive) {\n        field.type = 'object';\n        field.ctor = type;\n        byteSize = type.getLength();\n      }\n      field.start = lastOffset;\n      field.length = field.length || byteSize || fieldSizes[type];\n      lastOffset += field.length;\n    }\n    this.objectLength = lastOffset;\n    this.fields = fields;\n    this.isInitialized = true;\n  }\n}\n/**\n * @private\n * @type {Array<ObjectViewField>}\n */\nObjectView.fields = undefined;\n\n/**\n * @private\n */\nObjectView.schema = undefined;\n\n/**\n * @private\n */\nObjectView.objectLength = 0;\n\n/** @type {boolean} */\nObjectView.isInitialized = false;\n\nmodule.exports = ObjectView;\n","const BitField = require('./lib/bit-field');\nconst GraphMixin = require('./lib/graph');\nconst GridMixin = require('./lib/grid');\nconst BinaryHeap = require('./lib/binary-heap.js');\nconst Pool = require('./lib/pool');\nconst RankedBitArray = require('./lib/ranked-bit-array');\nconst RecordArray = require('./lib/record-array');\nconst SortedArray = require('./lib/sorted-array');\nconst SortedMixin = require('./lib/sorted-collection');\nconst SymmetricGridMixin = require('./lib/symmetric-grid');\nconst UnweightedAdjacencyList = require('./lib/unweighted-adjacency-list');\nconst UnweightedAdjacencyMatrix = require('./lib/unweighted-adjacency-matrix');\nconst WeightedAdjacencyListMixin = require('./lib/weighted-adjacency-list');\nconst WeightedAdjacencyMatrixMixin = require('./lib/weighted-adjacency-matrix');\nconst ArrayViewMixin = require('./lib/array-view');\nconst ObjectView = require('./lib/object-view');\nconst StringView = require('./lib/string-view');\nconst TypedArrayViewMixin = require('./lib/typed-array-view');\n\n/**\n * @external ArrayBuffer\n * @see {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer|ArrayBuffer}\n */\n\n/**\n * @external DataView\n * @see {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DataView|DataView}\n */\n\n/**\n * @external TypedArray\n * @see {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray|TypedArray}\n */\n\nmodule.exports = {\n  BitField,\n  GraphMixin,\n  GridMixin,\n  BinaryHeap,\n  Pool,\n  RankedBitArray,\n  RecordArray,\n  SortedArray,\n  SortedMixin,\n  SymmetricGridMixin,\n  UnweightedAdjacencyList,\n  UnweightedAdjacencyMatrix,\n  WeightedAdjacencyListMixin,\n  WeightedAdjacencyMatrixMixin,\n  ArrayViewMixin,\n  ObjectView,\n  StringView,\n  TypedArrayViewMixin,\n};\n","<!-- <svelte:options immutable={true} /> -->\n<!-- <svelte:component class=\".container\"  this={Sokoban} /> -->\n<script>\nexport let mapGrid;\nexport let level;\nimport { onMount } from 'svelte';\nimport { quintOut } from 'svelte/easing';\nimport { crossfade } from 'svelte/transition';\nimport { flip } from 'svelte/animate';\n\nimport { GridMixin } from 'structurae';\n\nimport hotkeys from 'hotkeys-js';\n\nconst directions = {left: {row: 0, column: -1, str: 'left'}, down: {row: 1, column: 0, str: 'down'}, right: {row: 0, column: 1, str: 'right'}, up: {row: -1, column: 0, str: 'up'}};\n\nfunction getRandomImageIndex(tileKey) {\n  const max = {C: 6, W: 4, ' ': 3, P: 5};\n  const min = {C: 2, W: 1, ' ': 1, P: 0};\n  const random = Math.max(Math.floor(Math.random() * Math.floor(max[tileKey])), min[tileKey]);\n  return tileKey === 'P' ? random : ('0' + random).slice(-2);\n}\n\nconst imageBasePath = \"sokoban/images/\";\nconst crate = {key: 'C', imagePrefix: 'Crates/crate_', imageIndex: getRandomImageIndex('C'), imageSuffix: '.png'};\nconst wall = {key: 'W', imagePrefix: 'Blocks/block_', imageIndex: getRandomImageIndex('W'), imageSuffix: '.png'};\nconst blank = {key: ' ', imagePrefix: 'Ground/ground_', imageIndex: getRandomImageIndex(' '), imageSuffix: '.png'};\nconst goal = {key: 'G', imagePrefix: 'Ground/ground_', imageIndex: blank.imageIndex, imageSuffix: '_goal.png'};\nconst player = {key: 'P', get imagePrefix() { return 'Player/' + this.direction.str + '/' }, imageIndex: 0, maxImageIndex: 5, imageSuffix: '.png',\n                get image() { return imageBasePath + this.imagePrefix + (this.moves % this.maxImageIndex) + this.imageSuffix;},\n                moves: 0, position: {row: 0, column: 0}, direction: directions.down, standingOn: blank};\n\nconst tileTypeDict = {};\ntileTypeDict['C'] = crate;\ntileTypeDict['G'] = goal;\ntileTypeDict['W'] = wall;\ntileTypeDict[' '] = blank;\nObject.values(tileTypeDict).forEach(tileType => {\n  tileType.image = imageBasePath + tileType.imagePrefix + tileType.imageIndex + tileType.imageSuffix;\n})\ntileTypeDict['P'] = player;\n\nlet goalTiles = [];\nlet map = [];\nlet rowIndex = 0;\nlet columns = 0;\nlet i = 0;\nmapGrid.forEach(row => {\n  let newRow = [];\n  let column = 0;\n  row.forEach(cell => {\n    const movableEntityTypes = \"PC\";\n    const cellKey = cell === 'B' ? 'C' : cell; //Block is a confusing name for the crates, so I'm translating the 'B' from the suggested map format of this exercise into a 'C'.\n    const movableEntity = (! movableEntityTypes.includes(cellKey)) ? null : {\n      key: cellKey,\n      initialLocationIndex: i,\n      initialPos: {row: rowIndex, column: column},\n    };\n    const fixedTile = { //fixed location on the grid\n      gridLocation: i,\n      initialKey: (! movableEntityTypes.includes(cellKey)) ? cellKey : blank.key,\n      entity: movableEntity,\n      moveEntityTo(destTile) {\n        if (destTile.entity) {\n          alert(`Warning! Entity of ${destTile} replaced by entity of ${this}.`);\n        }\n        destTile.entity = this.entity;\n        this.entity = null;\n        if (this.key === player.key) {\n          player.tile = this;\n        }\n        },\n      get id() { return this.entity ? this.entity.initialLocationIndex : -this.gridLocation },\n      get key() { return this.entity ? this.entity.key : this.initialKey },\n      floorKey: blank.key, index: i, position: {row: rowIndex, column: column},\n      get image() {\n        return this.isTraversable ? \"\" : tileTypeDict[this.key].image;\n      },\n      get backgroundImage() {\n        return this.isTraversable ? tileTypeDict[this.key].image : tileTypeDict[this.floorKey].image;\n      },\n      get isTraversable() { return this.key === ' ' || this.key === 'G'},\n      get hasCrate() { return this.key === 'C' && this.floorKey === 'G'},\n    }\n    if (cellKey === player.key) {\n      player.position = fixedTile.position;\n      player.standingOn = fixedTile;\n    }\n    if (cellKey === 'G') {\n      fixedTile.floorKey = 'G'; //used for the css background-image of the tile. Now we can see the goal tile below the crate.\n      goalTiles.push(fixedTile);\n    }\n    newRow.push(fixedTile);\n    i++;\n    column++;\n    columns = Math.max(column, columns);\n  })\n  rowIndex++;\n  map.push(newRow);\n})\n\nconst ArrayGrid = GridMixin(Array);\nlet grid = ArrayGrid.fromArrays(map); //Won't make a copy of the values, so changing things in grid will update map\nconst tileArray = map.flat();\n$: levelComplete = goalTiles.every(goalTile => goalTile.hasCrate);\n\n$: if(levelComplete) {\n  alert(\"Level Complete!\");\n  console.log(\"Level Complete!\");\n}\n\n// $: canMoveUp = canMoveInDirection(directions.up, player.position);\n\nfunction canMoveInDirection(relativeCoordinates, fromCoordinates) {\n  const params = {fromCoordinates: fromCoordinates, relativeCoordinates: relativeCoordinates};\n  params.targetCoordinates = {row: fromCoordinates.row + relativeCoordinates.row, column: fromCoordinates.column + relativeCoordinates.column};\n  params.beyondTargetCoordinates = {row: params.targetCoordinates.row + relativeCoordinates.row, column: params.targetCoordinates.column + relativeCoordinates.column};\n  if (params.targetCoordinates.row < 0 || params.targetCoordinates.column < 0) {\n    return {canMove : false, ...params}\n  } else if (params.targetCoordinates.row > grid.rows || params.targetCoordinates.column > grid.columns) {\n    return {canMove : false, ...params}\n  }\n  params.targetTile = grid.get(params.targetCoordinates.row, params.targetCoordinates.column);\n  params.beyondTargetTile = grid.get(params.beyondTargetCoordinates.row, params.beyondTargetCoordinates.column);\n  if (params.targetTile.isTraversable) {\n    return {canMove : true, ...params}\n  } else if (params.targetTile.key === crate.key && params.beyondTargetTile.isTraversable ) {\n      return {canMove : true, ...params}\n  } else {\n    return {canMove : false, ...params}\n  }\n}\nconst setPlayerReady = function() {\n  playerReady = true;\n}\nfunction TryMove(direction) {\n  if (playerReady) {\n    if (player.direction != direction) {\n      player.direction = direction;\n      player.moves++;\n      return;\n    }\n    const result = canMoveInDirection(direction, player.position);\n    if (result.canMove) {\n      // console.log(\"Moving!\")\n      player.moves++;\n      playerReady = false;\n      let animationWait = setTimeout(setPlayerReady, 250);\n      // grid.get(player.position.row, player.position.column).key = player.standingOn.floorKey;\n      if (result.targetTile.key === crate.key) {\n        const reachedGoalTile = result.beyondTargetTile.key === goal.key;\n        result.targetTile.moveEntityTo(result.beyondTargetTile);\n        if (reachedGoalTile) {\n          goalTiles = goalTiles;\n          console.log(goalTiles);\n        }\n      }\n      player.standingOn.moveEntityTo(result.targetTile);\n      player.standingOn = result.targetTile;\n      player.position = result.targetCoordinates;\n      map = map; //tells Svelte the map grid changed, since set() hides this from Svelte. Svelte would however pick up grid[index] = player.key\n    } else {\n      playerReady = false;\n      let animationWait = setTimeout(setPlayerReady, 250);\n      console.log(\"Can't go in that direction!\")\n    }\n    player.tile = player.tile;\n  } else {\n    console.log(\"Busy with animation!\");\n  }\n}\n\nfunction extraClassesFor(cell) {\n  if (goalTiles.some(function(goalPos) {\n      return goalPos.position.row === cell.position.row && goalPos.position.column === cell.position.column;\n    })) {\n      return \"goal\"\n  }\n  return \"\"\n}\n\nfunction extraStylesFor(cell) {\n  if (cell.floorKey === goal.key && cell.key != player.key) {\n    // return \"background-size: 100%; background-image: url(\" + tileTypeDict[cell.floorKey].image + \");\";\n  }\n  return \"\";\n}\nlet playerMoving = false;\nlet playerReady = true;\n// $: playerReady = !playerMoving && !levelComplete;\n// $: if (hotkeys && playerReady != null) {\n//         hotkeys.setScope(playerReady ? \"ready\" : \"waiting\");\n//       }\n\n// $: if(hotkeys && (hotkeysScope || true) { //trying to get Svelte to run the code in here whenever hotkeysScope changes, but not before hotkeys is defined.\n//     hotkeys.deleteScope(\"waiting\");\n//     hotkeys.deleteScope(\"ready\");\n//     hotkeys.setScope(hotkeysScope);\n// }\n\nconst backgroundSubareas = [];\n\nconst calculateGoalOffsets = function(onresize) {\n  for(let i=0;i<backgroundSubareas.length;i++) {\n      const {location, overlay} = backgroundSubareas[i];\n      overlay.style.setProperty(\"--offset-left\", location.offsetLeft + \"px\")\n      overlay.style.setProperty(\"--offset-top\", location.offsetTop + \"px\");\n    }\n}\n\nonMount(async () => {\n  const goalBackgroundElement = document.createElement(\"div\");\n  const goalBackgroundImage = document.createElement(\"img\");\n  goalBackgroundImage.src = tileTypeDict[goal.key].image;\n  goalBackgroundElement.appendChild(goalBackgroundImage);\n  goalBackgroundElement.classList.add(\"background-subarea\");\n  const goalElements = document.getElementsByClassName(\"goal\");\n  for(let i=0; i<goalElements.length; i++) {\n    const goalElem = goalElements[i];\n    let newElem = goalBackgroundElement;\n    if (i < goalElements.length - 1) {\n      newElem = goalBackgroundElement.cloneNode(true);\n    }\n    newElem.style.setProperty(\"--offset-left\", goalElem.offsetLeft + \"px\");\n    newElem.style.setProperty(\"--offset-top\", goalElem.offsetTop + \"px\");\n    goalElem.parentElement.insertBefore(newElem, goalElem);\n    newElem.style.setProperty(\"left\", \"var(--offset-left)\");\n    newElem.style.setProperty(\"top\", \"var(--offset-top)\");\n    backgroundSubareas.push({location: goalElem, overlay: newElem});\n  }\n  window.onresize = calculateGoalOffsets;\n  const module = await import('hotkeys-js');\n  hotkeys('left, right, up, down',  //this would break server-side rendering if outside of onMount, due to reliance on 'document'.\n  'ready', function(event, handler) {\n    switch (handler.key) {\n      /****************\n      *   Arrow keys  *\n      ****************/\n      case 'left':\n          TryMove(directions.left);\n        break;\n      case 'up':\n          TryMove(directions.up);\n        break;\n      case 'right':\n          TryMove(directions.right);\n        break;\n      case 'down':\n          TryMove(directions.down);\n        break;\n      /****************\n      * Other events  *\n      ****************/\n      }\n    return false;\n  });\n  hotkeys.setScope('ready');\n});\n\n\nfunction whizz(node, { from, to }, params) {\n  const dx = from.left - to.left;\n  const dy = from.top - to.top;\n\n  const d = Math.sqrt(dx * dx + dy * dy);\n\n  const rotation = Math.abs(dy) > 14 ? 0 : dx < 0 ? 360 : -360;\n\n  return {\n    delay: 0,\n    duration: Math.sqrt(d) * 120,\n    easing: params.easing || quintOut,\n    css: (t, u) =>\n      `transform: translate(${u * dx}px, ${u * dy}px) rotate(${t*rotation}deg);`\n  };\n}\n\nconst animations = function() {\n  const tiles = new Map(); //this is just to practice using Closures.\n  const closureBreakout = {};\n  closureBreakout.starting = function(tile) {\n    tiles.set(tile.id, true);\n    playerMoving = tile.key === player.key || playerMoving;\n  };\n  closureBreakout.ending = function(tile) {\n    tiles.delete(tile.id);\n    if (tile.key === player.key) {\n      if (!playerMoving) {\n        console.log(\"Player animation ended but we thought that they were already done with the animation.\")\n      }\n      playerMoving = false;\n    }\n  }\n  closureBreakout.canceled = function(tile) {\n    tiles.set(tile.id, false);\n    if (tile.key === player.key) {\n      if (!playerMoving) {\n        console.log(\"Player animation canceled but we thought that they were already done with the animation.\")\n      }\n      playerMoving = false;\n    }\n  }\n  return closureBreakout;\n}(); //Don't miss the ();\n\n\n</script>\n\n<style>\n\n* {\n  box-sizing: border-box;\n}\n\n#sokoban {\n  margin: 0 auto;\n  padding: 0;\n  max-width: 100%;\n}\n\n:global(.background-subarea) {\n  /* display: block */\n  position: absolute;\n  /* max-height: attr(height);\n  max-width: attr(width); */\n  height: var(--tile-height);\n  width: var(--tile-width);\n  z-index: 0;\n  /*transform: none; it took me way too long to get this idea. */\n  /*CSS transitions*/\n  transition-property: none !important;\n  /*CSS transforms*/\n  transform: none !important;\n  /*CSS animations*/\n  animation: none !important;\n  /*flex-item:*/\n  /* background-image: var(--goal-background); */\n  /* background-size: auto 100%; */\n  /* background-size: var(--tile-height) var(--tile-width) */\n  }\n  :global(.background-subarea > img) {\n    object-fit: contain;\n  }\n\n.flex-container {\n  padding: 0;\n  margin: 0 auto;\n  list-style: none;\n  display: flex;\n  flex-flow: row;\n  flex-wrap: wrap;\n  justify-content: center;\n  width: var(--width);\n  /* height: var(--height); */\n  /* line-height:30px; */\n}\ndiv.flex-item > img {\n  /* position: absolute; */\n  object-fit: cover;\n}\ndiv.flex-item {\n    margin: 0px;\n    text-align: center;\n    /* flex: 0 1 auto; */\n    flex: 0 0 var(--tile-width);\n    width: var(--tile-width);\n    height: var(--tile-width);\n    z-index: 2;\n}\n/* div.flex-item:before {\n    content:'';\n    float:left;\n    padding-top: var(--ratio);\n} */\n#gameView {\n  z-index: 0;\n  background-repeat: repeat;\n  background-size: var(--tile-width);\n  background-image: var(--floor-background);\n}\n\n</style>\n\n<!-- <svelte:window on:keyup|preventDefault={handleInput}/> -->\n<figure id=\"sokoban\" style=\"\n  --columns: {columns};\n  --rows: {rowIndex};\n  --ratio: calc(var(--columns) / var(--rows));\n  --width: calc(100vmin - 0em);\n  --tile-width: calc(var(--width) / var(--columns));\n  --goal-background: url(/{tileTypeDict[goal.key].image});\n  --floor-background: url(/{tileTypeDict[blank.key].image});\n  \">\n<div id=\"gameView\" class=\"flex-container\">\n<!--  83a0fe03-58ac-465b-a847-eee93bedb6a0 -->\n<!-- {#each {length: highest_tile_index} as tile, i} -->\n  <!-- <div class=\"flex-container\" > -->\n{#each tileArray as tile (tile.id)}\n<div class=\"flex-item {extraClassesFor(tile)}\" animate:whizz=\"{{duration: 150, easing: quintOut}}\"\n  on:animationstart={animations.starting(tile)} on:animationend={animations.ending(tile)} on:animationcancel={animations.canceled(tile)}>\n  <!-- bind:clientWidth={tileWidth} bind:clientHeight={tileHeight} -->\n  {#if tile.image && tile.key === player.key}\n    <img src=\"{player.image}\" style={extraStylesFor(tile)} alt=\"{tile.key}\"\n      id=\"player\" class=\"id-{tile.id} tile-index-{tile.index} row-{tile.position.row} column-{tile.position.column}\" />\n  {:else if tile.image}\n    <img src=\"{tile.image}\" style={extraStylesFor(tile)} alt=\"{tile.key}\"\n      class=\"id-{tile.id} tile-index-{tile.index} row-{tile.position.row} column-{tile.position.column}\" />\n  {/if}\n</div>\n{:else}\n  <div class=\"flex-container\">\n\t  <p class=\"flex-item\">No mapGrid provided!</p>\n  </div>\n{/each}\n</div>\n<figcaption class=\"text-center mx-auto\">{@html `Moves: ${player.moves}`}</figcaption>\n</figure>\n\n<!-- TODO: display correct image -->","<script context=\"module\">\n\texport async function preload({ params, query }) {\n\t\t// the `slug` parameter is available because\n\t\t// this file is called [slug].html\n\t\tconst res = await this.fetch(`levels/${params.slug}.json`);\n\t\tconst data = await res.json();\n\n\t\tif (res.status === 200) {\n\t\t\treturn { level: data };\n\t\t} else {\n\t\t\tthis.error(res.status, data.message);\n\t\t}\n\t}\n</script>\n\n<script>\n\timport Sokoban from '../../components/Sokoban.svelte';\n\texport let level;\n\tconst mapGrid = level.mapGrid;\n</script>\n\n<style>\n\t/*\n\t\tBy default, CSS is locally scoped to the component,\n\t\tand any unused styles are dead-code-eliminated.\n\t\tIn this page, Svelte can't know which elements are\n\t\tgoing to appear inside the {{{level.html}}} block,\n\t\tso we have to use the :global(...) modifier to target\n\t\tall elements inside\n\t*/\n\n\t\n\t.game_container {\n    display: grid;\n\t\t/* width: 80vmin;\n\t\theight: 80vmin; */\n\t\t/* margin-top: -16px; */\n    grid-template-areas: \"header header header\"\n    \"main main main\"\n    \"footer footer footer\";\n    grid-template-columns: 0px auto 0px;\n    grid-template-rows:0em auto 5em;\n  }\n\n  .header {\n    grid-area: header;\n  }\n  :global(#sokoban){\n    grid-area: main;\n  }\n  .footer {\n    grid-area: footer;\n  }\n\n\th3 {\n\t\tmargin: 0.5em auto;\n\t\t/* padding-bottom: 0.8em; */\n\t}\n\n</style>\n\n<svelte:head>\n\t<!-- <title>{level.name}</title> -->\n</svelte:head>\n\n<div class='game_container mx-auto'>\n\t<!-- <h3 class=\"header\">{level.name}</h3> -->\n\t<Sokoban {level} {mapGrid}/>\n\t{#if level.next != undefined}\n\t\t<div class=\"footer my-5 mx-auto\"><a rel=\"prefetch\" href=\"levels/{level.next}\"><button class=\"p-2 button\">Next Level</button></a></div>\n\t{/if}\n</div>"],"names":["_objectSpread","target","i","arguments","length","source","ownKeys","Object","keys","getOwnPropertySymbols","concat","filter","sym","getOwnPropertyDescriptor","enumerable","forEach","key","defineProperty","quintOut","t","BigInt","global","window","Number","BitField","data","this","constructor","isInitialized","initialize","isBigInt","value","Array","isArray","encode","field","offsets","masks","one","zero","mask","fields","matcher","match","getMatcher","decode","toString","isSafe","Symbol","iterator","get","name","result","current","size","selectedFields","map","entries","number","Math","log2","n","two","high","low","mid","totalSize","reduce","lastOffset","push","fieldName","fieldMask","from","e","undefined","options","columns","rows","offset","BinaryGrid","getOffset","args","defineProperties","lastPosition","seal","bucket","position","row","column","getBitPosition","index","ceil","species","Uint16Array","heapify","siftDown","isHeap","getLeftIndex","getParentIndex","siftUp","element","first","getRightIndex","pop","item","deletedItems","update","last","compare","parent","leftIndex","has","start","nextIndex","rightIndex","parentIndex","a","b","arrayLike","mapFn","thisArg","_get","heap","elements","VertexHeap","BinaryHeap","w","Base","undirected","Graph","colors","vertices","vertex","set","fill","isDFS","gray","white","black","resetColors","processing","pull","setGray","outEdges","edge","isGray","setBlack","traverse","end","isAcyclic","isNonNegative","weighted","predecessors","distances","Infinity","searchTopological","searchDijkstra","searchBellmanFord","searchUnweighted","path","unshift","lastPredecessor","isFound","isBlack","weight","getEdge","shift","distance","pad","Grid","writable","lastCoordinates","getIndex","array","withPadding","begin","Uint32Array","_this2","beginning","slice","j","arrays","grid","ArrayBuffer","getLength","popCount32","getLSBIndex","getGTEMultiple","base","nextAvailable","BitArray","record","utilities","change","masked","localRank","middle","left","right","bucketRankId","rank","ZERO_CHAR","String","fromCharCode","StringView","toChar","getCharStart","point","pattern","replacement","currentIndex","search","searchValue","fromIndex","searchShiftOr","searchNaive","wordLength","max","outer","m","m1","r","indexStart","indexEnd","sub","subarray","getCharEnd","decoder","fromCodePoint","decoded","indexOf","string","encoded","encoder","view","buffer","code","codePointAt","Uint8Array","Int8Array","TextEncoder","TextDecoder","fieldSizes","Int8","Uint8","Int16","Uint16","Int32","Uint32","Float32","Float64","BigInt64","BigUint64","Uint8ClampedArray","Int16Array","Int32Array","Float32Array","Float64Array","BigInt64Array","BigUint64Array","typedArrays","byteOffset","byteLength","lastField","schema","byteView","_this","type","littleEndian","getByteOffset","getInt8","getUint8","getInt16","getUint16","getInt32","getUint32","getFloat32","getFloat64","getBigInt64","getBigUint64","getString","getArray","setInt8","setUint8","setInt16","setUint16","setInt32","setUint32","setFloat32","setFloat64","setBigInt64","setBigUint64","setString","setArray","object","Reflect","fieldSize","TypeError","bytesPerElement","BYTES_PER_ELEMENT","DataView","isSorted","isUnique","getRange","RangeError","sort","symmetric","comparator","container","compared","score","getIntersectionScore","arr","startIndex","endIndex","unique","getUnion","toAdd","el","compareFunction","deleteCount","deletedElements","getUnique","SortedMixin","SymmetricGrid","sqrt","k","x","y","UnweightedAdjacencyList","edges","getVertexCount","setOffsets","hasEdge","isFull","setEdge","unsetEdge","nextOffset","edgeIndex","nextVertex","lastElement","copy","newSize","newOffset","empty","graph","UnweightedAdjacencyMatrix","list","addEdge","WeightedAdjacencyList","isNaN","NaN","SymmetricGridMixin","GridMixin","WeightedAdjacencyMatrix","ObjectViewClass","objectLength","setObject","arrayView","of","getters","int8","uint8","int16","uint16","int32","uint32","float32","float64","bigint64","biguint64","setters","TypedArrayView","typeGetter","le","typeSetter","dataArray","ObjectView","ctor","getView","getObject","Ctor","getTypedArray","setValue","fromString","setTypedArray","objectView","byteSize","isPrimitive","isTypedArray","TypedArrayViewMixin","DataArrayMixin","GraphMixin","Pool","RankedBitArray","RecordArray","SortedArray","WeightedAdjacencyListMixin","WeightedAdjacencyMatrixMixin","ArrayViewMixin","tile","image","extraStylesFor","id","player","extraClassesFor","animations","starting","ending","canceled","duration","easing","moves","tileArray","rowIndex","tileTypeDict","goal","blank","imageBasePath","getRandomImageIndex","tileKey","random","floor","C","W","P","whizz","node","params","to","dx","dy","top","d","rotation","abs","delay","css","u","mapGrid","level","directions","str","down","up","crate","imagePrefix","imageIndex","imageSuffix","wall","direction","maxImageIndex","standingOn","values","tileType","goalTiles","newRow","cell","cellKey","movableEntity","includes","initialLocationIndex","initialPos","fixedTile","gridLocation","initialKey","entity","moveEntityTo","destTile","alert","floorKey","isTraversable","fromArrays","flat","setPlayerReady","playerReady","TryMove","relativeCoordinates","fromCoordinates","targetCoordinates","beyondTargetCoordinates","canMove","targetTile","beyondTargetTile","setTimeout","reachedGoalTile","$$invalidate","console","log","playerMoving","backgroundSubareas","calculateGoalOffsets","onresize","location","overlay","style","setProperty","offsetLeft","offsetTop","onMount","goalBackgroundElement","document","createElement","goalBackgroundImage","src","appendChild","classList","add","goalElements","getElementsByClassName","goalElem","newElem","cloneNode","parentElement","insertBefore","import","hotkeys","event","handler","setScope","tiles","Map","closureBreakout","delete","levelComplete","every","goalTile","hasCrate","some","goalPos","next","preload","query","fetch","slug","res","json","status","error","message"],"mappings":"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"}