{
  "version": 3,
  "file": "[slug].ac212321.css",
  "sources": [
    "../../../../../../../src/components/Sokoban.svelte",
    "../../../../../../../src/routes/levels/[slug].svelte"
  ],
  "sourcesContent": [
    "<!-- <svelte:options immutable={true} /> -->\n<!-- <svelte:component class=\".container\"  this={Sokoban} /> -->\n<script>\nexport let mapGrid;\nexport let level;\nimport { onMount } from 'svelte';\nimport { quintOut } from 'svelte/easing';\nimport { crossfade } from 'svelte/transition';\nimport { flip } from 'svelte/animate';\n\nimport { GridMixin } from 'structurae';\n\nimport hotkeys from 'hotkeys-js';\n\nconst directions = {left: {row: 0, column: -1, str: 'left'}, down: {row: 1, column: 0, str: 'down'}, right: {row: 0, column: 1, str: 'right'}, up: {row: -1, column: 0, str: 'up'}};\n\nfunction getRandomImageIndex(tileKey) {\n  const max = {C: 6, W: 4, ' ': 3, P: 5};\n  const min = {C: 2, W: 1, ' ': 1, P: 0};\n  const random = Math.max(Math.floor(Math.random() * Math.floor(max[tileKey])), min[tileKey]);\n  return tileKey === 'P' ? random : ('0' + random).slice(-2);\n}\n\nconst imageBasePath = \"sokoban/images/\";\nconst crate = {key: 'C', imagePrefix: 'Crates/crate_', imageIndex: getRandomImageIndex('C'), imageSuffix: '.png'};\nconst wall = {key: 'W', imagePrefix: 'Blocks/block_', imageIndex: getRandomImageIndex('W'), imageSuffix: '.png'};\nconst blank = {key: ' ', imagePrefix: 'Ground/ground_', imageIndex: getRandomImageIndex(' '), imageSuffix: '.png'};\nconst goal = {key: 'G', imagePrefix: 'Ground/ground_', imageIndex: blank.imageIndex, imageSuffix: '_goal.png'};\nconst player = {key: 'P', get imagePrefix() { return 'Player/' + this.direction.str + '/' }, imageIndex: 0, maxImageIndex: 5, imageSuffix: '.png',\n                get image() { return imageBasePath + this.imagePrefix + (this.moves % this.maxImageIndex) + this.imageSuffix;},\n                moves: 0, position: {row: 0, column: 0}, direction: directions.down, standingOn: blank};\n\nconst tileTypeDict = {};\ntileTypeDict['C'] = crate;\ntileTypeDict['G'] = goal;\ntileTypeDict['W'] = wall;\ntileTypeDict[' '] = blank;\nObject.values(tileTypeDict).forEach(tileType => {\n  tileType.image = imageBasePath + tileType.imagePrefix + tileType.imageIndex + tileType.imageSuffix;\n})\ntileTypeDict['P'] = player;\n\nlet goalTiles = [];\nlet map = [];\nlet rowIndex = 0;\nlet columns = 0;\nlet i = 0;\nmapGrid.forEach(row => {\n  let newRow = [];\n  let column = 0;\n  row.forEach(cell => {\n    const movableEntityTypes = \"PC\";\n    const cellKey = cell === 'B' ? 'C' : cell; //Block is a confusing name for the crates, so I'm translating the 'B' from the suggested map format of this exercise into a 'C'.\n    const movableEntity = (! movableEntityTypes.includes(cellKey)) ? null : {\n      key: cellKey,\n      initialLocationIndex: i,\n      initialPos: {row: rowIndex, column: column},\n    };\n    const fixedTile = { //fixed location on the grid\n      gridLocation: i,\n      initialKey: (! movableEntityTypes.includes(cellKey)) ? cellKey : blank.key,\n      entity: movableEntity,\n      moveEntityTo(destTile) {\n        if (destTile.entity) {\n          alert(`Warning! Entity of ${destTile} replaced by entity of ${this}.`);\n        }\n        destTile.entity = this.entity;\n        this.entity = null;\n        if (this.key === player.key) {\n          player.tile = this;\n        }\n        },\n      get id() { return this.entity ? this.entity.initialLocationIndex : -this.gridLocation },\n      get key() { return this.entity ? this.entity.key : this.initialKey },\n      floorKey: blank.key, index: i, position: {row: rowIndex, column: column},\n      get image() {\n        return this.isTraversable ? \"\" : tileTypeDict[this.key].image;\n      },\n      get backgroundImage() {\n        return this.isTraversable ? tileTypeDict[this.key].image : tileTypeDict[this.floorKey].image;\n      },\n      get isTraversable() { return this.key === ' ' || this.key === 'G'},\n      get hasCrate() { return this.key === 'C' && this.floorKey === 'G'},\n    }\n    if (cellKey === player.key) {\n      player.position = fixedTile.position;\n      player.standingOn = fixedTile;\n    }\n    if (cellKey === 'G') {\n      fixedTile.floorKey = 'G'; //used for the css background-image of the tile. Now we can see the goal tile below the crate.\n      goalTiles.push(fixedTile);\n    }\n    newRow.push(fixedTile);\n    i++;\n    column++;\n    columns = Math.max(column, columns);\n  })\n  rowIndex++;\n  map.push(newRow);\n})\n\nconst ArrayGrid = GridMixin(Array);\nlet grid = ArrayGrid.fromArrays(map); //Won't make a copy of the values, so changing things in grid will update map\nconst tileArray = map.flat();\n$: levelComplete = goalTiles.every(goalTile => goalTile.hasCrate);\n\n$: if(levelComplete) {\n  alert(\"Level Complete!\");\n  console.log(\"Level Complete!\");\n}\n\n// $: canMoveUp = canMoveInDirection(directions.up, player.position);\n\nfunction canMoveInDirection(relativeCoordinates, fromCoordinates) {\n  const params = {fromCoordinates: fromCoordinates, relativeCoordinates: relativeCoordinates};\n  params.targetCoordinates = {row: fromCoordinates.row + relativeCoordinates.row, column: fromCoordinates.column + relativeCoordinates.column};\n  params.beyondTargetCoordinates = {row: params.targetCoordinates.row + relativeCoordinates.row, column: params.targetCoordinates.column + relativeCoordinates.column};\n  if (params.targetCoordinates.row < 0 || params.targetCoordinates.column < 0) {\n    return {canMove : false, ...params}\n  } else if (params.targetCoordinates.row > grid.rows || params.targetCoordinates.column > grid.columns) {\n    return {canMove : false, ...params}\n  }\n  params.targetTile = grid.get(params.targetCoordinates.row, params.targetCoordinates.column);\n  params.beyondTargetTile = grid.get(params.beyondTargetCoordinates.row, params.beyondTargetCoordinates.column);\n  if (params.targetTile.isTraversable) {\n    return {canMove : true, ...params}\n  } else if (params.targetTile.key === crate.key && params.beyondTargetTile.isTraversable ) {\n      return {canMove : true, ...params}\n  } else {\n    return {canMove : false, ...params}\n  }\n}\nconst setPlayerReady = function() {\n  playerReady = true;\n}\nfunction TryMove(direction) {\n  if (playerReady) {\n    if (player.direction != direction) {\n      player.direction = direction;\n      player.moves++;\n      return;\n    }\n    const result = canMoveInDirection(direction, player.position);\n    if (result.canMove) {\n      // console.log(\"Moving!\")\n      player.moves++;\n      playerReady = false;\n      let animationWait = setTimeout(setPlayerReady, 250);\n      // grid.get(player.position.row, player.position.column).key = player.standingOn.floorKey;\n      if (result.targetTile.key === crate.key) {\n        const reachedGoalTile = result.beyondTargetTile.key === goal.key;\n        result.targetTile.moveEntityTo(result.beyondTargetTile);\n        if (reachedGoalTile) {\n          goalTiles = goalTiles;\n          console.log(goalTiles);\n        }\n      }\n      player.standingOn.moveEntityTo(result.targetTile);\n      player.standingOn = result.targetTile;\n      player.position = result.targetCoordinates;\n      map = map; //tells Svelte the map grid changed, since set() hides this from Svelte. Svelte would however pick up grid[index] = player.key\n    } else {\n      playerReady = false;\n      let animationWait = setTimeout(setPlayerReady, 250);\n      console.log(\"Can't go in that direction!\")\n    }\n    player.tile = player.tile;\n  } else {\n    console.log(\"Busy with animation!\");\n  }\n}\n\nfunction extraClassesFor(cell) {\n  if (goalTiles.some(function(goalPos) {\n      return goalPos.position.row === cell.position.row && goalPos.position.column === cell.position.column;\n    })) {\n      return \"goal\"\n  }\n  return \"\"\n}\n\nfunction extraStylesFor(cell) {\n  if (cell.floorKey === goal.key && cell.key != player.key) {\n    // return \"background-size: 100%; background-image: url(\" + tileTypeDict[cell.floorKey].image + \");\";\n  }\n  return \"\";\n}\nlet playerMoving = false;\nlet playerReady = true;\n// $: playerReady = !playerMoving && !levelComplete;\n// $: if (hotkeys && playerReady != null) {\n//         hotkeys.setScope(playerReady ? \"ready\" : \"waiting\");\n//       }\n\n// $: if(hotkeys && (hotkeysScope || true) { //trying to get Svelte to run the code in here whenever hotkeysScope changes, but not before hotkeys is defined.\n//     hotkeys.deleteScope(\"waiting\");\n//     hotkeys.deleteScope(\"ready\");\n//     hotkeys.setScope(hotkeysScope);\n// }\n\nconst backgroundSubareas = [];\n\nconst calculateGoalOffsets = function(onresize) {\n  for(let i=0;i<backgroundSubareas.length;i++) {\n      const {location, overlay} = backgroundSubareas[i];\n      overlay.style.setProperty(\"--offset-left\", location.offsetLeft + \"px\")\n      overlay.style.setProperty(\"--offset-top\", location.offsetTop + \"px\");\n    }\n}\n\nonMount(async () => {\n  const goalBackgroundElement = document.createElement(\"div\");\n  const goalBackgroundImage = document.createElement(\"img\");\n  goalBackgroundImage.src = tileTypeDict[goal.key].image;\n  goalBackgroundElement.appendChild(goalBackgroundImage);\n  goalBackgroundElement.classList.add(\"background-subarea\");\n  const goalElements = document.getElementsByClassName(\"goal\");\n  for(let i=0; i<goalElements.length; i++) {\n    const goalElem = goalElements[i];\n    let newElem = goalBackgroundElement;\n    if (i < goalElements.length - 1) {\n      newElem = goalBackgroundElement.cloneNode(true);\n    }\n    newElem.style.setProperty(\"--offset-left\", goalElem.offsetLeft + \"px\");\n    newElem.style.setProperty(\"--offset-top\", goalElem.offsetTop + \"px\");\n    goalElem.parentElement.insertBefore(newElem, goalElem);\n    newElem.style.setProperty(\"left\", \"var(--offset-left)\");\n    newElem.style.setProperty(\"top\", \"var(--offset-top)\");\n    backgroundSubareas.push({location: goalElem, overlay: newElem});\n  }\n  window.onresize = calculateGoalOffsets;\n  const module = await import('hotkeys-js');\n  hotkeys('left, right, up, down',  //this would break server-side rendering if outside of onMount, due to reliance on 'document'.\n  'ready', function(event, handler) {\n    switch (handler.key) {\n      /****************\n      *   Arrow keys  *\n      ****************/\n      case 'left':\n          TryMove(directions.left);\n        break;\n      case 'up':\n          TryMove(directions.up);\n        break;\n      case 'right':\n          TryMove(directions.right);\n        break;\n      case 'down':\n          TryMove(directions.down);\n        break;\n      /****************\n      * Other events  *\n      ****************/\n      }\n    return false;\n  });\n  hotkeys.setScope('ready');\n});\n\n\nfunction whizz(node, { from, to }, params) {\n  const dx = from.left - to.left;\n  const dy = from.top - to.top;\n\n  const d = Math.sqrt(dx * dx + dy * dy);\n\n  const rotation = Math.abs(dy) > 14 ? 0 : dx < 0 ? 360 : -360;\n\n  return {\n    delay: 0,\n    duration: Math.sqrt(d) * 120,\n    easing: params.easing || quintOut,\n    css: (t, u) =>\n      `transform: translate(${u * dx}px, ${u * dy}px) rotate(${t*rotation}deg);`\n  };\n}\n\nconst animations = function() {\n  const tiles = new Map(); //this is just to practice using Closures.\n  const closureBreakout = {};\n  closureBreakout.starting = function(tile) {\n    tiles.set(tile.id, true);\n    playerMoving = tile.key === player.key || playerMoving;\n  };\n  closureBreakout.ending = function(tile) {\n    tiles.delete(tile.id);\n    if (tile.key === player.key) {\n      if (!playerMoving) {\n        console.log(\"Player animation ended but we thought that they were already done with the animation.\")\n      }\n      playerMoving = false;\n    }\n  }\n  closureBreakout.canceled = function(tile) {\n    tiles.set(tile.id, false);\n    if (tile.key === player.key) {\n      if (!playerMoving) {\n        console.log(\"Player animation canceled but we thought that they were already done with the animation.\")\n      }\n      playerMoving = false;\n    }\n  }\n  return closureBreakout;\n}(); //Don't miss the ();\n\n\n</script>\n\n<style>\n\n* {\n  box-sizing: border-box;\n}\n\n#sokoban {\n  margin: 0 auto;\n  padding: 0;\n  max-width: 100%;\n}\n\n:global(.background-subarea) {\n  /* display: block */\n  position: absolute;\n  /* max-height: attr(height);\n  max-width: attr(width); */\n  height: var(--tile-height);\n  width: var(--tile-width);\n  z-index: 0;\n  /*transform: none; it took me way too long to get this idea. */\n  /*CSS transitions*/\n  transition-property: none !important;\n  /*CSS transforms*/\n  transform: none !important;\n  /*CSS animations*/\n  animation: none !important;\n  /*flex-item:*/\n  /* background-image: var(--goal-background); */\n  /* background-size: auto 100%; */\n  /* background-size: var(--tile-height) var(--tile-width) */\n  }\n  :global(.background-subarea > img) {\n    object-fit: contain;\n  }\n\n.flex-container {\n  padding: 0;\n  margin: 0 auto;\n  list-style: none;\n  display: flex;\n  flex-flow: row;\n  flex-wrap: wrap;\n  justify-content: center;\n  width: var(--width);\n  /* height: var(--height); */\n  /* line-height:30px; */\n}\ndiv.flex-item > img {\n  /* position: absolute; */\n  object-fit: cover;\n}\ndiv.flex-item {\n    margin: 0px;\n    text-align: center;\n    /* flex: 0 1 auto; */\n    flex: 0 0 var(--tile-width);\n    width: var(--tile-width);\n    height: var(--tile-width);\n    z-index: 2;\n}\n/* div.flex-item:before {\n    content:'';\n    float:left;\n    padding-top: var(--ratio);\n} */\n#gameView {\n  z-index: 0;\n  background-repeat: repeat;\n  background-size: var(--tile-width);\n  background-image: var(--floor-background);\n}\n\n</style>\n\n<!-- <svelte:window on:keyup|preventDefault={handleInput}/> -->\n<figure id=\"sokoban\" style=\"\n  --columns: {columns};\n  --rows: {rowIndex};\n  --ratio: calc(var(--columns) / var(--rows));\n  --width: calc(100vmin - 0em);\n  --tile-width: calc(var(--width) / var(--columns));\n  --goal-background: url(/{tileTypeDict[goal.key].image});\n  --floor-background: url(/{tileTypeDict[blank.key].image});\n  \">\n<div id=\"gameView\" class=\"flex-container\">\n<!-- â˜ž 83a0fe03-58ac-465b-a847-eee93bedb6a0 -->\n<!-- {#each {length: highest_tile_index} as tile, i} -->\n  <!-- <div class=\"flex-container\" > -->\n{#each tileArray as tile (tile.id)}\n<div class=\"flex-item {extraClassesFor(tile)}\" animate:whizz=\"{{duration: 150, easing: quintOut}}\"\n  on:animationstart={animations.starting(tile)} on:animationend={animations.ending(tile)} on:animationcancel={animations.canceled(tile)}>\n  <!-- bind:clientWidth={tileWidth} bind:clientHeight={tileHeight} -->\n  {#if tile.image && tile.key === player.key}\n    <img src=\"{player.image}\" style={extraStylesFor(tile)} alt=\"{tile.key}\"\n      id=\"player\" class=\"id-{tile.id} tile-index-{tile.index} row-{tile.position.row} column-{tile.position.column}\" />\n  {:else if tile.image}\n    <img src=\"{tile.image}\" style={extraStylesFor(tile)} alt=\"{tile.key}\"\n      class=\"id-{tile.id} tile-index-{tile.index} row-{tile.position.row} column-{tile.position.column}\" />\n  {/if}\n</div>\n{:else}\n  <div class=\"flex-container\">\n\t  <p class=\"flex-item\">No mapGrid provided!</p>\n  </div>\n{/each}\n</div>\n<figcaption class=\"text-center mx-auto\">{@html `Moves: ${player.moves}`}</figcaption>\n</figure>\n\n<!-- TODO: display correct image -->",
    "<script context=\"module\">\n\texport async function preload({ params, query }) {\n\t\t// the `slug` parameter is available because\n\t\t// this file is called [slug].html\n\t\tconst res = await this.fetch(`levels/${params.slug}.json`);\n\t\tconst data = await res.json();\n\n\t\tif (res.status === 200) {\n\t\t\treturn { level: data };\n\t\t} else {\n\t\t\tthis.error(res.status, data.message);\n\t\t}\n\t}\n</script>\n\n<script>\n\timport Sokoban from '../../components/Sokoban.svelte';\n\texport let level;\n\tconst mapGrid = level.mapGrid;\n</script>\n\n<style>\n\t/*\n\t\tBy default, CSS is locally scoped to the component,\n\t\tand any unused styles are dead-code-eliminated.\n\t\tIn this page, Svelte can't know which elements are\n\t\tgoing to appear inside the {{{level.html}}} block,\n\t\tso we have to use the :global(...) modifier to target\n\t\tall elements inside\n\t*/\n\n\t\n\t.game_container {\n    display: grid;\n\t\t/* width: 80vmin;\n\t\theight: 80vmin; */\n\t\t/* margin-top: -16px; */\n    grid-template-areas: \"header header header\"\n    \"main main main\"\n    \"footer footer footer\";\n    grid-template-columns: 0px auto 0px;\n    grid-template-rows:0em auto 5em;\n  }\n\n  .header {\n    grid-area: header;\n  }\n  :global(#sokoban){\n    grid-area: main;\n  }\n  .footer {\n    grid-area: footer;\n  }\n\n\th3 {\n\t\tmargin: 0.5em auto;\n\t\t/* padding-bottom: 0.8em; */\n\t}\n\n</style>\n\n<svelte:head>\n\t<!-- <title>{level.name}</title> -->\n</svelte:head>\n\n<div class='game_container mx-auto'>\n\t<!-- <h3 class=\"header\">{level.name}</h3> -->\n\t<Sokoban {level} {mapGrid}/>\n\t{#if level.next != undefined}\n\t\t<div class=\"footer my-5 mx-auto\"><a rel=\"prefetch\" href=\"levels/{level.next}\"><button class=\"p-2 button\">Next Level</button></a></div>\n\t{/if}\n</div>"
  ],
  "names": [],
  "mappings": "AAsTA,cAAE,CAAC,AACD,UAAU,CAAE,UAAU,AACxB,CAAC,AAED,QAAQ,cAAC,CAAC,AACR,MAAM,CAAE,CAAC,CAAC,IAAI,CACd,OAAO,CAAE,CAAC,CACV,SAAS,CAAE,IAAI,AACjB,CAAC,AAEO,mBAAmB,AAAE,CAAC,AAE5B,QAAQ,CAAE,QAAQ,CAGlB,MAAM,CAAE,IAAI,aAAa,CAAC,CAC1B,KAAK,CAAE,IAAI,YAAY,CAAC,CACxB,OAAO,CAAE,CAAC,CAGV,mBAAmB,CAAE,IAAI,CAAC,UAAU,CAEpC,SAAS,CAAE,IAAI,CAAC,UAAU,CAE1B,SAAS,CAAE,IAAI,CAAC,UAAU,AAK1B,CAAC,AACO,yBAAyB,AAAE,CAAC,AAClC,UAAU,CAAE,OAAO,AACrB,CAAC,AAEH,eAAe,cAAC,CAAC,AACf,OAAO,CAAE,CAAC,CACV,MAAM,CAAE,CAAC,CAAC,IAAI,CACd,UAAU,CAAE,IAAI,CAChB,OAAO,CAAE,IAAI,CACb,SAAS,CAAE,GAAG,CACd,SAAS,CAAE,IAAI,CACf,eAAe,CAAE,MAAM,CACvB,KAAK,CAAE,IAAI,OAAO,CAAC,AAGrB,CAAC,AACD,GAAG,wBAAU,CAAG,GAAG,cAAC,CAAC,AAEnB,UAAU,CAAE,KAAK,AACnB,CAAC,AACD,GAAG,UAAU,cAAC,CAAC,AACX,MAAM,CAAE,GAAG,CACX,UAAU,CAAE,MAAM,CAElB,IAAI,CAAE,CAAC,CAAC,CAAC,CAAC,IAAI,YAAY,CAAC,CAC3B,KAAK,CAAE,IAAI,YAAY,CAAC,CACxB,MAAM,CAAE,IAAI,YAAY,CAAC,CACzB,OAAO,CAAE,CAAC,AACd,CAAC,AAMD,SAAS,cAAC,CAAC,AACT,OAAO,CAAE,CAAC,CACV,iBAAiB,CAAE,MAAM,CACzB,eAAe,CAAE,IAAI,YAAY,CAAC,CAClC,gBAAgB,CAAE,IAAI,kBAAkB,CAAC,AAC3C,CAAC;AC3VA,eAAe,cAAC,CAAC,AACd,OAAO,CAAE,IAAI,CAIb,mBAAmB,CAAE,sBAAsB;IAC3C,gBAAgB;IAChB,sBAAsB,CACtB,qBAAqB,CAAE,GAAG,CAAC,IAAI,CAAC,GAAG,CACnC,mBAAmB,GAAG,CAAC,IAAI,CAAC,GAAG,AACjC,CAAC,AAKO,QAAQ,AAAC,CAAC,AAChB,SAAS,CAAE,IAAI,AACjB,CAAC,AACD,OAAO,cAAC,CAAC,AACP,SAAS,CAAE,MAAM,AACnB,CAAC"
}