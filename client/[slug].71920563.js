import{S as t,i as e,s,e as i,a as r,c as n,b as o,f as a,d as h,g as l,C as c,h as u,j as g,D as f,E as d,F as y,G as p,H as m,t as v,n as b,I as w,J as k,K as x,m as I,p as A,q as E,r as U}from"./chunk.631cd46d.js";import C from"./hotkeys.esm.416ead1c.js";function O(t){return--t*t*t*t*t+1}const B=(("undefined"!=typeof globalThis?globalThis:"undefined"!=typeof window?window:"undefined"!=typeof global?global:"undefined"!=typeof self?self:{})||window).BigInt||Number,S=2147483647,T=31,P=53,L=281474976710656;class j{constructor(t=0){const{isInitialized:e}=this.constructor;e||this.constructor.initialize();const{isBigInt:s}=this.constructor,i=Array.isArray(t)?this.constructor.encode(t):t;this.value=s?B(i):i}get(t){const{offsets:e,masks:s}=this.constructor,i=this.value>>e[t]&s[t];return Number(i)}set(t,e=this.constructor.one){const{offsets:s,masks:i,isBigInt:r}=this.constructor;return r&&(e=B(e)),this.value=this.value&~(i[t]<<s[t])|e<<s[t],this}has(...t){const{offsets:e,zero:s,one:i}=this.constructor;let r=s;for(let s=0;s<t.length;s++)r|=i<<e[t[s]];return r|=this.value,this.value===r}match(t){return this.constructor.match(this.value,Array.isArray(t)?t:this.constructor.getMatcher(t))}toObject(){return this.constructor.decode(this.value)}toString(){return this.value.toString()}valueOf(){const{isBigInt:t,isSafe:e}=this.constructor;return t&&e?Number(this.value):this.value}static encode(t){const{zero:e,fields:s,isBigInt:i}=this;let r=e;for(let e=t.length-1;e>=0;e--){const n=t[e];r<<=s[e].size,r|=i?B(n):n}return r}static decode(t){const{fields:e,masks:s}=this,i={};let r=t;for(let t=0;t<e.length;t++){const{name:n,size:o}=e[t];i[n]=Number(r&s[n]),r>>=o}return i}static isValid(t){const{masks:e,fields:s}=this,i=Array.isArray(t)?s.map((e,s)=>[e.name,t[s]]):Object.entries(t);for(let t=0;t<i.length;t++){const[s,r]=i[t];if((r&S)!==r||r>e[s])return!1}return!0}static getMinSize(t){if(t<L)return 1+(0|Math.log2(t));const e=B(t),[s,i,r]=[B(0),B(1),B(2)];let n=B(P),o=B(48);for(;n-o>i;){const t=(n+o)/r;((i<<n)-(i<<t)&e)>s?o=t:n=t}return Number(o+i)}static initialize(){const t=this.fields.reduce((t,e)=>t+=e.size||1,0),e=t>T,[s,i,r]=e?[B(0),B(1),B(2)]:[0,1,2],n=[],o={},a={};let h=s;for(let t=0;t<this.fields.length;t++){const s=this.fields[t],l=s.name||s,c=e?B(s.size||1):s.size||1;o[l]=(r<<c-i)-i,a[l]=h,h+=c,n.push({name:l,size:c})}this.fields=n,this.size=t,this.mask=r<<(e?B(t):t)-i,this.isBigInt=e,this.isSafe=t<=P,this.zero=s,this.one=i,this.two=r,this.masks=o,this.offsets=a,this.isInitialized=!0}static getMatcher(t){const{masks:e,offsets:s,zero:i,isBigInt:r}=this,n=Object.keys(t);let o=i,a=i;for(let i=0;i<n.length;i++){const h=n[i],l=e[h]<<s[h],c=r?B(t[h]):t[h];a=a&~l|c<<s[h],o|=l}return[a,this.mask^o]}static match(t,e){return(t&e[1])===e[0]}*[Symbol.iterator](){const{fields:t}=this.constructor;for(let e=0;e<t.length;e++)yield this.get(t[e].name)}}j.fields=Array.from({length:T},(t,e)=>e),j.size=T,j.zero=0,j.one=1,j.two=2,j.masks=void 0,j.mask=2147483648,j.offsets=void 0,j.isBigInt=!1,j.isSafe=!1,j.isInitialized=!1;var z=j;class G extends Uint16Array{constructor(t={},...e){const{columns:s=16,rows:i=1}=t,r=G.getOffset(s);if(e.length)super(...e);else{super(i<<r>>4||1)}Object.defineProperties(this,{offset:{value:r},columns:{value:s},rows:{value:i},lastPosition:{value:Object.seal({bucket:0,position:0})}})}get(t,e){const{bucket:s,position:i}=this.getBitPosition(t,e);return this[s]>>i&1}set(t,e,s=1){if(t.length)return super.set(t,e),this;const{bucket:i,position:r}=this.getBitPosition(t,e);return this[i]=this[i]&~(1<<r)|s<<r,this}getBitPosition(t,e){const s=(t<<this.offset)+e,i=s>>4;return this.lastPosition.bucket=i,this.lastPosition.position=s-(i<<4),this.lastPosition}static get[Symbol.species](){return Uint16Array}static getLength(t,e){return t<<this.getOffset(e)>>4}static getOffset(t){return Math.ceil(Math.log2(t))}}var M=G;var F=class extends Array{constructor(...t){super(...t),this.heapify()}heapify(){for(let t=this.length>>1;t>=0;t--)this.siftDown(t);return this}isHeap(){return this.constructor.isHeap(this)}left(t){return this[this.constructor.getLeftIndex(t)]}parent(t){return this[this.constructor.getParentIndex(t)]}push(...t){for(let e=0;e<t.length;e++)super.push(t[e]),this.siftUp(this.length-1);return this.length}replace(t){const e=this[0];return this[0]=t,this.siftDown(0),e}right(t){return this[this.constructor.getRightIndex(t)]}shift(){if(this.length<2)return this.pop();const t=this[0];return this[0]=this.pop(),this.siftDown(0),t}splice(...t){const e=super.splice(...t);if(e.length<2&&t.length<4){const e=t[0];if(3===t.length)this.update(e);else{const t=this.pop();super.splice(e,0,t),this.siftDown(e)}}else this.heapify();return e}unshift(...t){return this.push(...t)}update(t){const{compare:e,getLeftIndex:s}=this.constructor,i=this.parent(t),r=s(t);this.has(r)&&(void 0===i||e(i,this[t]))?this.siftDown(t):this.siftUp(t)}has(t){return t>=0&&t<this.length}siftDown(t){const{getRightIndex:e,getLeftIndex:s,compare:i}=this.constructor;let r,n=t,o=s(n),a=e(n);for(;this.has(o)&&(r=this.has(a)&&i(this[a],this[o])?a:o,!i(this[n],this[r]));)[this[n],this[r]]=[this[r],this[n]],o=s(n=r),a=e(n)}siftUp(t){const{getParentIndex:e,compare:s}=this.constructor;let i=t,r=e(i);for(;this.has(r)&&!s(this[r],this[i]);)[this[i],this[r]]=[this[r],this[i]],r=e(i=r)}static get[Symbol.species](){return Array}static compare(t,e){return t<e}static from(t,e,s){return super.from(t,e,s).heapify()}static getLeftIndex(t){return 1+(t<<1)}static getParentIndex(t){return t-1>>1}static getRightIndex(t){return 2+(t<<1)}static isHeap(t){for(let e=t.length-1;e>-1;e--){const s=this.getParentIndex(e);if(s<0)break;if(!this.compare(t[s],t[e]))return!1}return!0}static of(...t){return super.of(...t).heapify()}};class D extends F{static compare(t,e){return t.w<e.w}}var V=function(t,e=!1){class s extends t{constructor(t,...e){super(t,...e);const s=new M({rows:2,columns:t.vertices});Object.defineProperties(this,{colors:{value:s}})}isGray(t){return!!this.colors.get(0,t)}setGray(t){return this.colors.set(0,t),this}isBlack(t){return!!this.colors.get(1,t)}setBlack(t){return this.colors.set(1,t),this}resetColors(){return this.colors.fill(0),this}*traverse(t,e=0,s=!0,i,r){this.resetColors();const n=[e],[o,a]=t?["push","pop"]:["push","shift"];for(;n.length;){const t=n[a]();this.setGray(t),s&&(yield t);for(const e of this.outEdges(t))this.isGray(e)||n[o](e),i&&(yield e);this.setBlack(t),r&&(yield t)}}isAcyclic(){for(const t of this.traverse(!0,0,!1,!0))if(this.isGray(t))return!1;return!0}topologicalSort(){return[...this.traverse(!0,0,!1,!1,!0)]}path(t,e,s,i){const{weighted:r}=this.constructor,{vertices:n}=this,o=new Array(n).fill(-1),a=new Array(n).fill(1/0);if(!(r?s?this.searchTopological(t,e,a,o):i?this.searchDijkstra(t,e,a,o):this.searchBellmanFord(t,e,a,o):this.searchUnweighted(t,e,o)))return[];const h=[];let l=e;for(;~l;)h.unshift(l),l=o[l];return h}searchUnweighted(t,e,s){let i=t,r=!1;for(const n of this.traverse(!1,t,!0,!0))if(this.isGray(n)?i=n:s[n]=i,n===e){r=!0;break}return r}searchTopological(t,e,s,i){s[t]=0;let r=t,n=!1;for(const o of this.traverse(!0,t,!0,!0)){if(this.isGray(o))this.isBlack(o)||(r=o);else{const t=this.getEdge(r,o);s[o]>s[r]+t&&(s[o]=s[r]+t,i[o]=r)}o===e&&(n=!0)}return n}searchDijkstra(t,e,s,i){this.resetColors();const r=new D;s[t]=0,r.push({e:t,w:this[t]});let n=!1;for(;r.length;){const t=r.shift();if(!this.isGray(t.e)){this.setGray(t.e);for(const o of this.outEdges(t.e)){const a=this.getEdge(t.e,o),h=s[t.e]+a;h<s[o]&&(s[o]=h,i[o]=t.e,r.push({e:o,w:h})),o===e&&(n=!0)}}}return n}searchBellmanFord(t,e,s,i){const{vertices:r}=this;s[t]=0;let n=!1;for(let t=0;t<r;t++)for(const r of this.outEdges(t)){const o=this.getEdge(t,r),a=s[t]+o;s[r]>a&&(s[r]=a,i[r]=t,r===e&&(n=!0))}return n}tree(t=0){const{weighted:e}=this.constructor,{vertices:s}=this,i=new Array(s).fill(-1);if(!e)return this.searchUnweighted(t,void 0,i),i;this.resetColors();const r=new Array(s).fill(1/0),n=new D;for(r[t]=0,n.push({e:t,w:this[0]});n.length;){const t=n.shift();if(!this.isGray(t.e)){this.setGray(t.e);for(const e of this.outEdges(t.e)){const s=this.getEdge(t.e,e);this.isGray(e)||s>r[e]||(r[e]=s,i[e]=t.e,n.push({e:e,w:s}))}}}return i}}return s.undirected=e,s};var N=function(t){class e extends t{constructor(t={},...s){const{columns:i=2,rows:r=1,pad:n=0}=t,o=e.getOffset(i);s.length?super(...s):(super(r<<o),this.fill(n)),Object.defineProperties(this,{offset:{value:o,writable:!0},pad:{value:n,writable:!0},lastCoordinates:{value:Object.seal({row:0,column:0})}})}set columns(t){this.offset=e.getOffset(t)}get columns(){return 1<<this.offset}get rows(){return this.length>>this.offset}getIndex(t,e){return(t<<this.offset)+e}get(t,e){return this[this.getIndex(t,e)]}set(t,e,s){return t.length&&super.set?(super.set(t,e),this):(this[this.getIndex(t,e)]=s,this)}setArray(t,e){if(super.set)super.set(t,e);else{this.length=t.length;for(let e=0;e<t.length;e++)this[e]=t[e]}}getCoordinates(t){return this.lastCoordinates.row=t>>this.offset,this.lastCoordinates.column=t-(this.lastCoordinates.row<<this.offset),this.lastCoordinates}toArrays(t){const{rows:e,columns:s}=this,i=new Uint32Array(e).map((t,e)=>e<<this.offset),r=new Array(e);for(let n=0;n<e;n++){const e=i[n];if(t)r[n]=this.slice(e,e+s);else for(let t=e+s-1;t>=e;t--)if(this[t]!==this.pad){r[n]=this.slice(e,t+1);break}}return r}static get[Symbol.species](){return t}static getLength(t,e){return t<<this.getOffset(e)}static getOffset(t){return Math.ceil(Math.log2(t))}static fromArrays(t,e=0){const s=t.length;let i=t[0].length;for(let e=0;e<s;e++)t[e].length>i&&(i=t[e].length);const r=new this({rows:s,columns:i=1<<this.getOffset(i),pad:e});for(let e=0;e<s;e++)for(let s=0;s<t[e].length;s++)r.set(e,s,t[e][s]);return r}}return e};var $=class extends Uint32Array{constructor(t=32,...e){t.length||t instanceof ArrayBuffer?super(t,...e):super(new.target.getLength(t)),Object.defineProperties(this,{lastPosition:{value:Object.seal({bucket:0,position:0})}})}getBit(t){const{bucket:e,position:s}=this.getBitPosition(t);return this[e]>>s&1}setBit(t,e=1){const{bucket:s,position:i}=this.getBitPosition(t);return this[s]=this[s]&~(1<<i)|e<<i,this}get size(){return this.length<<5}getBitPosition(t){const e=t>>5;return this.lastPosition.bucket=e,this.lastPosition.position=t-(e<<5),this.lastPosition}static getLength(t){return Math.ceil(t/32)}static get[Symbol.species](){return Uint32Array}};const q={1:0,2:1,4:2,8:3,16:4,32:5,64:6,128:7,256:8,512:9,1024:10,2048:11,4096:12,8192:13,16384:14,32768:15,65536:16,131072:17,262144:18,524288:19,1048576:20,2097152:21,4194304:22,8388608:23,16777216:24,33554432:25,67108864:26,134217728:27,268435456:28,536870912:29,1073741824:30,2147483648:31};var R={log2:q,popCount32:function(t){const e=t-(t>>1&1431655765),s=(858993459&e)+(e>>2&858993459);return 16843009*(s+(s>>4)&252645135)>>24},getLSBIndex:function(t){return 2147483648===t?31:q[t&-t]},getGTEMultiple:function(t,e){return 1+(t-1|e-1)}};var K=class extends ${constructor(t){super(t),this.fill(4294967295),Object.defineProperties(this,{nextAvailable:{value:0,writable:!0}})}get(){const{nextAvailable:t}=this;if(!~t)return-1;const e=this[t],s=R.getLSBIndex(e);if(this[t]&=~(1<<s),0===this[t]){this.nextAvailable=-1;for(let t=0;t<this.length;t++)if(0!==this[t]){this.nextAvailable=t;break}}return(t<<5)+s}free(t){const{bucket:e,position:s}=this.getBitPosition(t);this[e]|=1<<s,this.nextAvailable=e}};var W=class extends ${setBit(t,e=1){super.setBit(t,e);const s=e||-1;for(let t=(this.length>>1)+this.lastPosition.bucket;t<this.length;t++)this[t]+=s;return this}get size(){return this.length>>1<<5}rank(t){const{bucket:e,position:s}=this.getBitPosition(t),i=this[e]&(1<<s)-1,r=R.popCount32(i);return(e?this[(this.length>>1)+e-1]:0)+r}select(t){const e=this.length>>1;let s=e,i=this.length-1,r=0;for(;s<=i;)if(t>this[r=i+s>>1])s=r+1;else if(t<this[r])i=r-1;else{if(t!==this[r-1])break;i=r-1}if((r=t===this[r]?r:s)>=this.length)return-1;let n=r>e?this[r-1]:0;const o=r-e;let a=this[o];for(;a;){const e=R.getLSBIndex(a);if(a&=a-1,++n===t)return(o<<5)+e}}static getLength(t){return Math.ceil(t/32)<<1}};const _=String.fromCharCode(0);class H extends Uint8Array{*characters(){for(let t=0;t<this.length;t++)this[t]>>6!=2&&(yield this.toChar(t))}charAt(t=0){return this.toChar(this.getCharStart(t))}getCharEnd(t){const e=this[t];if(e<128)return t;switch((240&e)>>4){case 15:return t+3;case 14:return t+2;case 13:case 12:return t+1;default:return-1}}getCharStart(t,e=-1,s=0){let i=e;for(let e=s;e<this.length;e++)if(this[e]>>6!=2&&i++,i===t)return e;return-1}replace(t,e){let s=0;for(;s<this.length;){const i=this.search(t,s);if(!~i)break;this.set(e,i),s=i+e.length}return this}reverse(){for(let t=0,e=this.length-1;t<e;t++,e--)[this[t],this[e]]=[this[e],this[t]];let t=this.length;for(;--t>0;)switch((240&this[t])>>4){case 15:[this[t],this[t-3]]=[this[t-3],this[t]],[this[t-1],this[t-2]]=[this[t-2],this[t-1]],t-=3;break;case 14:[this[t],this[t-2]]=[this[t-2],this[t]],t-=2;break;case 12:case 13:[this[t],this[t-1]]=[this[t-1],this[t]],t--}return this}search(t,e=0){return this.length>256&&t.length<32?this.searchShiftOr(t,e):this.searchNaive(t,e)}searchNaive(t,e){const s=t.length,i=this.length-s;t:for(let r=e;r<=i;r++){for(let e=0;e<s;e++)if(this[r+e]!==t[e])continue t;return r}return-1}searchShiftOr(t,e){const{masks:s}=this.constructor,i=t.length,r=1<<i;s.fill(-1);let n=-2;for(let e=0;e<i;e++)s[t[e]]&=~(1<<e);for(let t=e;t<this.length;t++)if(n|=s[this[t]],0==((n<<=1)&r))return t-i+1;return-1}get size(){let t=0;for(let e=0;e<this.length;e++)this[e]>>6!=2&&t++;return t}substring(t,e=this.size){const s=this.getCharStart(t),i=this.getCharStart(e,t,s),r=this.subarray(s,this.getCharEnd(i)+1);return this.constructor.decoder.decode(r)}toChar(t){const e=this[t];if(e<128)return String.fromCodePoint(e);switch((240&e)>>4){case 15:return String.fromCodePoint((7&e)<<18|(63&this[t+1])<<12|(63&this[t+2])<<6|63&this[t+3]);case 14:return String.fromCodePoint((15&e)<<12|(63&this[t+1])<<6|63&this[t+2]);case 13:case 12:return String.fromCodePoint((31&e)<<6|63&this[t+1]);default:return""}}toString(){const t=this.constructor.decoder.decode(this),e=t.indexOf(_);return~e?t.slice(0,e):t}trim(){const t=this.indexOf(0);return~t?this.subarray(0,t):this}static fromString(t,e){const s=this.encoder.encode(t);if(e){const t=new this(e);return t.set(s),t}return new this(s.buffer)}static getByteSize(t){let e=0;for(let s=0;s<t.length;s++){const i=t.codePointAt(s);i<128?e+=1:i<2048?e+=2:i<65536?e+=3:(e+=4,s++)}return e}}H.masks=new Int8Array(256).fill(-1),H.encoder=new TextEncoder,H.decoder=new TextDecoder;var J=H;const Y={Int8:1,Uint8:1,Int16:2,Uint16:2,Int32:4,Uint32:4,Float32:4,Float64:8,BigInt64:8,BigUint64:8,String:0,Int8Array:0,Uint8Array:0,Uint8ClampedArray:0,Int16Array:0,Uint16Array:0,Int32Array:0,Uint32Array:0,Float32Array:0,Float64Array:0,BigInt64Array:0,BigUint64Array:0},Q={Int8Array:Int8Array,Uint8Array:Uint8Array,Uint8ClampedArray:Uint8ClampedArray,Int16Array:Int16Array,Uint16Array:Uint16Array,Int32Array:Int32Array,Uint32Array:Uint32Array,Float32Array:Float32Array,Float64Array:Float64Array,BigInt64Array:BigInt64Array,BigUint64Array:BigUint64Array};var X=class extends DataView{constructor(t,e=1,s,i,r){const n=t[t.length-1];n.end||new.target.initialize(t);const o=n.end,a=Math.ceil(Math.log2(o));super(s||new ArrayBuffer(e<<a),i,r);const h={};for(let e=0;e<t.length;e++)h[t[e].name]=t[e];Object.defineProperties(this,{fields:{value:t},offset:{value:a},schema:{value:h},byteView:{value:new J(this.buffer,this.byteOffset,this.byteLength)}})}get(t,e){const{type:s,size:i,littleEndian:r}=this.schema[e],n=this.getByteOffset(t,e);switch(s){case"Int8":return this.getInt8(n);case"Uint8":return this.getUint8(n);case"Int16":return this.getInt16(n,r);case"Uint16":return this.getUint16(n,r);case"Int32":return this.getInt32(n,r);case"Uint32":return this.getUint32(n,r);case"Float32":return this.getFloat32(n,r);case"Float64":return this.getFloat64(n,r);case"BigInt64":return this.getBigInt64(n,r);case"BigUint64":return this.getBigUint64(n,r);case"String":return this.getString(n,i);default:return this.getArray(n,i,s)}}getArray(t,e,s){return new Q[s](this.buffer,this.byteOffset+t,e)}getString(t,e){return this.byteView.subarray(t,t+e)}set(t,e,s){const{type:i,littleEndian:r,size:n}=this.schema[e],o=this.getByteOffset(t,e);switch(i){case"Int8":this.setInt8(o,s);break;case"Uint8":this.setUint8(o,s);break;case"Int16":this.setInt16(o,s,r);break;case"Uint16":this.setUint16(o,s,r);break;case"Int32":this.setInt32(o,s,r);break;case"Uint32":this.setUint32(o,s,r);break;case"Float32":this.setFloat32(o,s,r);break;case"Float64":this.setFloat64(o,s,r);break;case"BigInt64":this.setBigInt64(o,s,r);break;case"BigUint64":this.setBigUint64(o,s,r);break;case"String":this.setString(o,s,n);break;default:this.setArray(o,s,n,i)}return this}setArray(t,e,s,i){const r=new Q[i](this.buffer,this.byteOffset+t,s);return e.length<r.length&&r.fill(0),r.set(e),this}setString(t,e,s){e.length===s?this.byteView.set(e,t):this.byteView.subarray(t,t+s).fill(0).set(e)}get size(){return this.buffer.byteLength>>this.offset}getByteOffset(t,e){return(t<<this.offset)+this.schema[e].start}toObject(t){const{fields:e}=this,s={};for(let i=0;i<e.length;i++){const{name:r}=e[i];s[r]=this.get(t,r)}return s}fromObject(t,e){const{fields:s}=this;for(let i=0;i<s.length;i++){const{name:r}=s[i];Reflect.has(e,r)&&this.set(t,r,e[r])}return this}static getLength(t,e){const s=t[t.length-1];return s.end||this.initialize(t),e<<Math.ceil(Math.log2(s.end))}static initialize(t){let e=0;for(let s=0;s<t.length;s++){const i=t[s],{type:r}=i;let n=i.size;if(!Reflect.has(Y,r))throw TypeError(`Type "${r}" is not a valid type.`);if(Reflect.has(Q,r)){const t=Q[r].BYTES_PER_ELEMENT;e=R.getGTEMultiple(e,t),n*=t}i.start=e,e+=n||Y[r],i.end=e}}};var Z=function(t){return class extends t{includes(t){return!!~this.indexOf(t)}indexOf(t){return this.constructor.getIndex(this,t)}isSorted(){return this.constructor.isSorted(this)}isUnique(){return this.constructor.isUnique(this)}range(t,e,s){return this.constructor.getRange(this,t,e,this.constructor.compare,s)}rank(t){return this.constructor.getIndex(this,t,this.constructor.compare,!0)}static compare(t,e){if(t>e)return 1;if(t<e)return-1;if(t===e)return 0;throw new RangeError("Unstable comparison.")}static from(t,e,s){const i=super.from(t,e,s);return i.sort(),i}static getDifference(t,e,s,i=this.compare,r=[]){let n=0,o=0;for(;n<t.length&&o<e.length;){const a=i(t[n],e[o]);a>0?(s&&(r[r.length]=e[o]),o++):a<0?(r[r.length]=t[n],n++):(n++,o++)}for(;n<t.length;)r[r.length]=t[n],n++;if(s)for(;o<e.length;)r[r.length]=e[o],o++;return r}static getDifferenceScore(t,e,s,i){const r=this.getIntersectionScore(t,e,i);return s?t.length+e.length-2*r:t.length-r}static getIndex(t,e,s=this.compare,i=!1,r=0,n=t.length-1){let o,a=r,h=n;for(;a<=h;){const i=s(t[o=a+h>>1],e);if(i<0)a=o+1;else{if(!(i>0))return o;h=o-1}}return i?a:-1}static getIntersection(t,e,s=this.compare,i=[]){let r=0,n=0;for(;r<t.length&&n<e.length;){const o=s(t[r],e[n]);o>0?n++:o<0?r++:(i[i.length]=t[r],r++,n++)}return i}static getIntersectionScore(t,e,s=this.compare){let i=0,r=0,n=0;for(;r<t.length&&n<e.length;){const o=s(t[r],e[n]);o>0?n++:o<0?r++:(i++,r++,n++)}return i}static getRange(t,e,s,i,r){const n=void 0===e?0:this.getIndex(t,e,i,!0),o=void 0===s?t.length:this.getIndex(t,s,i,!0,n)+1;return t[r?"subarray":"slice"](n,o)}static getUnion(t,e,s,i=this.compare,r=[]){let n=0,o=0;for(;n<t.length&&o<e.length;){const a=i(t[n],e[o]);a>0?(r[r.length]=e[o],o++):a<0?(r[r.length]=t[n],n++):(r[r.length]=t[n],s||(r[r.length]=e[o]),n++,o++)}for(;n<t.length;)r[r.length]=t[n],n++;for(;o<e.length;)r[r.length]=e[o],o++;return r}static getUnique(t,e=this.compare,s=[]){s[0]=t[0];for(let i=1;i<t.length;i++)0!==e(t[i-1],t[i])&&(s[s.length]=t[i]);return s}static of(...t){const e=super.of(...t);return e.sort(),e}static isSorted(t,e=this.compare){for(let s=1;s<t.length;s++)if(e(t[s-1],t[s])>0)return!1;return!0}static isUnique(t,e=this.compare){for(let s=1;s<t.length;s++)if(0===e(t[s-1],t[s]))return!1;return!0}}};var tt=class extends(Z(Array)){concat(...t){let e=this;for(let s=0;s<t.length;s++)e=this.constructor.getUnion(e,t[s],this.unique,this.constructor.compare,new this.constructor);return e}push(...t){const{compare:e}=this.constructor,s=this.length;if(!s)return super.push(...t.sort(e));const i=this.unique?t.filter(t=>!~this.indexOf(t)):t,r=i.length;if(!r)return s;i.sort(e);for(let t=r-1;t>=0;t--){let r;const n=this[s-1];for(r=s-2;r>=0&&1===e(this[r],i[t]);r--)this[r+1]=this[r];r===s-2&&1!==e(n,i[t])||(this[r+1]=i[t],i[t]=n)}return super.push(...i)}set(t){this.length=t.length;for(let e=0;e<t.length;e++)this[e]=t[e];return this}sort(t=this.constructor.compare){return super.sort(t)}splice(t,e,...s){const i=super.splice(t,e);return this.push(...s),i}uniquify(){return this.set(this.constructor.getUnique(this,this.constructor.compare,new this.constructor))}unshift(...t){return this.push(...t)}};var et=function(t){class e extends t{constructor(t={},...s){const{rows:i=2,pad:r=0}=t;s.length?super(...s):(super(e.getLength(i)),this.fill(r)),Object.defineProperties(this,{pad:{value:r,writable:!0},columns:{value:i},rows:{value:i},lastCoordinates:{value:Object.seal({row:0,column:0})}})}get(t,e){return this[this.constructor.getIndex(t,e)]}set(t,e,s){return t.length&&super.set?(super.set(t,e),this):(this[this.constructor.getIndex(t,e)]=s,this)}setArray(t,e){if(super.set)super.set(t,e);else{this.length=t.length;for(let e=0;e<t.length;e++)this[e]=t[e]}}getCoordinates(t){const e=Math.sqrt(1+(t<<3))-1>>1;return this.lastCoordinates.row=e,this.lastCoordinates.column=t-(e*(e+1)>>1),this.lastCoordinates}toArrays(){const{rows:t}=this,e=new Array(t).fill(0).map(()=>[]);let s=0;for(let i=0;i<t;i++)for(let t=0;t<=i;t++)e[i][t]=this[s],e[t][i]=this[s],s++;return e}static get[Symbol.species](){return t}static getIndex(t,e){const[s,i]=t>=e?[e,t]:[t,e];return s+((i+1)*i>>1)}static getLength(t){return(t+1)*t>>1}static fromArrays(t,e=0){const s=t.length,i=new this({rows:s,pad:e});let r=0;for(let e=0;e<s;e++)for(let s=0;s<=e;s++)i[r]=t[e][s],r++;return i}}return e};class st extends Uint32Array{constructor(t={},...e){let{vertices:s,edges:i}=t;e.length?(!s&&e[0].length&&(s=st.getVertexCount(e[0]),i=e[0].length-s-1),super(...e)):super((s=s||2)+(i=i||2)+1),Object.defineProperties(this,{vertices:{value:s},edges:{value:i}}),e.length||this.setOffsets()}addEdge(t,e){const{undirected:s}=this.constructor;if(this.hasEdge(t,e))return this;if(this.isFull())throw new RangeError("The list is full.");return this.setEdge(t,e),s&&this.setEdge(e,t),this}removeEdge(t,e){const{undirected:s}=this.constructor;return this.unsetEdge(t,e),s&&this.unsetEdge(e,t),this}hasEdge(t,e){return!!this.getEdge(t,e)}getEdge(t,e){const s=this[t],i=this[t+1];if(s===i)return 0;for(let t=s;t<i;t++)if(this[t]===e)return 1;return 0}setEdge(t,e){const{vertices:s}=this;for(let e=this[s];e>this[t];e--)[this[e],this[e-1]]=[this[e-1],this[e]];this[this[t]]=e;for(let e=t+1;e<=s;e++)this[e]+=1;return this}unsetEdge(t,e){const s=this[t],i=this[t+1];if(s===i)return this;let r=0;for(let t=s;t<i;t++)if(this[t]===e){r=t;break}if(!r)return this;for(let t=r;t<this[this.vertices];t++)this[t]=this[t+1];for(let e=t+1;e<=this.vertices;e++)this[e]-=1;return this}*outEdges(t){const e=this[t],s=this[t+1];if(e!==s)for(let t=s-1;t>=e;t--)yield this[t]}*inEdges(t){const{vertices:e}=this;let s=0,i=1;for(let r=e+1;r<this[e];r++){for(;r>=this[i];)s++,i++;this[r]===t&&(yield s)}}setOffsets(){const t=this.vertices+1;for(let e=0;e<t;e++)this[e]=t}isFull(){return this[this.vertices]>=this.length}grow(t=0,e=1){const s=new this.constructor({vertices:this.vertices+t,edges:this.edges+e});if(t){const e=this[this.vertices],i=this.vertices+t,r=e+t;for(let e=0;e<=i;e++)s[e]=e<this.vertices?this[e]+t:r;s.set(this.subarray(this.vertices+1),i+1)}else s.set(this);return s}static getLength(t,e){return t+e+1}static getVertexCount(t){let e=0;for(;t[e]<=t[e+1];)e++;return e}static get[Symbol.species](){return Uint32Array}static fromGrid(t){const e=t.rows,s=e+1,i=t.pad||0,r=new Array(s).fill(s);let n=0;for(let o=0;o<e;o++){r[o+1]=0===o?s:r[o];for(let s=0;s<e;s++)t.get(o,s)!==i&&(r.push(s),r[o+1]+=1,n++)}const o=new this({vertices:e,edges:n});return o.set(r),o}}st.undirected=!1,st.weighted=!1;var it=st;class rt extends M{constructor(t={},...e){const{vertices:s=2}=t;super({rows:s,columns:s},...e),Object.defineProperties(this,{vertices:{value:s}})}addEdge(t,e){const{undirected:s}=this.constructor;return this.set(t,e),s&&this.set(e,t),this}removeEdge(t,e){const{undirected:s}=this.constructor;return this.set(t,e,0),s&&this.set(e,t,0),this}hasEdge(t,e){return!!this.get(t,e)}getEdge(t,e){return this.get(t,e)}*outEdges(t){const{columns:e,offset:s}=this,i=t<<s,r=i+e;for(let t=i;t<r;t++){const e=t>>4,s=t-(e<<4);this[e]>>s&1&&(yield t-i)}}*inEdges(t){const{rows:e,offset:s}=this;for(let i=0;i<e;i++){const e=(i<<s)+t,r=e>>4,n=e-(r<<4);this[r]>>n&1&&(yield i)}}static getLength(t){return super.getLength(t,t)}static fromList(t){const{vertices:e}=t,s=new this({vertices:e});for(let i=0;i<e;i++){const e=t[i],r=t[i+1];if(e!==r)for(let n=r-1;n>=e;n--)s.addEdge(i,t[n])}return s}}rt.undirected=!1,rt.weighted=!1;var nt=rt;var ot=function(t){class e extends t{constructor(t={},...s){let{vertices:i,edges:r}=t;s.length?(!i&&s[0].length&&(i=e.getVertexCount(s[0]),r=s[0].length-i-1),super(...s)):super((i=i||2)+((r=r||4)<<1)+1),Object.defineProperties(this,{vertices:{value:i},edges:{value:r}}),s.length||this.setOffsets()}addEdge(t,e,s){const{undirected:i}=this.constructor;if(this.hasEdge(t,e))return this;if(this.isFull())throw new RangeError("The list is full.");return this.setEdge(t,e,s),i&&this.setEdge(e,t,s),this}removeEdge(t,e){const{undirected:s}=this.constructor;return this.unsetEdge(t,e),s&&this.unsetEdge(e,t),this}hasEdge(t,e){return!Number.isNaN(this.getEdge(t,e))}getEdge(t,e){const s=this[t],i=this[t+1];if(s===i)return NaN;for(let t=s;t<i;t+=2)if(this[t]===e)return this[t+1];return NaN}setEdge(t,e,s){const{vertices:i}=this;for(let e=this[i];e>this[t];e-=2)[this[e],this[e+1],this[e-1],this[e-2]]=[this[e-2],this[e-1],this[e],this[e+1]];this[this[t]]=e,this[this[t]+1]=s;for(let e=t+1;e<=i;e++)this[e]+=2;return this}unsetEdge(t,e){const s=this[t],i=this[t+1];if(s===i)return this;let r=0;for(let t=s;t<i;t+=2)if(this[t]===e){r=t;break}if(!r)return this;for(let t=r;t<this[this.vertices];t+=2)this[t]=this[t+2],this[t+1]=this[t+3];for(let e=t+1;e<=this.vertices;e++)this[e]-=2;return this}*outEdges(t){const e=this[t],s=this[t+1];if(e!==s)for(let t=s-2;t>=e;t-=2)yield this[t]}*inEdges(t){const{vertices:e}=this;let s=0,i=1;for(let r=e+1;r<this[e];r+=2){for(;r>=this[i];)s++,i++;this[r]===t&&(yield s)}}setOffsets(){const t=this.vertices+1;for(let e=0;e<t;e++)this[e]=t}isFull(){return this[this.vertices]>=this.length}grow(t=0,e=1){const s=new this.constructor({vertices:this.vertices+t,edges:this.edges+e});if(t){const e=this[this.vertices],i=this.vertices+t,r=e+t;for(let e=0;e<=i;e++)s[e]=e<this.vertices?this[e]+t:r;s.set(this.subarray(this.vertices+1),i+1)}else s.set(this);return s}static getLength(t,e){return t+(e<<1)+1}static getVertexCount(t){let e=0;for(;t[e]<=t[e+1];)e++;return e}static get[Symbol.species](){return t}static fromGrid(t){const e=t.rows,s=e+1,i=t.pad||0,r=new Array(s).fill(s);let n=0;for(let o=0;o<e;o++){r[o+1]=0===o?s:r[o];for(let s=0;s<e;s++){const e=t.get(o,s);e!==i&&(r.push(s,e),r[o+1]+=2,n++)}}const o=new this({vertices:e,edges:n});return o.set(r),o}}return e.undirected=!1,e.weighted=!0,e};var at=function(t,e=!1){const s=e?et(t):N(t);class i extends s{constructor(t={},...e){const{vertices:s=2,pad:i=0}=t;super({rows:s,columns:s,pad:i},...e),Object.defineProperties(this,{vertices:{value:s}})}addEdge(t,e,s){return this.set(t,e,s),this}removeEdge(t,e){return this.set(t,e,this.pad),this}hasEdge(t,e){return this.get(t,e)!==this.pad}getEdge(t,e){return this.get(t,e)}*outEdges(t){const{vertices:e}=this;for(let s=0;s<e;s++)this.hasEdge(t,s)&&(yield s)}*inEdges(t){const{vertices:e}=this;for(let s=0;s<e;s++)this.hasEdge(s,t)&&(yield s)}static getLength(t){return super.getLength(t,t)}static fromList(t,e=0){const{vertices:s}=t,i=new this({vertices:s,pad:e});for(let e=0;e<s;e++){const s=t[e],r=t[e+1];if(s!==r)for(let n=r-2;n>=s;n-=2)i.addEdge(e,t[n],t[n+1])}return i}}return i.undirected=e,i.weighted=!0,i};var ht=function(t){return t.isInitialized||t.initialize(),class extends t{get(e){const{objectLength:s}=this.constructor;return new t(this.buffer,this.byteOffset+e*s,s)}set(t,e){return this.setObject(t*this.constructor.objectLength,e,this.constructor),this}setView(t,e){const{objectLength:s}=this.constructor;return new Uint8Array(this.buffer,this.byteOffset+t*s,s).set(new Uint8Array(e.buffer,e.byteOffset,e.length)),this}get size(){return this.byteLength/this.constructor.objectLength}*[Symbol.iterator](){const{size:t}=this;for(let e=0;e<t;e++)yield this.get(e)}toObject(){return this.getArray(0,this.constructor,this.size)}static from(t,e){const s=e||this.of(t.length),{size:i}=s;for(let e=0;e<i;e++)s.set(e,t[e]);return s}static getLength(t){return t*this.objectLength}static of(t=1){return new this(new ArrayBuffer(this.getLength(t)))}}};const lt={int8:"getInt8",uint8:"getUint8",int16:"getInt16",uint16:"getUint16",int32:"getInt32",uint32:"getUint32",float32:"getFloat32",float64:"getFloat64",bigint64:"getBigInt64",biguint64:"getBigUint64"},ct={int8:"setInt8",uint8:"setUint8",int16:"setInt16",uint16:"setUint16",int32:"setInt32",uint32:"setUint32",float32:"setFloat32",float64:"setFloat64",bigint64:"setBigInt64",biguint64:"setBigUint64"},ut={int8:0,uint8:0,int16:1,uint16:1,int32:2,uint32:2,float32:2,float64:3,bigint64:3,biguint64:3};var gt=function(t,e){class s extends DataView{get(t){const{typeGetter:e,offset:s,littleEndian:i}=this.constructor;return this[e](t<<s,i)}set(t,e){const{typeSetter:s,offset:i,littleEndian:r}=this.constructor;return this[s](t<<i,e,r),this}get size(){return this.byteLength>>this.constructor.offset}*[Symbol.iterator](){const{size:t}=this;for(let e=0;e<t;e++)yield this.get(e)}toObject(){return[...this]}static getLength(t){return t<<this.offset}static from(t,e){const s=e||this.of(t.length),{size:i}=s;for(let e=0;e<i;e++)s.set(e,t[e]);return s}static of(t=1){return new this(new ArrayBuffer(this.getLength(t)))}}return s.typeGetter=lt[t],s.typeSetter=ct[t],s.offset=ut[t],s.littleEndian=!!e,s};const ft={int8:1,uint8:1,int16:2,uint16:2,int32:4,uint32:4,float32:4,float64:8,bigint64:8,biguint64:8,string:0};class dt extends DataView{get(t){const{type:e,littleEndian:s,start:i,ctor:r,length:n}=this.constructor.schema[t];switch(e){case"int8":return this.getInt8(i);case"uint8":return this.getUint8(i);case"int16":return this.getInt16(i,s);case"uint16":return this.getUint16(i,s);case"int32":return this.getInt32(i,s);case"uint32":return this.getUint32(i,s);case"float32":return this.getFloat32(i,s);case"float64":return this.getFloat64(i,s);case"bigint64":return this.getBigInt64(i,s);case"biguint64":return this.getBigUint64(i,s);default:return this.getView(i,n,r)}}getArray(t,e,s){const{schema:i,objectLength:r}=e,n=new Array(s);for(let e=0;e<s;e++)n[e]=this.getObject(i,t+e*r);return n}getTypedArray(t,e,s){const{typeGetter:i,offset:r,littleEndian:n}=e,o=new Array(s);for(let e=0;e<s;e++)o[e]=this[i](t+(e<<r),n);return o}getObject(t,e){const s=Object.keys(t),i={};for(let r=0;r<s.length;r++){const n=s[r],{type:o,littleEndian:a,start:h,ctor:l,length:c,size:u}=t[n];let g;const f=e+h;switch(o){case"int8":g=this.getInt8(f);break;case"uint8":g=this.getUint8(f);break;case"int16":g=this.getInt16(f,a);break;case"uint16":g=this.getUint16(f,a);break;case"int32":g=this.getInt32(f,a);break;case"uint32":g=this.getUint32(f,a);break;case"float32":g=this.getFloat32(f,a);break;case"float64":g=this.getFloat64(f,a);break;case"bigint64":g=this.getBigInt64(f,a);break;case"biguint64":g=this.getBigUint64(f,a);break;case"string":g=new J(this.buffer,this.byteOffset+f,c).toString();break;case"typedarray":g=this.getTypedArray(f,l,u);break;case"array":g=this.getArray(f,l,u);break;default:g=this.getObject(l.schema,f)}i[n]=g}return i}getView(t,e,s=J){return new s(this.buffer,this.byteOffset+t,e)}set(t,e){return this.setValue(t,e)}setArray(t,e,s,i){const{fields:r,schema:n}=s,o=i<e.length?i:e.length;for(let i=0;i<o;i++)for(let o=0;o<r.length;o++){const a=r[o];this.setValue(a,e[i][a],n,t+i*s.objectLength)}}setObject(t,e,s){const{fields:i,schema:r}=s;for(let s=0;s<i.length;s++){const n=i[s];Reflect.has(e,n)&&this.setValue(n,e[n],r,t)}}setString(t,e,s){new Uint8Array(this.buffer,this.byteOffset+t,s).fill(0).set(J.fromString(e))}setTypedArray(t,e,s,i){const{typeSetter:r,offset:n,littleEndian:o}=s,a=i<e.length?i:e.length;for(let s=0;s<a;s++)this[r](t+(s<<n),e[s],o)}setValue(t,e,s=this.constructor.schema,i=0){const{type:r,littleEndian:n,start:o,ctor:a,length:h,size:l}=s[t],c=i+o;switch(r){case"int8":this.setInt8(c,e);break;case"uint8":this.setUint8(c,e);break;case"int16":this.setInt16(c,e,n);break;case"uint16":this.setUint16(c,e,n);break;case"int32":this.setInt32(c,e,n);break;case"uint32":this.setUint32(c,e,n);break;case"float32":this.setFloat32(c,e,n);break;case"float64":this.setFloat64(c,e,n);break;case"bigint64":this.setBigInt64(c,e,n);break;case"biguint64":this.setBigUint64(c,e,n);break;case"string":this.setString(c,e,h);break;case"typedarray":this.setTypedArray(c,e,a,l);break;case"array":this.setArray(c,e,a,l);break;default:this.setObject(c,e,a)}return this}setView(t,e){const{start:s}=this.constructor.schema[t];return new Uint8Array(this.buffer,this.byteOffset,this.byteLength).set(new Uint8Array(e.buffer,e.byteOffset,e.byteLength),s),this}toObject(){return this.getObject(this.constructor.schema,0)}static from(t,e){const s=e||new this(new ArrayBuffer(this.getLength()));return s.setObject(0,t,s.constructor),s}static getLength(){return this.isInitialized||this.initialize(),this.objectLength}static initialize(){const{schema:t}=this,e=Object.keys(t);let s=0;for(let i=0;i<e.length;i++){const r=t[e[i]],{type:n,size:o,littleEndian:a}=r;let h=0;const l="string"==typeof n,c=l&&!!o,u=!c&&!!o;if(l&&!Reflect.has(ft,n))throw TypeError(`Type "${n}" is not a valid type.`);c?(r.ctor=gt(n,a),r.type="typedarray",h=r.ctor.getLength(o)):u?(r.ctor=ht(n),r.type="array",h=r.ctor.getLength(o)):l||(r.type="object",r.ctor=n,h=n.getLength()),r.start=s,r.length=r.length||h||ft[n],s+=r.length}this.objectLength=s,this.fields=e,this.isInitialized=!0}}dt.fields=void 0,dt.schema=void 0,dt.objectLength=0,dt.isInitialized=!1;var yt={BitField:z,GraphMixin:V,GridMixin:N,BinaryHeap:F,Pool:K,RankedBitArray:W,RecordArray:X,SortedArray:tt,SortedMixin:Z,SymmetricGridMixin:et,UnweightedAdjacencyList:it,UnweightedAdjacencyMatrix:nt,WeightedAdjacencyListMixin:ot,WeightedAdjacencyMatrixMixin:at,ArrayViewMixin:ht,ObjectView:dt,StringView:J,TypedArrayViewMixin:gt}.GridMixin;const{Map:pt,Object:mt}=k;function vt(t,e,s){const i=mt.create(t);return i.tile=e[s],i}function bt(t){var e,s,c,f;return{c(){e=i("div"),s=i("p"),c=v("No mapGrid provided!"),f=r(),this.h()},l(t){e=n(t,"DIV",{class:!0},!1);var i=o(e);s=n(i,"P",{class:!0},!1);var r=o(s);c=a(r,"No mapGrid provided!"),r.forEach(h),f=a(i,"\n  "),i.forEach(h),this.h()},h(){l(s,"class","flex-item svelte-tcq59r"),l(e,"class","flex-container svelte-tcq59r")},m(t,i){u(t,e,i),g(e,s),g(s,c),g(e,f)},d(t){t&&h(e)}}}function wt(t){var e;return{c(){e=i("img"),this.h()},l(t){e=n(t,"IMG",{src:!0,style:!0,alt:!0,class:!0},!1),o(e).forEach(h),this.h()},h(){l(e,"src",t.tile.image),l(e,"style",t.extraStylesFor(t.tile)),l(e,"alt",t.tile.key),l(e,"class","id-"+t.tile.id+" tile-index-"+t.tile.index+" row-"+t.tile.position.row+" column-"+t.tile.position.column+" svelte-tcq59r")},m(t,s){u(t,e,s)},p:b,d(t){t&&h(e)}}}function kt(t){var e,s;return{c(){e=i("img"),this.h()},l(t){e=n(t,"IMG",{src:!0,style:!0,alt:!0,id:!0,class:!0},!1),o(e).forEach(h),this.h()},h(){l(e,"src",s=t.player.image),l(e,"style",t.extraStylesFor(t.tile)),l(e,"alt",t.tile.key),l(e,"id","player"),l(e,"class","id-"+t.tile.id+" tile-index-"+t.tile.index+" row-"+t.tile.position.row+" column-"+t.tile.position.column+" svelte-tcq59r")},m(t,s){u(t,e,s)},p(t,i){t.player&&s!==(s=i.player.image)&&l(e,"src",s)},d(t){t&&h(e)}}}function xt(t,e){var s,p,m,v,w=b;function k(t){return t.tile.image&&t.tile.key===t.player.key?kt:t.tile.image?wt:void 0}var x=k(e),I=x&&x(e);return{key:t,first:null,c(){s=i("div"),I&&I.c(),p=r(),this.h()},l(t){s=n(t,"DIV",{class:!0},!1);var e=o(s);I&&I.l(e),p=a(e,"\n"),e.forEach(h),this.h()},h(){l(s,"class","flex-item "+e.extraClassesFor(e.tile)+" svelte-tcq59r"),v=[c(s,"animationstart",e.animations.starting(e.tile)),c(s,"animationend",e.animations.ending(e.tile)),c(s,"animationcancel",e.animations.canceled(e.tile))],this.first=s},m(t,e){u(t,s,e),I&&I.m(s,null),g(s,p)},p(t,i){x===(x=k(e=i))&&I?I.p(t,e):(I&&I.d(1),(I=x&&x(e))&&(I.c(),I.m(s,p)))},r(){m=s.getBoundingClientRect()},f(){f(s),w()},a(){w(),w=d(s,m,Ut,{duration:150,easing:O})},d(t){t&&h(s),I&&I.d(),y(v)}}}function It(t){var e,s,c,f,d=[],y=new pt,v=`Moves: ${t.player.moves}`,w=t.tileArray;const k=t=>t.tile.id;for(var I=0;I<w.length;I+=1){let e=vt(t,w,I),s=k(e);y.set(s,d[I]=xt(s,e))}var A=null;return w.length||(A=bt()).c(),{c(){for(e=i("figure"),s=i("div"),I=0;I<d.length;I+=1)d[I].c();c=r(),f=i("figcaption"),this.h()},l(t){e=n(t,"FIGURE",{id:!0,style:!0,class:!0},!1);var i=o(e);s=n(i,"DIV",{id:!0,class:!0},!1);var r=o(s);for(I=0;I<d.length;I+=1)d[I].l(r);r.forEach(h),c=a(i,"\n"),f=n(i,"FIGCAPTION",{class:!0},!1),o(f).forEach(h),i.forEach(h),this.h()},h(){l(s,"id","gameView"),l(s,"class","flex-container svelte-tcq59r"),l(f,"class","text-center mx-auto svelte-tcq59r"),l(e,"id","sokoban"),p(e,"--columns",t.columns),p(e,"--rows",t.rowIndex),p(e,"--ratio","calc(var(--columns) / var(--rows))"),p(e,"--width","calc(100vmin - 0em)"),p(e,"--tile-width","calc(var(--width) / var(--columns))"),p(e,"--goal-background","url(/"+t.tileTypeDict[t.goal.key].image+")"),p(e,"--floor-background","url(/"+t.tileTypeDict[t.blank.key].image+")"),l(e,"class","svelte-tcq59r")},m(t,i){for(u(t,e,i),g(e,s),I=0;I<d.length;I+=1)d[I].m(s,null);A&&A.m(s,null),g(e,c),g(e,f),f.innerHTML=v},p(t,i){const r=i.tileArray;for(let t=0;t<d.length;t+=1)d[t].r();d=m(d,t,k,1,i,r,y,s,x,xt,null,vt);for(let t=0;t<d.length;t+=1)d[t].a();r.length?A&&(A.d(1),A=null):A||((A=bt()).c(),A.m(s,null)),t.player&&v!==(v=`Moves: ${i.player.moves}`)&&(f.innerHTML=v),t.columns&&p(e,"--columns",i.columns),t.rowIndex&&p(e,"--rows",i.rowIndex),(t.tileTypeDict||t.goal)&&p(e,"--goal-background","url(/"+i.tileTypeDict[i.goal.key].image+")"),(t.tileTypeDict||t.blank)&&p(e,"--floor-background","url(/"+i.tileTypeDict[i.blank.key].image+")")},i:b,o:b,d(t){for(t&&h(e),I=0;I<d.length;I+=1)d[I].d();A&&A.d()}}}const At="sokoban/images/";function Et(t){const e=Math.max(Math.floor(Math.random()*Math.floor({C:6,W:4," ":3,P:5}[t])),{C:2,W:1," ":1,P:0}[t]);return"P"===t?e:("0"+e).slice(-2)}function Ut(t,{from:e,to:s},i){const r=e.left-s.left,n=e.top-s.top,o=Math.sqrt(r*r+n*n),a=Math.abs(n)>14?0:r<0?360:-360;return{delay:0,duration:120*Math.sqrt(o),easing:i.easing||O,css:(t,e)=>`transform: translate(${e*r}px, ${e*n}px) rotate(${t*a}deg);`}}function Ct(t,e,s){let{mapGrid:i,level:r}=e;const n={left:{row:0,column:-1,str:"left"},down:{row:1,column:0,str:"down"},right:{row:0,column:1,str:"right"},up:{row:-1,column:0,str:"up"}},o={key:"C",imagePrefix:"Crates/crate_",imageIndex:Et("C"),imageSuffix:".png"},a={key:"W",imagePrefix:"Blocks/block_",imageIndex:Et("W"),imageSuffix:".png"},h={key:" ",imagePrefix:"Ground/ground_",imageIndex:Et(" "),imageSuffix:".png"},l={key:"G",imagePrefix:"Ground/ground_",imageIndex:h.imageIndex,imageSuffix:"_goal.png"},c={key:"P",get imagePrefix(){return"Player/"+this.direction.str+"/"},imageIndex:0,maxImageIndex:5,imageSuffix:".png",get image(){return At+this.imagePrefix+this.moves%this.maxImageIndex+this.imageSuffix},moves:0,position:{row:0,column:0},direction:n.down,standingOn:h},u={};u.C=o,s("tileTypeDict",u),u.G=l,s("tileTypeDict",u),u.W=a,s("tileTypeDict",u),u[" "]=h,s("tileTypeDict",u),Object.values(u).forEach(t=>{t.image=At+t.imagePrefix+t.imageIndex+t.imageSuffix}),u.P=c,s("tileTypeDict",u);let g=[],f=[],d=0,y=0,p=0;i.forEach(t=>{let e=[],i=0;t.forEach(t=>{const r="B"===t?"C":t,n="PC".includes(r)?{key:r,initialLocationIndex:p,initialPos:{row:d,column:i}}:null,o={gridLocation:p,initialKey:"PC".includes(r)?h.key:r,entity:n,moveEntityTo(t){t.entity&&alert(`Warning! Entity of ${t} replaced by entity of ${this}.`),t.entity=this.entity,this.entity=null,this.key===c.key&&(c.tile=this,s("player",c))},get id(){return this.entity?this.entity.initialLocationIndex:-this.gridLocation},get key(){return this.entity?this.entity.key:this.initialKey},floorKey:h.key,index:p,position:{row:d,column:i},get image(){return this.isTraversable?"":u[this.key].image},get backgroundImage(){return this.isTraversable?u[this.key].image:u[this.floorKey].image},get isTraversable(){return" "===this.key||"G"===this.key},get hasCrate(){return"C"===this.key&&"G"===this.floorKey}};r===c.key&&(c.position=o.position,s("player",c),c.standingOn=o,s("player",c)),"G"===r&&(o.floorKey="G",g.push(o)),e.push(o),p++,i++,s("columns",y=Math.max(i,y))}),s("rowIndex",++d),f.push(e)});let m=yt(Array).fromArrays(f);const v=f.flat();const b=function(){I=!0};function k(t){if(I){if(c.direction!=t)return c.direction=t,s("player",c),c.moves++,void s("player",c);const e=function(t,e){const s={fromCoordinates:e,relativeCoordinates:t};return s.targetCoordinates={row:e.row+t.row,column:e.column+t.column},s.beyondTargetCoordinates={row:s.targetCoordinates.row+t.row,column:s.targetCoordinates.column+t.column},s.targetCoordinates.row<0||s.targetCoordinates.column<0?{canMove:!1,...s}:s.targetCoordinates.row>m.rows||s.targetCoordinates.column>m.columns?{canMove:!1,...s}:(s.targetTile=m.get(s.targetCoordinates.row,s.targetCoordinates.column),s.beyondTargetTile=m.get(s.beyondTargetCoordinates.row,s.beyondTargetCoordinates.column),s.targetTile.isTraversable?{canMove:!0,...s}:s.targetTile.key===o.key&&s.beyondTargetTile.isTraversable?{canMove:!0,...s}:{canMove:!1,...s})}(t,c.position);if(e.canMove){c.moves++,s("player",c),I=!1;setTimeout(b,250);if(e.targetTile.key===o.key){const t=e.beyondTargetTile.key===l.key;e.targetTile.moveEntityTo(e.beyondTargetTile),t&&(s("goalTiles",g),console.log(g))}c.standingOn.moveEntityTo(e.targetTile),c.standingOn=e.targetTile,s("player",c),c.position=e.targetCoordinates,s("player",c)}else{I=!1;setTimeout(b,250);console.log("Can't go in that direction!")}s("player",c)}else console.log("Busy with animation!")}let x=!1,I=!0;const A=[],E=function(t){for(let t=0;t<A.length;t++){const{location:e,overlay:s}=A[t];s.style.setProperty("--offset-left",e.offsetLeft+"px"),s.style.setProperty("--offset-top",e.offsetTop+"px")}};w(async()=>{const t=document.createElement("div"),e=document.createElement("img");e.src=u[l.key].image,t.appendChild(e),t.classList.add("background-subarea");const s=document.getElementsByClassName("goal");for(let e=0;e<s.length;e++){const i=s[e];let r=t;e<s.length-1&&(r=t.cloneNode(!0)),r.style.setProperty("--offset-left",i.offsetLeft+"px"),r.style.setProperty("--offset-top",i.offsetTop+"px"),i.parentElement.insertBefore(r,i),r.style.setProperty("left","var(--offset-left)"),r.style.setProperty("top","var(--offset-top)"),A.push({location:i,overlay:r})}window.onresize=E;await import("./hotkeys.esm.416ead1c.js");C("left, right, up, down","ready",function(t,e){switch(e.key){case"left":k(n.left);break;case"up":k(n.up);break;case"right":k(n.right);break;case"down":k(n.down)}return!1}),C.setScope("ready")});const U=function(){const t=new Map,e={starting:function(e){t.set(e.id,!0),x=e.key===c.key||x},ending:function(e){t.delete(e.id),e.key===c.key&&(x||console.log("Player animation ended but we thought that they were already done with the animation."),x=!1)},canceled:function(e){t.set(e.id,!1),e.key===c.key&&(x||console.log("Player animation canceled but we thought that they were already done with the animation."),x=!1)}};return e}();let O;return t.$set=t=>{"mapGrid"in t&&s("mapGrid",i=t.mapGrid),"level"in t&&s("level",r=t.level)},t.$$.update=(t={goalTiles:1,levelComplete:1})=>{t.goalTiles&&s("levelComplete",O=g.every(t=>t.hasCrate)),t.levelComplete&&O&&(alert("Level Complete!"),console.log("Level Complete!"))},{mapGrid:i,level:r,blank:h,goal:l,player:c,tileTypeDict:u,rowIndex:d,columns:y,tileArray:v,extraClassesFor:function(t){return g.some(function(e){return e.position.row===t.position.row&&e.position.column===t.position.column})?"goal":""},extraStylesFor:function(t){return t.floorKey===l.key&&(t.key,c.key),""},animations:U}}class Ot extends t{constructor(t){super(),e(this,t,Ct,It,s,["mapGrid","level"])}}function Bt(t){var e,s,r,c,f;return{c(){e=i("div"),s=i("a"),r=i("button"),c=v("Next Level"),this.h()},l(t){e=n(t,"DIV",{class:!0},!1);var i=o(e);s=n(i,"A",{rel:!0,href:!0},!1);var l=o(s);r=n(l,"BUTTON",{class:!0},!1);var u=o(r);c=a(u,"Next Level"),u.forEach(h),l.forEach(h),i.forEach(h),this.h()},h(){l(r,"class","p-2 button"),l(s,"rel","prefetch"),l(s,"href",f="levels/"+t.level.next),l(e,"class","footer my-5 mx-auto svelte-3cscbz")},m(t,i){u(t,e,i),g(e,s),g(s,r),g(r,c)},p(t,e){t.level&&f!==(f="levels/"+e.level.next)&&l(s,"href",f)},d(t){t&&h(e)}}}function St(t){var e,s,c,f,d=new Ot({props:{level:t.level,mapGrid:t.mapGrid}}),y=null!=t.level.next&&Bt(t);return{c(){e=r(),s=i("div"),d.$$.fragment.c(),c=r(),y&&y.c(),this.h()},l(t){e=a(t,"\n\n"),s=n(t,"DIV",{class:!0},!1);var i=o(s);d.$$.fragment.l(i),c=a(i,"\n\t"),y&&y.l(i),i.forEach(h),this.h()},h(){l(s,"class","game_container mx-auto svelte-3cscbz")},m(t,i){u(t,e,i),u(t,s,i),I(d,s,null),g(s,c),y&&y.m(s,null),f=!0},p(t,e){var i={};t.level&&(i.level=e.level),t.mapGrid&&(i.mapGrid=e.mapGrid),d.$set(i),null!=e.level.next?y?y.p(t,e):((y=Bt(e)).c(),y.m(s,null)):y&&(y.d(1),y=null)},i(t){f||(A(d.$$.fragment,t),f=!0)},o(t){E(d.$$.fragment,t),f=!1},d(t){t&&(h(e),h(s)),U(d),y&&y.d()}}}async function Tt({params:t,query:e}){const s=await this.fetch(`levels/${t.slug}.json`),i=await s.json();if(200===s.status)return{level:i};this.error(s.status,i.message)}function Pt(t,e,s){let{level:i}=e;const r=i.mapGrid;return t.$set=t=>{"level"in t&&s("level",i=t.level)},{level:i,mapGrid:r}}export default class extends t{constructor(t){super(),e(this,t,Pt,St,s,["level"])}}export{Tt as preload};
//# sourceMappingURL=[slug].71920563.js.map
