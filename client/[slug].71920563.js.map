{"version":3,"file":"[slug].71920563.js","sources":["../../../node_modules/svelte/easing/index.mjs","../../../node_modules/structurae/lib/bit-field.js","../../../node_modules/structurae/lib/binary-grid.js","../../../node_modules/structurae/lib/binary-heap.js","../../../node_modules/structurae/lib/graph.js","../../../node_modules/structurae/lib/grid.js","../../../node_modules/structurae/lib/bit-array.js","../../../node_modules/structurae/lib/utilities.js","../../../node_modules/structurae/lib/pool.js","../../../node_modules/structurae/lib/ranked-bit-array.js","../../../node_modules/structurae/lib/string-view.js","../../../node_modules/structurae/lib/record-array.js","../../../node_modules/structurae/lib/sorted-collection.js","../../../node_modules/structurae/lib/sorted-array.js","../../../node_modules/structurae/lib/symmetric-grid.js","../../../node_modules/structurae/lib/unweighted-adjacency-list.js","../../../node_modules/structurae/lib/unweighted-adjacency-matrix.js","../../../node_modules/structurae/lib/weighted-adjacency-list.js","../../../node_modules/structurae/lib/weighted-adjacency-matrix.js","../../../node_modules/structurae/lib/array-view.js","../../../node_modules/structurae/lib/typed-array-view.js","../../../node_modules/structurae/lib/object-view.js","../../../node_modules/structurae/index.js","../../../src/components/Sokoban.svelte","../../../src/routes/levels/[slug].svelte"],"sourcesContent":["export { identity as linear } from '../internal';\n\n/*\nAdapted from https://github.com/mattdesl\nDistributed under MIT License https://github.com/mattdesl/eases/blob/master/LICENSE.md\n*/\nfunction backInOut(t) {\n    const s = 1.70158 * 1.525;\n    if ((t *= 2) < 1)\n        return 0.5 * (t * t * ((s + 1) * t - s));\n    return 0.5 * ((t -= 2) * t * ((s + 1) * t + s) + 2);\n}\nfunction backIn(t) {\n    const s = 1.70158;\n    return t * t * ((s + 1) * t - s);\n}\nfunction backOut(t) {\n    const s = 1.70158;\n    return --t * t * ((s + 1) * t + s) + 1;\n}\nfunction bounceOut(t) {\n    const a = 4.0 / 11.0;\n    const b = 8.0 / 11.0;\n    const c = 9.0 / 10.0;\n    const ca = 4356.0 / 361.0;\n    const cb = 35442.0 / 1805.0;\n    const cc = 16061.0 / 1805.0;\n    const t2 = t * t;\n    return t < a\n        ? 7.5625 * t2\n        : t < b\n            ? 9.075 * t2 - 9.9 * t + 3.4\n            : t < c\n                ? ca * t2 - cb * t + cc\n                : 10.8 * t * t - 20.52 * t + 10.72;\n}\nfunction bounceInOut(t) {\n    return t < 0.5\n        ? 0.5 * (1.0 - bounceOut(1.0 - t * 2.0))\n        : 0.5 * bounceOut(t * 2.0 - 1.0) + 0.5;\n}\nfunction bounceIn(t) {\n    return 1.0 - bounceOut(1.0 - t);\n}\nfunction circInOut(t) {\n    if ((t *= 2) < 1)\n        return -0.5 * (Math.sqrt(1 - t * t) - 1);\n    return 0.5 * (Math.sqrt(1 - (t -= 2) * t) + 1);\n}\nfunction circIn(t) {\n    return 1.0 - Math.sqrt(1.0 - t * t);\n}\nfunction circOut(t) {\n    return Math.sqrt(1 - --t * t);\n}\nfunction cubicInOut(t) {\n    return t < 0.5 ? 4.0 * t * t * t : 0.5 * Math.pow(2.0 * t - 2.0, 3.0) + 1.0;\n}\nfunction cubicIn(t) {\n    return t * t * t;\n}\nfunction cubicOut(t) {\n    const f = t - 1.0;\n    return f * f * f + 1.0;\n}\nfunction elasticInOut(t) {\n    return t < 0.5\n        ? 0.5 *\n            Math.sin(((+13.0 * Math.PI) / 2) * 2.0 * t) *\n            Math.pow(2.0, 10.0 * (2.0 * t - 1.0))\n        : 0.5 *\n            Math.sin(((-13.0 * Math.PI) / 2) * (2.0 * t - 1.0 + 1.0)) *\n            Math.pow(2.0, -10.0 * (2.0 * t - 1.0)) +\n            1.0;\n}\nfunction elasticIn(t) {\n    return Math.sin((13.0 * t * Math.PI) / 2) * Math.pow(2.0, 10.0 * (t - 1.0));\n}\nfunction elasticOut(t) {\n    return (Math.sin((-13.0 * (t + 1.0) * Math.PI) / 2) * Math.pow(2.0, -10.0 * t) + 1.0);\n}\nfunction expoInOut(t) {\n    return t === 0.0 || t === 1.0\n        ? t\n        : t < 0.5\n            ? +0.5 * Math.pow(2.0, 20.0 * t - 10.0)\n            : -0.5 * Math.pow(2.0, 10.0 - t * 20.0) + 1.0;\n}\nfunction expoIn(t) {\n    return t === 0.0 ? t : Math.pow(2.0, 10.0 * (t - 1.0));\n}\nfunction expoOut(t) {\n    return t === 1.0 ? t : 1.0 - Math.pow(2.0, -10.0 * t);\n}\nfunction quadInOut(t) {\n    t /= 0.5;\n    if (t < 1)\n        return 0.5 * t * t;\n    t--;\n    return -0.5 * (t * (t - 2) - 1);\n}\nfunction quadIn(t) {\n    return t * t;\n}\nfunction quadOut(t) {\n    return -t * (t - 2.0);\n}\nfunction quartInOut(t) {\n    return t < 0.5\n        ? +8.0 * Math.pow(t, 4.0)\n        : -8.0 * Math.pow(t - 1.0, 4.0) + 1.0;\n}\nfunction quartIn(t) {\n    return Math.pow(t, 4.0);\n}\nfunction quartOut(t) {\n    return Math.pow(t - 1.0, 3.0) * (1.0 - t) + 1.0;\n}\nfunction quintInOut(t) {\n    if ((t *= 2) < 1)\n        return 0.5 * t * t * t * t * t;\n    return 0.5 * ((t -= 2) * t * t * t * t + 2);\n}\nfunction quintIn(t) {\n    return t * t * t * t * t;\n}\nfunction quintOut(t) {\n    return --t * t * t * t * t + 1;\n}\nfunction sineInOut(t) {\n    return -0.5 * (Math.cos(Math.PI * t) - 1);\n}\nfunction sineIn(t) {\n    const v = Math.cos(t * Math.PI * 0.5);\n    if (Math.abs(v) < 1e-14)\n        return 1;\n    else\n        return 1 - v;\n}\nfunction sineOut(t) {\n    return Math.sin((t * Math.PI) / 2);\n}\n\nexport { backInOut, backIn, backOut, bounceOut, bounceInOut, bounceIn, circInOut, circIn, circOut, cubicInOut, cubicIn, cubicOut, elasticInOut, elasticIn, elasticOut, expoInOut, expoIn, expoOut, quadInOut, quadIn, quadOut, quartInOut, quartIn, quartOut, quintInOut, quintIn, quintOut, sineInOut, sineIn, sineOut };\n","/**\n * @private\n * Use Number if BigInt is not available.\n */\nconst BigInt = (global || window).BigInt || Number;\n\n/**\n * @private\n * @type {number} The largest safe integer for bitwise operations.\n */\nconst SIGN_BIT = 2147483647;\n\n/**\n * @private\n * @type {number} The maximum safe size for bitwise operations on standard numbers.\n */\nconst BITWISE_SIZE = 31;\n\n/**\n * @private\n * @type {number} The maximum safe size for standard numbers in bits.\n */\nconst MAX_SIZE = 53;\n\n/**\n * @private\n * @type {number} 2 ** 48\n */\nconst TWO_TO_48 = 281474976710656;\n\n/**\n * @private\n * @type {number} 2 ** 31\n */\nconst TWO_TO_31 = 2147483648;\n\n/**\n * @typedef {number | BigInt} AnyNumber\n */\n\n/**\n * @typedef {number | string} FieldName\n */\n\n/**\n * @typedef {Object<string, number>} UnpackedInt\n */\n\n/**\n * @typedef {Object} Field\n * @property {FieldName} name name of the field\n * @property {number} [size] size in bits\n */\n\n/**\n * @typedef {Array} Matcher\n * @property {AnyNumber} 0 value\n * @property {AnyNumber} 1 mask\n */\n\n/**\n * @typedef {Object<string, AnyNumber>} Masks\n */\n\n/**\n * Stores and operates on data in Numbers and BigInts treating them as bitfields.\n */\nclass BitField {\n  /**\n   * @param {AnyNumber|Array<number>} [data=0]\n   * @example\n   *\n   * class Person extends BitField {}\n   * Person.fields = [\n   *  { name: 'age', size: 7 },\n   *  { name: 'gender', size: 1 },\n   * ];\n   * new Person([20, 1]).value\n   * //=> 41\n   * new Person(41).value\n   * //=> 41\n   */\n  constructor(data = 0) {\n    const { isInitialized } = this.constructor;\n    if (!isInitialized) this.constructor.initialize();\n\n    const { isBigInt } = this.constructor;\n    const value = Array.isArray(data) ? this.constructor.encode(data) : data;\n\n    /** @type {number|BigInt} */\n    this.value = isBigInt ? BigInt(value) : value;\n  }\n\n  /**\n   * Returns the value of a given field.\n   *\n   * @param {Field} field name of the field\n   * @returns {number} value value of the field\n   * @example\n   *\n   * class Person extends BitField {}\n   * Person.fields = [\n   *  { name: 'age', size: 7 },\n   *  { name: 'gender', size: 1 },\n   * ];\n   * const person = new Person([20, 1]);\n   * person.get('age');\n   * //=> 20\n   * person.get('gender');\n   * //=> 1\n   */\n  get(field) {\n    const { offsets, masks } = this.constructor;\n    const value = (this.value >> offsets[field]) & masks[field];\n    return Number(value);\n  }\n\n  /**\n   * Stores a given value in a field.\n   *\n   * @param {Field} field name of the field\n   * @param {number} value value of the field\n   * @returns {BitField} the instance\n   * @example\n   *\n   * class Person extends BitField {}\n   * Person.fields = [\n   *  { name: 'age', size: 7 },\n   *  { name: 'gender', size: 1 },\n   * ];\n   * const person = new Person([20, 1]);\n   * person.get('age');\n   * //=> 20\n   * person.set('age', 30).get('age');\n   * //=> 30\n   */\n  set(field, value = this.constructor.one) {\n    const { offsets, masks, isBigInt } = this.constructor;\n    if (isBigInt) value = BigInt(value);\n    this.value = (this.value & ~(masks[field] << offsets[field])) | (value << offsets[field]);\n    return this;\n  }\n\n  /**\n   * Checks if an instance has all the specified fields set to 1. Useful for bit flags.\n   *\n   * @param {...Field} fields names of the fields to check\n   * @returns {boolean} whether all the specified fields are set in the instance\n   * @example\n   *\n   * const SettingsFlags = BinariusFactory(['notify', 'premium', 'moderator']);\n   * const settings = SettingsFlags([1, 0, 1]);\n   * settings.has('notify', 'moderator');\n   * //=> true\n   * settings.has('notify', 'premium');\n   * //=> false\n   */\n  has(...fields) {\n    const { offsets, zero, one } = this.constructor;\n    let mask = zero;\n    for (let i = 0; i < fields.length; i++) {\n      mask |= one << offsets[fields[i]];\n    }\n    mask |= this.value;\n    return this.value === mask;\n  }\n\n  /**\n   * Checks if the instance contains all the key-value pairs listed in matcher.\n   * Use `ParseInt.getMatcher` to get an array of precomputed values\n   * that you can use to efficiently compare multiple instances\n   * to the same key-value pairs as shown in the examples below.\n   *\n   * @param {UnpackedInt|Matcher} matcher an object with key-value pairs,\n   *                                                or an array of precomputed matcher values\n   * @returns {boolean} whether the instance matches with the provided fields\n   * @example\n   * class Person extends BitField {}\n   * Person.fields = [\n   *  { name: 'age', size: 7 },\n   *  { name: 'gender', size: 1 },\n   * ];\n   * const person = new Person([20, 1]);\n   * person.match({ age: 20 });\n   * //=> true\n   * person.match({ gender: 1 });\n   * //=> true\n   * person.match({ gender: 1, age: 20 });\n   * //=> true\n   * person.match({ gender: 1, age: 19 });\n   * //=> false\n   *\n   * // use precomputed matcher\n   * const matcher = Person.getMatcher({ age: 20});\n   * new Person([20, 0]).match(matcher);\n   * //=> true\n   * new Person([19, 0]).match(matcher);\n   * //=> false\n   */\n  match(matcher) {\n    return this.constructor.match(this.value, Array.isArray(matcher)\n      ? matcher : this.constructor.getMatcher(matcher));\n  }\n\n  /**\n   * Returns the object representation of the instance,\n   * with field names as properties with corresponding values.\n   * @returns {UnpackedInt} the object representation of the instance\n   * @example\n   *\n   * class Person extends BitField {}\n   * Person.fields = [\n   *  { name: 'age', size: 7 },\n   *  { name: 'gender', size: 1 },\n   * ];\n   * const person = new Person([20, 1]);\n   * person.toObject();\n   * //=> { age: 20, gender: 1 }\n   */\n  toObject() {\n    return this.constructor.decode(this.value);\n  }\n\n  /**\n   * Returns a string representing the value of the instance.\n   *\n   * @returns {string} a string representing the value of the instance\n   */\n  toString() {\n    return this.value.toString();\n  }\n\n  /**\n   * Returns the numerical value of an instance.\n   * Returns a BigInt if the total size exceeds 53 bits.\n   *\n   * @returns {AnyNumber} the numerical value of the instance\n   */\n  valueOf() {\n    const { isBigInt, isSafe } = this.constructor;\n    return (isBigInt && isSafe) ? Number(this.value) : this.value;\n  }\n\n  /**\n   * Encodes a given list of numbers into a single number according to the schema.\n   *\n   * @param {Array<AnyNumber>} data the list of numbers to encode\n   * @returns {AnyNumber} encoded number\n   * @example\n   *\n   * class Person extends BitField {}\n   * Person.fields = [\n   *  { name: 'age', size: 7 },\n   *  { name: 'gender', size: 1 },\n   * ];\n   * Person.encode([20, 1])\n   * //=> 41\n   */\n  static encode(data) {\n    const { zero, fields, isBigInt } = this;\n    let result = zero;\n    for (let i = data.length - 1; i >= 0; i--) {\n      const current = data[i];\n      result <<= fields[i].size;\n      result |= (isBigInt ? BigInt(current) : current);\n    }\n    return result;\n  }\n\n  /**\n   * Decodes an encoded number into it's object representation according to the schema.\n   *\n   * @param {AnyNumber} data encoded number\n   * @returns {UnpackedInt} object representation\n   * @example\n   *\n   * class Person extends BitField {}\n   * Person.fields = [\n   *  { name: 'age', size: 7 },\n   *  { name: 'gender', size: 1 },\n   * ];\n   * Person.decode(41);\n   * //=> { age: 20, gender: 1 }\n   */\n  static decode(data) {\n    const { fields, masks } = this;\n    const result = {};\n    let value = data;\n    for (let i = 0; i < fields.length; i++) {\n      const { name, size } = fields[i];\n      result[name] = Number(value & masks[name]);\n      value >>= size;\n    }\n    return result;\n  }\n\n  /**\n   * Checks if a given set of values or all given pairs of field name and value\n   * are valid according to the schema.\n   *\n   * @param {AnyNumber|UnpackedInt} data pairs of field name and value to check\n   * @returns {boolean} whether all pairs are valid\n   * @example\n   *\n   * class Person extends BitField {}\n   * Person.fields = [\n   *  { name: 'age', size: 7 },\n   *  { name: 'gender', size: 1 },\n   * ];\n   * Person.isValid({age: 100})\n   * //=> true\n   * Person.isValid({age: 100, gender: 3})\n   * //=> false\n   * Person.isValid([100, 1])\n   * //=> true\n   * Person.isValid([100, 3])\n   * //=> false\n   */\n  static isValid(data) {\n    const { masks, fields } = this;\n    const selectedFields = Array.isArray(data)\n      ? fields.map((field, i) => [field.name, data[i]])\n      : Object.entries(data);\n    for (let i = 0; i < selectedFields.length; i++) {\n      const [field, value] = selectedFields[i];\n      if (((value & SIGN_BIT) !== value) || value > masks[field]) return false;\n    }\n    return true;\n  }\n\n  /**\n   * Returns the minimum amount of bits necessary to hold a given number.\n   *\n   * @param {number} number\n   * @returns {number} the amount of bits\n   * @example\n   *\n   * BitField.getMinSize(100)\n   * //=> 7\n   *\n   * BitField.getMinSize(2000)\n   * //=> 11\n   *\n   * BitField.getMinSize(Number.MAX_SAFE_INTEGER)\n   * //=> 53\n   */\n  static getMinSize(number) {\n    if (number < TWO_TO_48) return (Math.log2(number) | 0) + 1;\n    const n = BigInt(number);\n    const [zero, one, two] = [BigInt(0), BigInt(1), BigInt(2)];\n    let high = BigInt(MAX_SIZE);\n    let low = BigInt(48);\n\n    while (high - low > one) {\n      const mid = (high + low) / two;\n      const maskHigh = (one << high) - (one << mid);\n      if ((maskHigh & n) > zero) {\n        low = mid;\n      } else {\n        high = mid;\n      }\n    }\n    return Number(low + one);\n  }\n\n  /**\n   * Prepares the class to handle data according to it's schema provided in `BitField.fields`.\n   * The method is called automatically the first time the constructor is used.\n   *\n   * @returns {void}\n   */\n  static initialize() {\n    // determine total size and if BigInts are required\n    const totalSize = this.fields.reduce((result, field) => result += (field.size || 1), 0);\n    const isBigInt = totalSize > BITWISE_SIZE;\n    const [zero, one, two] = isBigInt ? [BigInt(0), BigInt(1), BigInt(2)] : [0, 1, 2];\n\n    // normalize fields, set masks and offsets\n    const fields = [];\n    const masks = {};\n    const offsets = {};\n    let lastOffset = zero;\n    for (let i = 0; i < this.fields.length; i++) {\n      const field = this.fields[i];\n      const name = field.name || field;\n      const size = isBigInt ? BigInt(field.size || 1) : field.size || 1;\n      masks[name] = (two << size - one) - one;\n      offsets[name] = lastOffset;\n      lastOffset += size;\n      fields.push({ name, size });\n    }\n\n    this.fields = fields;\n    this.size = totalSize;\n    this.mask = two << ((isBigInt ? BigInt(totalSize) : totalSize) - one);\n    this.isBigInt = isBigInt;\n    this.isSafe = totalSize <= MAX_SIZE;\n    this.zero = zero;\n    this.one = one;\n    this.two = two;\n    this.masks = masks;\n    this.offsets = offsets;\n    this.isInitialized = true;\n  }\n\n  /**\n   * Creates an array of values to be used as a matcher\n   * to efficiently match against multiple instances.\n   *\n   * @param {UnpackedInt} matcher an object containing field names and their values\n   * @returns {Matcher} an array of precomputed values\n   */\n  static getMatcher(matcher) {\n    const {\n      masks, offsets, zero, isBigInt,\n    } = this;\n    const fields = Object.keys(matcher);\n    let mask = zero;\n    let value = zero;\n    for (let i = 0; i < fields.length; i++) {\n      const fieldName = fields[i];\n      const fieldMask = masks[fieldName] << offsets[fieldName];\n      const fieldValue = isBigInt ? BigInt(matcher[fieldName]) : matcher[fieldName];\n      value = (value & ~fieldMask) | (fieldValue << offsets[fieldName]);\n      mask |= fieldMask;\n    }\n    return [value, this.mask ^ mask];\n  }\n\n  /**\n   * The static version of `BitField#match`, matches a given value against a precomputed matcher.\n   *\n   * @param {AnyNumber} value a value to check\n   * @param {Matcher} matcher a precomputed set of values\n   * @returns {boolean}\n   *\n   */\n  static match(value, matcher) {\n    return (value & matcher[1]) === matcher[0];\n  }\n\n  /**\n   * Allows iterating over numbers stored in the instance.\n   *\n   * @yields {number}\n   */\n  * [Symbol.iterator]() {\n    const { fields } = this.constructor;\n    for (let i = 0; i < fields.length; i++) {\n      yield this.get(fields[i].name);\n    }\n  }\n}\n\n/** @type {Array<FieldName>|Array<Field>} */\nBitField.fields = Array.from({ length: BITWISE_SIZE }, (e, i) => i);\n\n/** @type {number} */\nBitField.size = BITWISE_SIZE;\n\n/** @type {AnyNumber} */\nBitField.zero = 0;\n\n/** @type {AnyNumber} */\nBitField.one = 1;\n\n/** @type {AnyNumber} */\nBitField.two = 2;\n\n/** @type {Masks} */\nBitField.masks = undefined;\n\n/** @type {AnyNumber} */\nBitField.mask = TWO_TO_31;\n\n/** @type {Masks} */\nBitField.offsets = undefined;\n\n/** @type {boolean} */\nBitField.isBigInt = false;\n\n/** @type {boolean} */\nBitField.isSafe = false;\n\n/** @type {boolean} */\nBitField.isInitialized = false;\n\nmodule.exports = BitField;\n","/**\n * @typedef {Object} BitCoordinates\n * @property {number} bucket row index\n * @property {number} position column index\n */\n\n/**\n * Implements a grid or 2D matrix of bits.\n *\n * @extends Uint16Array\n */\nclass BinaryGrid extends Uint16Array {\n  /**\n   * @param {Object} [options]\n   * @param {number} [options.rows=1] the number of rows\n   * @param {number} [options.columns=16] the number of columns\n   * @param {...*} [args]\n   */\n  constructor(options = {}, ...args) {\n    const { columns = 16, rows = 1 } = options;\n    const offset = BinaryGrid.getOffset(columns);\n    if (args.length) {\n      super(...args);\n    } else {\n      const length = (rows << offset) >> 4;\n      super(length || 1);\n    }\n    Object.defineProperties(this, {\n      offset: { value: offset },\n      columns: { value: columns },\n      rows: { value: rows },\n      lastPosition: { value: Object.seal({ bucket: 0, position: 0 }) },\n    });\n  }\n\n  /**\n   * Returns the value of a bit at given coordinates.\n   *\n   * @param {number} row\n   * @param {number} column\n   * @returns {number}\n   */\n  get(row, column) {\n    const { bucket, position } = this.getBitPosition(row, column);\n    return (this[bucket] >> position) & 1;\n  }\n\n  /**\n   * Sets the value of a bit at given coordinates.\n   * Proxies to TypedArray#set if the first parameter is Array-like.\n   *\n   * @param {number|Collection} row\n   * @param {number} [column]\n   * @param {number} [value]\n   * @returns {BinaryGrid}\n   */\n  set(row, column, value = 1) {\n    if (row.length) {\n      super.set(row, column);\n      return this;\n    }\n    const { bucket, position } = this.getBitPosition(row, column);\n    this[bucket] = (this[bucket] & ~(1 << position)) | (value << position);\n    return this;\n  }\n\n  /**\n   * @private\n   * @param {number} row\n   * @param {number} column\n   * @returns {BitCoordinates}\n   */\n  getBitPosition(row, column) {\n    const index = (row << this.offset) + column;\n    const bucket = index >> 4;\n    this.lastPosition.bucket = bucket;\n    this.lastPosition.position = index - (bucket << 4);\n    return this.lastPosition;\n  }\n\n  /**\n   * @type {Uint16ArrayConstructor}\n   */\n  static get [Symbol.species]() {\n    return Uint16Array;\n  }\n\n  /**\n   * Returns the length of underlying Array required to hold the grid.\n   *\n   * @param {number} rows\n   * @param {number} columns\n   * @returns {number}\n   */\n  static getLength(rows, columns) {\n    return (rows << this.getOffset(columns)) >> 4;\n  }\n\n  /**\n   * @private\n   * @param {number} columns\n   * @returns {number}\n   */\n  static getOffset(columns) {\n    return Math.ceil(Math.log2(columns));\n  }\n}\n\nmodule.exports = BinaryGrid;\n","/**\n * Extends Array to implement the Binary Heap data structure.\n *\n * @extends Array\n */\nclass BinaryHeap extends Array {\n  /**\n   * @param {...*} args\n   */\n  constructor(...args) {\n    super(...args);\n    this.heapify();\n  }\n\n  /**\n   * Restores the binary heap.\n   *\n   * @returns {BinaryHeap}\n   */\n  heapify() {\n    for (let i = this.length >> 1; i >= 0; i--) {\n      this.siftDown(i);\n    }\n    return this;\n  }\n\n  /**\n   * Checks whether the array is a valid binary heap.\n   *\n   * @returns {boolean} whether the array is a valid binary heap\n   */\n  isHeap() {\n    return this.constructor.isHeap(this);\n  }\n\n  /**\n   * Returns the left child of an element at a given index.\n   *\n   * @param {number} index\n   * @returns {*}\n   */\n  left(index) {\n    return this[this.constructor.getLeftIndex(index)];\n  }\n\n  /**\n   * Returns the parent of an element at a given index.\n   *\n   * @param {number} index\n   * @returns {*}\n   */\n  parent(index) {\n    return this[this.constructor.getParentIndex(index)];\n  }\n\n  /**\n   * Adds items to the heap.\n   *\n   * @param {...*} elements\n   * @returns {number}\n   */\n  push(...elements) {\n    for (let i = 0; i < elements.length; i++) {\n      super.push(elements[i]);\n      this.siftUp(this.length - 1);\n    }\n    return this.length;\n  }\n\n  /**\n   * Returns the first (min/max) element of the heap and replaces it with a given element.\n   *\n   * @param {*} element\n   * @returns {*}\n   */\n  replace(element) {\n    const first = this[0];\n    this[0] = element;\n    this.siftDown(0);\n    return first;\n  }\n\n  /**\n   * Returns the right child of an element at a given index.\n   *\n   * @param {number} index\n   * @returns {*}\n   */\n  right(index) {\n    return this[this.constructor.getRightIndex(index)];\n  }\n\n  /**\n   * Extracts the first element of the heap.\n   *\n   * @returns {*}\n   */\n  shift() { // extract min/max\n    if (this.length < 2) return this.pop();\n    const item = this[0];\n    this[0] = this.pop();\n    this.siftDown(0);\n    return item;\n  }\n\n  /**\n   * Changes elements of the heap.\n   *\n   * @param {...*} args\n   * @returns {Array<*>}\n   */\n  splice(...args) {\n    const deletedItems = super.splice(...args);\n    const isSingle = deletedItems.length < 2 && args.length < 4;\n    if (isSingle) {\n      const index = args[0];\n      const isReplacement = args.length === 3;\n      if (isReplacement) {\n        this.update(index);\n      } else {\n        const last = this.pop();\n        super.splice(index, 0, last);\n        this.siftDown(index);\n      }\n    } else {\n      this.heapify();\n    }\n    return deletedItems;\n  }\n\n  /**\n   * Adds elements to the heap.\n   *\n   * @param {...*} items\n   * @returns {number}\n   */\n  unshift(...items) {\n    return this.push(...items);\n  }\n\n  /**\n   * Updates the position of an element inside the heap.\n   *\n   * @param {number} index\n   * @returns {void}\n   */\n  update(index) {\n    const { compare, getLeftIndex } = this.constructor;\n    const parent = this.parent(index);\n    const leftIndex = getLeftIndex(index);\n    if (this.has(leftIndex) && (parent === undefined || compare(parent, this[index]))) {\n      this.siftDown(index);\n    } else {\n      this.siftUp(index);\n    }\n  }\n\n  /**\n   * @private\n   * @param {number} index\n   * @returns {boolean}\n   */\n  has(index) {\n    return index >= 0 && index < this.length;\n  }\n\n  /**\n   * @private\n   * @param {number} start\n   * @returns {void}\n   */\n  siftDown(start) {\n    const { getRightIndex, getLeftIndex, compare } = this.constructor;\n    let index = start;\n    let leftIndex = getLeftIndex(index);\n    let rightIndex = getRightIndex(index);\n    let nextIndex;\n    while (this.has(leftIndex)) {\n      if (this.has(rightIndex) && compare(this[rightIndex], this[leftIndex])) {\n        nextIndex = rightIndex;\n      } else {\n        nextIndex = leftIndex;\n      }\n\n      if (compare(this[index], this[nextIndex])) break;\n      [this[index], this[nextIndex]] = [this[nextIndex], this[index]];\n      index = nextIndex;\n      leftIndex = getLeftIndex(index);\n      rightIndex = getRightIndex(index);\n    }\n  }\n\n  /**\n   * @private\n   * @param {number} start\n   * @returns {void}\n   */\n  siftUp(start) {\n    const { getParentIndex, compare } = this.constructor;\n    let index = start;\n    let parentIndex = getParentIndex(index);\n    while (this.has(parentIndex) && !compare(this[parentIndex], this[index])) {\n      [this[index], this[parentIndex]] = [this[parentIndex], this[index]];\n      index = parentIndex;\n      parentIndex = getParentIndex(index);\n    }\n  }\n\n  /**\n   * @private\n   */\n  static get [Symbol.species]() {\n    return Array;\n  }\n\n  /**\n   * The comparator function used by the heap.\n   *\n   * @param {*} a\n   * @param {*} b\n   * @returns {boolean}\n   */\n  static compare(a, b) {\n    return a < b;\n  }\n\n  /**\n   * Creates a new BinaryHeap from a given array-like object.\n   *\n   * @param {*} arrayLike an array-like object to convert to a heap\n   * @param {Function} mapFn a map function to call on every element of the array\n   * @param {Object} thisArg the value to use as `this` when invoking the `mapFn`\n   * @returns {SortedCollection} a new BinaryHeap\n   */\n  static from(arrayLike, mapFn, thisArg) {\n    return super.from(arrayLike, mapFn, thisArg).heapify();\n  }\n\n  /**\n   * @private\n   * @param {number} index\n   * @returns {number}\n   */\n  static getLeftIndex(index) {\n    return (index << 1) + 1;\n  }\n\n  /**\n   * @private\n   * @param {number} index\n   * @returns {number}\n   */\n  static getParentIndex(index) {\n    return (index - 1) >> 1;\n  }\n\n  /**\n   * @private\n   * @param {number} index\n   * @returns {number}\n   */\n  static getRightIndex(index) {\n    return (index << 1) + 2;\n  }\n\n  /**\n   * Checks if a given collection is a valid binary heap.\n   *\n   * @param {Collection} heap\n   * @returns {boolean}\n   */\n  static isHeap(heap) {\n    for (let i = heap.length - 1; i > -1; i--) {\n      const parentIndex = this.getParentIndex(i);\n      if (parentIndex < 0) break;\n      if (!this.compare(heap[parentIndex], heap[i])) return false;\n    }\n    return true;\n  }\n\n  /**\n   * Creates a new BinaryHeap with a variable number of arguments,\n   * regardless of number or type of the arguments.\n   *\n   * @param {...*} elements the elements of which to create the heap\n   * @returns {SortedCollection} the new BinaryHeap\n   */\n  static of(...elements) {\n    return super.of(...elements).heapify();\n  }\n}\n\nmodule.exports = BinaryHeap;\n","const BinaryGrid = require('./binary-grid');\nconst BinaryHeap = require('./binary-heap');\n\n/**\n * @private\n * @extends BinaryHeap\n */\nclass VertexHeap extends BinaryHeap {\n  static compare(a, b) {\n    return a.w < b.w;\n  }\n}\n\n/**\n * @typedef {UnweightedAdjacencyList | UnweightedAdjacencyMatrix\n    | WeightedAdjacencyList | WeightedAdjacencyMatrix} AdjacencyStructure\n */\n\n/**\n * Creates a Graph class extending a given adjacency structure.\n *\n * @param {AdjacencyStructure} Base\n * @param {boolean} [undirected=false]\n * @returns {Graph}\n */\nfunction GraphMixin(Base, undirected = false) {\n  /**\n   * Extends an adjacency list/matrix structure and provides methods for traversal (BFS, DFS),\n   * pathfinding (Dijkstra, Bellman-Ford), spanning tree construction (BFS, Prim), etc.\n   *\n   * @extends AdjacencyStructure\n   */\n  class Graph extends Base {\n    /**\n     * @param {Object} options\n     * @param {number} options.vertices\n     * @param {number} [options.edges]\n     * @param {number} [options.pad]\n     * @param {...*} args\n     */\n    constructor(options, ...args) {\n      super(options, ...args);\n      const colors = new BinaryGrid({ rows: 2, columns: options.vertices });\n      Object.defineProperties(this, {\n        colors: { value: colors },\n      });\n    }\n\n    /**\n     * Checks if a vertex is entered during a traversal.\n     *\n     * @param {number} vertex the vertex\n     * @returns {boolean}\n     */\n    isGray(vertex) {\n      return !!this.colors.get(0, vertex);\n    }\n\n    /**\n     * Marks a vertex as entered during a traversal.\n     *\n     * @param {number} vertex the vertex\n     * @returns {Graph}\n     */\n    setGray(vertex) {\n      this.colors.set(0, vertex);\n      return this;\n    }\n\n    /**\n     * Checks if a vertex has been fully processed during a traversal.\n     *\n     * @param {number} vertex the vertex\n     * @returns {boolean}\n     */\n    isBlack(vertex) {\n      return !!this.colors.get(1, vertex);\n    }\n\n    /**\n     * Marks a vertex as fully processed during a traversal.\n     *\n     * @param {number} vertex the vertex\n     * @returns {Graph}\n     */\n    setBlack(vertex) {\n      this.colors.set(1, vertex);\n      return this;\n    }\n\n    /**\n     * Resets all coloring of vertices done during traversals.\n     *\n     * @private\n     * @returns {Graph}\n     */\n    resetColors() {\n      this.colors.fill(0);\n      return this;\n    }\n\n    /**\n     * Does a Breadth-First or Depth-First traversal of the graph.\n     *\n     * @generator\n     * @param {boolean} [isDFS=false] whether to do DFS traversal, does BFS otherwise\n     * @param {number} [start=0] the vertex to start at\n     * @param {boolean} [gray=true] whether to return vertices upon entering\n     * @param {boolean} [white=false] whether to return edges upon first encountering\n     * @param {boolean} [black=false] whether to return vertices after processing\n     * @yields {number} the vertex at each step\n     */\n    * traverse(isDFS, start = 0, gray = true, white, black) {\n      this.resetColors();\n      const processing = [start];\n      const [push, pull] = isDFS ? ['push', 'pop'] : ['push', 'shift'];\n      while (processing.length) {\n        const vertex = processing[pull]();\n        this.setGray(vertex);\n        if (gray) yield vertex;\n        for (const edge of this.outEdges(vertex)) {\n          if (!this.isGray(edge)) {\n            processing[push](edge);\n          }\n          if (white) yield edge;\n        }\n        this.setBlack(vertex);\n        if (black) yield vertex;\n      }\n    }\n\n    /**\n     * Checks whether the graph is acyclic.\n     *\n     * @returns {boolean}\n     */\n    isAcyclic() {\n      for (const vertex of this.traverse(true, 0, false, true)) {\n        if (this.isGray(vertex)) return false;\n      }\n      return true;\n    }\n\n    /**\n     * Returns a list of vertexes sorted topologically.\n     *\n     * @returns {Array<number>}\n     */\n    topologicalSort() {\n      return [...this.traverse(true, 0, false, false, true)];\n    }\n\n    /**\n     * Returns a list of vertices along the shortest path between two given vertices.\n     *\n     * @param {number} start the starting vertex\n     * @param {number} end the ending vertex\n     * @param {boolean} [isAcyclic=false] whether the graph is acyclic\n     * @param {boolean} [isNonNegative=false] whether all edges are non-negative\n     * @returns {Array<number>}\n     */\n    path(start, end, isAcyclic, isNonNegative) {\n      const { weighted } = this.constructor;\n      const { vertices } = this;\n      const predecessors = new Array(vertices).fill(-1);\n      const distances = new Array(vertices).fill(Infinity);\n      const isFound = !weighted ? this.searchUnweighted(start, end, predecessors)\n        : isAcyclic ? this.searchTopological(start, end, distances, predecessors)\n          : isNonNegative ? this.searchDijkstra(start, end, distances, predecessors)\n            : this.searchBellmanFord(start, end, distances, predecessors);\n      if (!isFound) return [];\n      const path = [];\n      let last = end;\n      while (~last) {\n        path.unshift(last);\n        last = predecessors[last];\n      }\n      return path;\n    }\n\n    /**\n     * For unweighted graphs.\n     *\n     * @private\n     * @param {number} start the starting vertex\n     * @param {number} [end] the ending vertex\n     * @param {Array<number>} predecessors\n     * @returns {boolean}\n     */\n    searchUnweighted(start, end, predecessors) {\n      let lastPredecessor = start;\n      let isFound = false;\n      for (const vertex of this.traverse(false, start, true, true)) {\n        if (!this.isGray(vertex)) {\n          predecessors[vertex] = lastPredecessor;\n        } else {\n          lastPredecessor = vertex;\n        }\n        if (vertex === end) {\n          isFound = true;\n          break;\n        }\n      }\n      return isFound;\n    }\n\n    /**\n     * For DAGs only.\n     *\n     * @private\n     * @param {number} start\n     * @param {number} end\n     * @param {Array<number>} distances\n     * @param {Array<number>} predecessors\n     * @returns {boolean}\n     */\n    searchTopological(start, end, distances, predecessors) {\n      distances[start] = 0;\n      let lastPredecessor = start;\n      let isFound = false;\n      for (const vertex of this.traverse(true, start, true, true)) {\n        if (!this.isGray(vertex)) {\n          const weight = this.getEdge(lastPredecessor, vertex);\n          if (distances[vertex] > distances[lastPredecessor] + weight) {\n            distances[vertex] = distances[lastPredecessor] + weight;\n            predecessors[vertex] = lastPredecessor;\n          }\n        } else if (!this.isBlack(vertex)) {\n          lastPredecessor = vertex;\n        }\n        if (vertex === end) {\n          isFound = true;\n        }\n      }\n      return isFound;\n    }\n\n    /**\n     * For non-negative edges.\n     *\n     * @private\n     * @param {number} start\n     * @param {number} end\n     * @param {Array<number>} distances\n     * @param {Array<number>} predecessors\n     * @returns {boolean}\n     */\n    searchDijkstra(start, end, distances, predecessors) {\n      this.resetColors();\n      const heap = new VertexHeap();\n      distances[start] = 0;\n      heap.push({ e: start, w: this[start] });\n      let isFound = false;\n      while (heap.length) {\n        const vertex = heap.shift();\n        if (this.isGray(vertex.e)) continue;\n        this.setGray(vertex.e);\n        for (const edge of this.outEdges(vertex.e)) {\n          const weight = this.getEdge(vertex.e, edge);\n          const distance = distances[vertex.e] + weight;\n          if (distance < distances[edge]) {\n            distances[edge] = distance;\n            predecessors[edge] = vertex.e;\n            heap.push({ e: edge, w: distance });\n          }\n          if (edge === end) {\n            isFound = true;\n          }\n        }\n      }\n      return isFound;\n    }\n\n    /**\n     * For all.\n     *\n     * @private\n     * @param {number} start\n     * @param {number} end\n     * @param {Array<number>} distances\n     * @param {Array<number>} predecessors\n     * @returns {boolean}\n     */\n    searchBellmanFord(start, end, distances, predecessors) {\n      const { vertices } = this;\n      distances[start] = 0;\n      let isFound = false;\n      for (let i = 0; i < vertices; i++) {\n        for (const edge of this.outEdges(i)) {\n          const weight = this.getEdge(i, edge);\n          const distance = distances[i] + weight;\n          if (distances[edge] > distance) {\n            distances[edge] = distance;\n            predecessors[edge] = i;\n            if (edge === end) {\n              isFound = true;\n            }\n          }\n        }\n      }\n      return isFound;\n    }\n\n    /**\n     * Returns a minimal spanning tree of the graph.\n     * Uses the Prim's algorithm for weighted graphs and BFS tree for unweighted graphs.\n     *\n     * @param {number} [start=0]\n     * @returns {Array<number>}\n     */\n    tree(start = 0) {\n      const { weighted } = this.constructor;\n      const { vertices } = this;\n      const predecessors = new Array(vertices).fill(-1);\n      if (!weighted) {\n        this.searchUnweighted(start, undefined, predecessors);\n        return predecessors;\n      }\n      this.resetColors();\n      const distances = new Array(vertices).fill(Infinity);\n      const heap = new VertexHeap();\n      distances[start] = 0;\n      heap.push({ e: start, w: this[0] });\n      while (heap.length) {\n        const vertex = heap.shift();\n        if (this.isGray(vertex.e)) continue;\n        this.setGray(vertex.e);\n        for (const edge of this.outEdges(vertex.e)) {\n          const weight = this.getEdge(vertex.e, edge);\n          if (this.isGray(edge) || weight > distances[edge]) continue;\n          distances[edge] = weight;\n          predecessors[edge] = vertex.e;\n          heap.push({ e: edge, w: weight });\n        }\n      }\n      return predecessors;\n    }\n  }\n\n  Graph.undirected = undirected;\n\n  return Graph;\n}\n\nmodule.exports = GraphMixin;\n","/**\n * @typedef {Int8ArrayConstructor |\n * Int8ArrayConstructor |\n * Uint8ArrayConstructor |\n * Uint8ClampedArrayConstructor |\n * Int16ArrayConstructor |\n * Uint16ArrayConstructor |\n * Int32ArrayConstructor |\n * Uint32ArrayConstructor |\n * Float32ArrayConstructor |\n * Float64ArrayConstructor} TypedArrayConstructor\n */\n\n/**\n * @typedef {ArrayConstructor|TypedArrayConstructor} CollectionConstructor\n */\n\n/**\n * @typedef {Int8Array |\n * Uint8Array |\n * Uint8ClampedArray |\n * Int16Array |\n * Uint16Array |\n * Int32Array |\n * Uint32Array |\n * Float32Array |\n * Float64Array} TypedArray\n */\n\n/**\n * @typedef {Array|TypedArray} Collection\n */\n\n/**\n * @typedef {Object} Coordinates\n * @property {number} row row index\n * @property {number} column column index\n */\n\n/**\n * Creates a Grid class extending a given Array-like class.\n *\n * @param {CollectionConstructor} Base\n * @returns {Grid}\n * @example\n *\n * const ArrayGrid = Grid(Array);\n */\nfunction GridMixin(Base) {\n  /**\n   * Extends built-in indexed collections to handle 2 dimensional data.\n   *\n   * @extends CollectionConstructor\n   */\n  class Grid extends Base {\n    /**\n     * Passes all arguments to the Base class except if called with a special set of grid options,\n     * in that case creates and empty grid of specified parameters.\n     *\n     * @param {Object} [options]\n     * @param {number} [options.rows=1] the number of rows\n     * @param {number} [options.columns=2] the number of columns\n     * @param {*} [options.pad=0] the initial value of cells\n     * @param {...*} [args]\n     * @example\n     *\n     * new ArrayGrid('a')\n     * //=> ArrayGrid ['a']\n     *\n     * new ArrayGrid(2)\n     * //=> ArrayGrid [undefined, undefined]\n     *\n     * new ArrayGrid({ rows: 3, columns: 2 })\n     * //=> ArrayGrid [0, 0, 0, 0, 0, 0]\n     *\n     * new ArrayGrid({ rows: 3, columns: 2, pad: 1 })\n     * //=> ArrayGrid [1, 1, 1, 1, 1, 1]\n     */\n    constructor(options = {}, ...args) {\n      const { columns = 2, rows = 1, pad = 0 } = options;\n      const offset = Grid.getOffset(columns);\n      if (args.length) {\n        super(...args);\n      } else {\n        const length = rows << offset;\n        super(length);\n        this.fill(pad);\n      }\n      Object.defineProperties(this, {\n        offset: { value: offset, writable: true },\n        pad: { value: pad, writable: true },\n        lastCoordinates: { value: Object.seal({ row: 0, column: 0 }) },\n      });\n    }\n\n    /**\n     * Specifies the number of columns of the grid.\n     *\n     * @param {number} columns\n     * @returns {void}\n     */\n    set columns(columns) {\n      this.offset = Grid.getOffset(columns);\n    }\n\n    /**\n     * Number of columns in the grid.\n     * @type {number}\n     */\n    get columns() {\n      return 1 << this.offset;\n    }\n\n    /**\n     * Number of rows in the grid.\n     * @type {number}\n     */\n    get rows() {\n      return this.length >> this.offset;\n    }\n\n    /**\n     * Returns an array index of an element at given coordinates.\n     *\n     * @param {number} row\n     * @param {number} column\n     * @returns {*}\n     * @example\n     *\n     * const a = ArrayGrid({ rows: 3, columns: 2, pad: 3});\n     * a.get(1, 0);\n     * //=> 2\n     */\n    getIndex(row, column) {\n      return (row << this.offset) + column;\n    }\n\n    /**\n     * Returns an element from given coordinates.\n     *\n     * @param {number} row\n     * @param {number} column\n     * @returns {*}\n     * @example\n     *\n     * const a = ArrayGrid({ rows: 3, columns: 2, pad: 3});\n     * a.get(0, 1);\n     * //=> 3\n     */\n    get(row, column) {\n      return this[this.getIndex(row, column)];\n    }\n\n    /**\n     * Sets the element at given coordinates.\n     * Proxies to TypedArray#set if the first parameter is Array-like\n     * and the grid is based on a TypedArray.\n     *\n     * @param {number|Collection} row\n     * @param {number} [column]\n     * @param {*} [value]\n     * @returns {Grid} the instance\n     * @example\n     *\n     * const a = ArrayGrid({ rows: 3, columns: 2, pad: 3});\n     * a.set(0, 1, 5);\n     * a.get(0, 1);\n     * //=> 5\n     */\n    set(row, column, value) {\n      if (row.length && super.set) {\n        super.set(row, column);\n        return this;\n      }\n      this[this.getIndex(row, column)] = value;\n      return this;\n    }\n\n    /**\n     * Implements in-place replacement of the grid elements if it's based on Array.\n     * Proxies to TypedArray#set if the grid is based on a TypedArray.\n     *\n     * @param {Collection} array\n     * @param {number} [offset]\n     * @returns {void}\n     */\n    setArray(array, offset) {\n      if (super.set) {\n        super.set(array, offset);\n      } else {\n        this.length = array.length;\n        for (let i = 0; i < array.length; i++) {\n          this[i] = array[i];\n        }\n      }\n    }\n\n    /**\n     * Gets coordinates of an element at specified index.\n     *\n     * @param {number} index\n     * @returns {Coordinates} coordinates\n     * @example\n     * const a = ArrayGrid({ rows: 3, columns: 2, pad: 3});\n     * a.getCoordinates(1);\n     * //=> [0, 1]\n     * a.getCoordinates(2);\n     * //=> [1, 0]\n     */\n    getCoordinates(index) {\n      this.lastCoordinates.row = index >> this.offset;\n      this.lastCoordinates.column = index - (this.lastCoordinates.row << this.offset);\n      return this.lastCoordinates;\n    }\n\n    /**\n     * Returns an array of arrays where each nested array correspond to a row in the grid.\n     *\n     * @param {boolean} [withPadding=false] whether to remove padding from the end of the rows\n     * @returns {Array<Array<*>>}\n     * @example\n     *\n     * const a = ArrayGrid({ rows: 3, columns: 2, pad: 3});\n     * a.toArrays();\n     * //=> [[3, 3], [3, 3], [3, 3]]\n     */\n    toArrays(withPadding) {\n      const { rows, columns } = this;\n      const begin = new Uint32Array(rows).map((b, i) => i << this.offset);\n      const result = new Array(rows);\n\n      for (let i = 0; i < rows; i++) {\n        const beginning = begin[i];\n        if (withPadding) {\n          result[i] = this.slice(beginning, beginning + columns);\n          continue;\n        }\n        for (let j = beginning + columns - 1; j >= beginning; j--) {\n          if (this[j] !== this.pad) {\n            result[i] = this.slice(beginning, j + 1);\n            break;\n          }\n        }\n      }\n\n      return result;\n    }\n\n    /**\n     * @type {CollectionConstructor}\n     */\n    static get [Symbol.species]() {\n      return Base;\n    }\n\n    /**\n     * Returns the length of underlying Array required to hold the grid.\n     *\n     * @param {number} rows\n     * @param {number} columns\n     * @returns {number}\n     */\n    static getLength(rows, columns) {\n      return rows << this.getOffset(columns);\n    }\n\n    /**\n     * @private\n     * @param {number} columns\n     * @returns {number}\n     */\n    static getOffset(columns) {\n      return Math.ceil(Math.log2(columns));\n    }\n\n    /**\n     * Creates a grid from an array of arrays.\n     *\n     * @param {Array<Array<*>>} arrays\n     * @param {*} [pad=0] the value to pad the arrays to create equal sized rows\n     * @returns {Grid}\n     *\n     * const a = ArrayGrid.from([[1, 2], [3], [4, 5, 6]])\n     * //=> ArrayGrid [1, 2, 0, 0, 3, 0, 0, 0, 4, 5, 6, 0]\n     * a.get(1, 0);\n     * //=> 3\n     * a.get(2, 1);\n     * //=> 5\n     */\n    static fromArrays(arrays, pad = 0) {\n      const rows = arrays.length;\n\n      // find longest array to get the column size\n      let columns = arrays[0].length; // if !arrays[0].length\n      for (let i = 0; i < rows; i++) {\n        if (arrays[i].length > columns) columns = arrays[i].length;\n      }\n      const offset = this.getOffset(columns);\n      columns = 1 << offset;\n\n      // create grid of the required length\n      const grid = new this({ rows, columns, pad });\n\n      // fill the grid with values from arrays\n      for (let i = 0; i < rows; i++) {\n        for (let j = 0; j < arrays[i].length; j++) {\n          grid.set(i, j, arrays[i][j]);\n        }\n      }\n\n      return grid;\n    }\n  }\n\n  return Grid;\n}\n\nmodule.exports = GridMixin;\n","/**\n * Uses Uint32Array as a vector or array of bits.\n *\n * @extends Uint32Array\n */\nclass BitArray extends Uint32Array {\n  /**\n   * @param {number} [size=32] the number of bits\n   * @param {...*} [args]\n   */\n  constructor(size = 32, ...args) {\n    if (size.length || size instanceof ArrayBuffer) {\n      super(size, ...args);\n    } else {\n      super(new.target.getLength(size));\n    }\n    Object.defineProperties(this, {\n      lastPosition: { value: Object.seal({ bucket: 0, position: 0 }) },\n    });\n  }\n\n  /**\n   * Returns the bit value at a given index.\n   *\n   * @param {number} index\n   * @returns {number}\n   */\n  getBit(index) {\n    const { bucket, position } = this.getBitPosition(index);\n    return (this[bucket] >> position) & 1;\n  }\n\n  /**\n   * Sets the bit value at a given index.\n   *\n   * @param {number} index\n   * @param {number} [value=1]\n   * @returns {BitArray}\n   */\n  setBit(index, value = 1) {\n    const { bucket, position } = this.getBitPosition(index);\n    this[bucket] = (this[bucket] & ~(1 << position)) | (value << position);\n    return this;\n  }\n\n  /**\n   * Returns the amount of available bits in the array.\n   *\n   * @type {number}\n   */\n  get size() {\n    return this.length << 5;\n  }\n\n  /**\n   * @protected\n   * @param {number} index\n   * @returns {BitCoordinates}\n   */\n  getBitPosition(index) {\n    const bucket = index >> 5;\n    this.lastPosition.bucket = bucket;\n    this.lastPosition.position = index - (bucket << 5);\n    return this.lastPosition;\n  }\n\n  /**\n   * Returns the length of underlying TypedArray required to hold the bit array.\n   *\n   * @param {number} size\n   * @returns {number}\n   */\n  static getLength(size) {\n    return Math.ceil(size / 32);\n  }\n\n  /**\n   * @type {Uint32ArrayConstructor}\n   */\n  static get [Symbol.species]() {\n    return Uint32Array;\n  }\n}\n\nmodule.exports = BitArray;\n","const log2 = {\n  1: 0,\n  2: 1,\n  4: 2,\n  8: 3,\n  16: 4,\n  32: 5,\n  64: 6,\n  128: 7,\n  256: 8,\n  512: 9,\n  1024: 10,\n  2048: 11,\n  4096: 12,\n  8192: 13,\n  16384: 14,\n  32768: 15,\n  65536: 16,\n  131072: 17,\n  262144: 18,\n  524288: 19,\n  1048576: 20,\n  2097152: 21,\n  4194304: 22,\n  8388608: 23,\n  16777216: 24,\n  33554432: 25,\n  67108864: 26,\n  134217728: 27,\n  268435456: 28,\n  536870912: 29,\n  1073741824: 30,\n  2147483648: 31,\n};\n\n/**\n * Counts set bits in a given number.\n *\n * @param {number} value\n * @returns {number}\n */\nfunction popCount32(value) {\n  const a = value - ((value >> 1) & 0x55555555);\n  const b = (a & 0x33333333) + ((a >> 2) & 0x33333333);\n  return ((b + (b >> 4) & 0xF0F0F0F) * 0x1010101) >> 24;\n}\n\n/**\n * Returns the index of the Least Significant Bit in a number.\n *\n * @param {number} value\n * @returns {number}\n */\nfunction getLSBIndex(value) {\n  if (value === 2147483648) return 31;\n  return log2[value & -value];\n}\n\n/**\n * Returns a multiple of a base number that is greater or equal to a given value.\n *\n * @param {number} value\n * @param {number} base\n * @returns {number}\n */\nfunction getGTEMultiple(value, base) {\n  return ((value - 1) | (base - 1)) + 1;\n}\n\nmodule.exports = {\n  log2,\n  popCount32,\n  getLSBIndex,\n  getGTEMultiple,\n};\n","const BitArray = require('./bit-array');\nconst utilities = require('./utilities');\n\n/**\n * Manages availability of objects in object pools.\n *\n * @extends BitArray\n */\nclass Pool extends BitArray {\n  /**\n   * @param {number} size the size of the pool\n   */\n  constructor(size) {\n    super(size);\n    this.fill(4294967295);\n    Object.defineProperties(this, {\n      nextAvailable: { value: 0, writable: true },\n    });\n  }\n\n  /**\n   * Gets the next available index in the pool.\n   *\n   * @returns {number} the next available index\n   */\n  get() {\n    const { nextAvailable } = this;\n    if (!~nextAvailable) return -1;\n    const record = this[nextAvailable];\n    const index = utilities.getLSBIndex(record);\n    this[nextAvailable] &= ~(1 << index);\n\n    // record is full, find next empty\n    if (this[nextAvailable] === 0) {\n      this.nextAvailable = -1;\n      for (let i = 0; i < this.length; i++) {\n        if (this[i] !== 0) {\n          this.nextAvailable = i;\n          break;\n        }\n      }\n    }\n\n    return (nextAvailable << 5) + index;\n  }\n\n  /**\n   * Makes a given index available.\n   *\n   * @param {number} index index to be freed\n   * @returns {void}\n   */\n  free(index) {\n    const { bucket, position } = this.getBitPosition(index);\n    this[bucket] |= 1 << position;\n    this.nextAvailable = bucket;\n  }\n}\n\nmodule.exports = Pool;\n","const BitArray = require('./bit-array');\nconst utilities = require('./utilities');\n\n/**\n * A bit array that supports constant time rank and O(logN) time select operations.\n *\n * @extends BitArray\n */\nclass RankedBitArray extends BitArray {\n  /**\n   * Sets the bit value at a given index.\n   *\n   * @param {number} index\n   * @param {number} [value=1]\n   * @returns {RankedBitArray}\n   */\n  setBit(index, value = 1) {\n    super.setBit(index, value);\n    const change = value || -1;\n    for (let i = (this.length >> 1) + this.lastPosition.bucket; i < this.length; i++) {\n      this[i] += change;\n    }\n    return this;\n  }\n\n  /**\n   * Returns the amount of available bits in the array.\n   *\n   * @type {number}\n   */\n  get size() {\n    return (this.length >> 1) << 5;\n  }\n\n  /**\n   * Returns the rank of a bit at a given index.\n   *\n   * @param {number} index\n   * @returns {number}\n   */\n  rank(index) {\n    const { bucket, position } = this.getBitPosition(index);\n    const value = this[bucket];\n    // mask out following bits\n    const masked = value & ((1 << position) - 1);\n    const localRank = utilities.popCount32(masked);\n    const bucketRank = bucket ? this[(this.length >> 1) + bucket - 1] : 0;\n    return bucketRank + localRank;\n  }\n\n  /**\n   * Returns the select of a bit at a given index.\n   *\n   * @param {number} index\n   * @returns {number}\n   */\n  select(index) {\n    const middle = this.length >> 1;\n    let left = middle;\n    let right = this.length - 1;\n    let bucketRankId = 0;\n    while (left <= right) {\n      bucketRankId = (right + left) >> 1;\n      if (index > this[bucketRankId]) {\n        left = bucketRankId + 1;\n      } else if (index < this[bucketRankId]) {\n        right = bucketRankId - 1;\n      } else if (index === this[bucketRankId - 1]) { // preceded by a duplicate\n        right = bucketRankId - 1;\n      } else {\n        break;\n      }\n    }\n    bucketRankId = index === this[bucketRankId] ? bucketRankId : left;\n\n    if (bucketRankId >= this.length) return -1;\n\n    let rank = bucketRankId > middle ? this[bucketRankId - 1] : 0;\n    const bucket = bucketRankId - middle;\n    let value = this[bucket];\n    while (value) {\n      const position = utilities.getLSBIndex(value);\n      value &= value - 1;\n      rank++;\n      if (rank === index) {\n        return (bucket << 5) + position;\n      }\n    }\n  }\n\n  /**\n   * Returns the length of underlying TypedArray required to hold the bit array.\n   *\n   * @param {number} size\n   * @returns {number}\n   */\n  static getLength(size) {\n    return Math.ceil(size / 32) << 1;\n  }\n}\n\nmodule.exports = RankedBitArray;\n","/**\n * @private\n */\nconst ZERO_CHAR = String.fromCharCode(0);\n\n/**\n * Extends Uint8Array to handle C-like representation of UTF-8 encoded strings.\n *\n * @extends Uint8Array\n */\nclass StringView extends Uint8Array {\n  /**\n   * Iterates over the characters in the StringView.\n   *\n   * @yields {string}\n   * @example\n   * const stringView = StringView.fromString('abc😀');\n   * [...stringView.characters()]\n   * //=> ['a', 'b', 'c', '😀']\n   */\n  * characters() {\n    for (let i = 0; i < this.length; i++) {\n      if (this[i] >> 6 !== 2) {\n        yield this.toChar(i);\n      }\n    }\n  }\n\n  /**\n   * Returns a new string consisting of the single UTF character\n   * located at the specified character index.\n   *\n   * @param {number} [index=0] a character index\n   * @returns {string} a string representing the character\n   * @example\n   * const stringView = StringView.fromString('abc😀');\n   * stringView.charAt(0);\n   * //=> 'a'\n   * stringView.charAt(3);\n   * //=> '😀'\n   */\n  charAt(index = 0) {\n    return this.toChar(this.getCharStart(index));\n  }\n\n  /**\n   * @private\n   * @param {number} index\n   * @returns {number}\n   */\n  getCharEnd(index) {\n    const point = this[index];\n    if (point < 0x80) return index;\n    switch ((point & 0xF0) >> 4) {\n      case 0xF: return index + 3;\n      case 0xE: return index + 2;\n      case 0xD:\n      case 0xC: return index + 1;\n      default: return -1;\n    }\n  }\n\n  /**\n   * @private\n   * @param {number} index\n   * @param {number} [startCharIndex=-1]\n   * @param {number} [startIndex=0]\n   * @returns {number}\n   */\n  getCharStart(index, startCharIndex = -1, startIndex = 0) {\n    let current = startCharIndex;\n    for (let i = startIndex; i < this.length; i++) {\n      if (this[i] >> 6 !== 2) current++;\n      if (current === index) return i;\n    }\n    return -1;\n  }\n\n  /**\n   * Performs an in-place replacement within the StringView\n   * of all occurrences of a given pattern with a given replacement.\n   *\n   * @param {Collection} pattern the pattern to be replaced\n   * @param {Collection} replacement the replacement\n   * @returns {StringView}\n   * @example\n   * const stringView = StringView.fromString('abc😀a');\n   * const pattern = StringView.fromString('a');\n   * const replacement = StringView.fromString('d');\n   * stringView.replace(pattern, replacement).toString();\n   * //=> 'dbc😀d'\n   */\n  replace(pattern, replacement) {\n    let position = 0;\n    while (position < this.length) {\n      const currentIndex = this.search(pattern, position);\n      if (!~currentIndex) break;\n      this.set(replacement, currentIndex);\n      position = currentIndex + replacement.length;\n    }\n    return this;\n  }\n\n  /**\n   * Reverses the characters of the StringView in-place.\n   *\n   * @returns {StringView}\n   * @example\n   * const stringView = StringView.fromString('abc😀a');\n   * stringView.reverse().toString();\n   * //=> 'a😀cba'\n   */\n  reverse() {\n    const last = this.length - 1;\n    for (let i = 0, j = last; i < j; i++, j--) {\n      [this[i], this[j]] = [this[j], this[i]];\n    }\n    let j = this.length;\n    while (--j > 0) {\n      switch ((this[j] & 0xF0) >> 4) {\n        case 0xF:\n          [this[j], this[j - 3]] = [this[j - 3], this[j]];\n          [this[j - 1], this[j - 2]] = [this[j - 2], this[j - 1]];\n          j -= 3;\n          break;\n        case 0xE:\n          [this[j], this[j - 2]] = [this[j - 2], this[j]];\n          j -= 2;\n          break;\n        case 0xC:\n        case 0xD:\n          [this[j], this[j - 1]] = [this[j - 1], this[j]];\n          j--;\n          break;\n        default:\n          break;\n      }\n    }\n    return this;\n  }\n\n  /**\n   * Returns the index within the calling StringView\n   * of the first occurrence of the specified value, starting the search at start.\n   * Returns -1 if the value is not found.\n   *\n   * @param {Collection} searchValue the value to search for\n   * @param {number} [fromIndex=0] the index at which to start the search\n   * @returns {number} the index of the first occurrence of the specified value\n   * @example\n   * const stringView = StringView.fromString('abc😀a');\n   * const searchValue = StringView.fromString('😀');\n   * stringView.search(searchValue);\n   * //=> 3\n   */\n  search(searchValue, fromIndex = 0) {\n    if (this.length > 256 && searchValue.length < 32) {\n      return this.searchShiftOr(searchValue, fromIndex);\n    }\n    return this.searchNaive(searchValue, fromIndex);\n  }\n\n  /**\n   * @private\n   * @param {Collection} searchValue\n   * @param {number} start\n   * @returns {number}\n   */\n  searchNaive(searchValue, start) {\n    const wordLength = searchValue.length;\n    const max = this.length - wordLength;\n    outer: for (let i = start; i <= max; i++) {\n      for (let j = 0; j < wordLength; j++) {\n        if (this[i + j] !== searchValue[j]) {\n          continue outer;\n        }\n      }\n      return i;\n    }\n    return -1;\n  }\n\n  /**\n   * @private\n   * @param {Collection} searchValue\n   * @param {number} start\n   * @returns {number}\n   */\n  searchShiftOr(searchValue, start) {\n    const { masks } = this.constructor;\n    const m = searchValue.length;\n    const m1 = 1 << m;\n    masks.fill(-1);\n    let r = -2;\n    for (let i = 0; i < m; i++) {\n      masks[searchValue[i]] &= ~(1 << i);\n    }\n    for (let i = start; i < this.length; i++) {\n      r |= masks[this[i]];\n      r <<= 1;\n      if ((r & m1) === 0) {\n        return (i - m) + 1;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * The amount of UTF characters in the StringView.\n   *\n   * @type {number}\n   * @example\n   * const stringView = StringView.fromString('abc😀a');\n   * stringView.size\n   * //=> 5\n   * stringView.length\n   * //=> 8\n   */\n  get size() {\n    let size = 0;\n    for (let i = 0; i < this.length; i++) {\n      if ((this[i] >> 6) !== 2) size++;\n    }\n    return size;\n  }\n\n  /**\n   * Returns a string of characters between the start and end\n   * character indexes, or to the end of the string.\n   *\n   * @param {number} indexStart the character index of the first character to include\n   * @param {number} [indexEnd] the character index of the first character to exclude\n   * @returns {string} a new string containing the specified part of the given string\n   * @example\n   * const stringView = StringView.fromString('abc😀a');\n   * stringView.substring(0, 4);\n   * //=> 'abc😀'\n   * stringView.substring(2);\n   * //=> 'c😀a'\n   */\n  substring(indexStart, indexEnd = this.size) {\n    const start = this.getCharStart(indexStart);\n    const end = this.getCharStart(indexEnd, indexStart, start);\n    const sub = this.subarray(start, this.getCharEnd(end) + 1);\n    return this.constructor.decoder.decode(sub);\n  }\n\n  /**\n   * @private\n   * @param {number} index\n   * @returns {string}\n   */\n  toChar(index) {\n    const point = this[index];\n    if (point < 0x80) return String.fromCodePoint(point);\n    switch ((point & 0xF0) >> 4) {\n      case 0xF: return String.fromCodePoint(((point & 0x07) << 18)\n        | ((this[index + 1] & 0x3F) << 12)\n        | ((this[index + 2] & 0x3F) << 6)\n        | ((this[index + 3] & 0x3F)));\n      case 0xE: return String.fromCodePoint(((point & 0x0F) << 12)\n        | ((this[index + 1] & 0x3F) << 6)\n        | ((this[index + 2] & 0x3F)));\n      case 0xD:\n      case 0xC: return String.fromCodePoint(((point & 0x1F) << 6)\n        | ((this[index + 1] & 0x3F)));\n      default: return '';\n    }\n  }\n\n  /**\n   * Returns a string representation of the StringView.\n   *\n   * @returns {string}\n   * @example\n   * const stringView = StringView.fromString('abc😀a');\n   * stringView.toString();\n   * //=> 'abc😀a'\n   * stringView == 'abc😀a'\n   * //=> true\n   */\n  toString() {\n    const decoded = this.constructor.decoder.decode(this);\n    const end = decoded.indexOf(ZERO_CHAR);\n    return ~end ? decoded.slice(0, end) : decoded;\n  }\n\n  /**\n   * Returns a StringView without trailing zeros.\n   *\n   * @returns {StringView}\n   * @example\n   * const stringView = StringView.fromString('abc😀a', 10);\n   * stringView\n   * //=> StringView [ 97, 98, 99, 240, 159, 152, 128, 97, 0, 0 ]\n   * stringView.trim();\n   * //=> StringView [ 97, 98, 99, 240, 159, 152, 128, 97 ]\n   */\n  trim() {\n    const end = this.indexOf(0);\n    return (~end) ? this.subarray(0, end) : this;\n  }\n\n  /**\n   * Creates a StringView from a string.\n   * todo use TextEncoder.encodeInto when supported by Node.js (FF supports already)\n   *\n   * @param {string} string the string to encode\n   * @param {number} [size] the size of the StringView in bytes\n   * @returns {StringView} a new StringView\n   * @example\n   * const stringView = StringView.fromString('abc😀a');\n   * stringView\n   * //=> StringView [ 97, 98, 99, 240, 159, 152, 128, 97 ]\n   *\n   * const stringView = StringView.fromString('abc😀a', 10);\n   * stringView\n   * //=> StringView [ 97, 98, 99, 240, 159, 152, 128, 97, 0, 0 ]\n   */\n  static fromString(string, size) {\n    const encoded = this.encoder.encode(string);\n    if (size) {\n      const view = new this(size);\n      view.set(encoded);\n      return view;\n    }\n    return new this(encoded.buffer);\n  }\n\n  /**\n   * Returns the size in bytes of a given string without encoding it.\n   *\n   * @param {string} string the string to check\n   * @returns {number} the size in bytes\n   * @example\n   * const stringView = StringView.getByteSize('abc😀a');\n   * //=> 8\n   */\n  static getByteSize(string) {\n    let size = 0;\n    for (let i = 0; i < string.length; i++) {\n      const code = string.codePointAt(i);\n      if (code < 0x0080) size += 1; // 1-byte\n      else if (code < 0x0800) size += 2; // 2-byte\n      else if (code < 0x10000) size += 3; // 3-byte\n      else { // 4-byte\n        size += 4;\n        i++;\n      }\n    }\n    return size;\n  }\n}\n\n/**\n * @type Int8Array\n * @private\n */\nStringView.masks = new Int8Array(256).fill(-1);\n\n/**\n * @type TextEncoder\n */\nStringView.encoder = new TextEncoder();\n\n/**\n * @type TextDecoder\n */\nStringView.decoder = new TextDecoder();\n\nmodule.exports = StringView;\n","const utilities = require('./utilities');\n\n/**\n* @typedef {('Int8' | 'Uint8' | 'Int16' | 'Uint16'\n * | 'Int32' | 'Uint32' | 'Float32' | 'Float64'\n * | 'BigInt64' | 'BigUint64' | 'String' )} RecordFieldType\n*/\n\n/**\n * @typedef {Object} RecordField\n * @property {string} name\n * @property {RecordFieldType} type\n * @property {number} [size] the maximum size in bytes for a string type\n * @property {boolean} [littleEndian]\n */\n\nconst StringView = require('./string-view');\n\n/**\n * @private\n */\nconst fieldSizes = {\n  Int8: 1,\n  Uint8: 1,\n  Int16: 2,\n  Uint16: 2,\n  Int32: 4,\n  Uint32: 4,\n  Float32: 4,\n  Float64: 8,\n  BigInt64: 8,\n  BigUint64: 8,\n  String: 0,\n  Int8Array: 0,\n  Uint8Array: 0,\n  Uint8ClampedArray: 0,\n  Int16Array: 0,\n  Uint16Array: 0,\n  Int32Array: 0,\n  Uint32Array: 0,\n  Float32Array: 0,\n  Float64Array: 0,\n  BigInt64Array: 0,\n  BigUint64Array: 0,\n};\n\n/**\n * @private\n */\nconst typedArrays = {\n  Int8Array,\n  Uint8Array,\n  Uint8ClampedArray,\n  Int16Array,\n  Uint16Array,\n  Int32Array,\n  Uint32Array,\n  Float32Array,\n  Float64Array,\n  BigInt64Array,\n  BigUint64Array,\n};\n\n/**\n * Extends DataView to use ArrayBuffer as an array of records or C-like structs.\n *\n * @deprecated\n * @extends DataView\n */\nclass RecordArray extends DataView {\n  /**\n   * @param {Array<RecordField>} fields an array field descriptions\n   * @param {number} [size] the amount of structs in the array,\n   *                        optional if an existing ArrayBuffer is used\n   * @param {ArrayBuffer} [buffer] an existing ArrayBuffer to use for structs\n   * @param {number} [byteOffset] the byteOffset in an existing ArrayBuffer\n   * @param {number} [byteLength] the byteLength in an existing ArrayBuffer\n   * @example\n   * const people = new RecordArray([\n   *   { name: 'age', type: 'Uint8' },\n   *   { name: 'score', type: 'Float32' },\n   * ], 20);\n   *\n   * const cars = new RecordArray([\n   *   { name: 'name', type: 'String', size: 10 },\n   *   { name: 'speed', type: 'Float32' }\n   * ], 100)\n   */\n  constructor(fields, size = 1, buffer, byteOffset, byteLength) {\n    const lastField = fields[fields.length - 1];\n    if (!lastField.end) new.target.initialize(fields);\n    const lastOffset = lastField.end;\n    const offset = Math.ceil(Math.log2(lastOffset));\n    const data = buffer || new ArrayBuffer(size << offset);\n    super(data, byteOffset, byteLength);\n\n    const schema = {};\n    for (let i = 0; i < fields.length; i++) {\n      schema[fields[i].name] = fields[i];\n    }\n\n    Object.defineProperties(this, {\n      fields: { value: fields },\n      offset: { value: offset },\n      schema: { value: schema },\n      byteView: { value: new StringView(this.buffer, this.byteOffset, this.byteLength) },\n    });\n  }\n\n  /**\n   * Returns the value of a given field of a record at the given index.\n   *\n   * @param {number} index the index of a record\n   * @param {string} field the name of the field\n   * @returns {*} value of the field\n   * @example\n   * const people = new RecordArray([\n   *   { name: 'age', type: 'Uint8' },\n   *   { name: 'score', type: 'Float32' },\n   * ], 20);\n   *\n   * person.get(0, 'age');\n   */\n  get(index, field) {\n    const { type, size, littleEndian } = this.schema[field];\n    const offset = this.getByteOffset(index, field);\n    switch (type) {\n      case 'Int8':\n        return this.getInt8(offset);\n      case 'Uint8':\n        return this.getUint8(offset);\n      case 'Int16':\n        return this.getInt16(offset, littleEndian);\n      case 'Uint16':\n        return this.getUint16(offset, littleEndian);\n      case 'Int32':\n        return this.getInt32(offset, littleEndian);\n      case 'Uint32':\n        return this.getUint32(offset, littleEndian);\n      case 'Float32':\n        return this.getFloat32(offset, littleEndian);\n      case 'Float64':\n        return this.getFloat64(offset, littleEndian);\n      case 'BigInt64':\n        return this.getBigInt64(offset, littleEndian);\n      case 'BigUint64':\n        return this.getBigUint64(offset, littleEndian);\n      case 'String':\n        return this.getString(offset, size);\n      default:\n        return this.getArray(offset, size, type);\n    }\n  }\n\n  /**\n   * @param {number} offset\n   * @param {number} size\n   * @param {string} type\n   * @returns {RecordArray}\n   */\n  getArray(offset, size, type) {\n    return new typedArrays[type](this.buffer, this.byteOffset + offset, size);\n  }\n\n  /**\n   * @param {number} offset\n   * @param {number} size\n   * @returns {StringView}\n   */\n  getString(offset, size) {\n    return this.byteView.subarray(offset, offset + size);\n  }\n\n  /**\n   * Sets a value to a field of a record at a given index.\n   *\n   * @param {number} index the index of a record\n   * @param {string} field the name of the field\n   * @param {*} value the value to be set\n   * @returns {this}\n   * @example\n   * const people = new RecordArray([\n   *   { name: 'age', type: 'Uint8' },\n   *   { name: 'score', type: 'Float32' },\n   * ], 20);\n   *\n   * person.set(0, 'age', 10);\n   * person.get(0, 'age');\n   * //=> 10\n   */\n  set(index, field, value) {\n    const { type, littleEndian, size } = this.schema[field];\n    const offset = this.getByteOffset(index, field);\n    switch (type) {\n      case 'Int8':\n        this.setInt8(offset, value);\n        break;\n      case 'Uint8':\n        this.setUint8(offset, value);\n        break;\n      case 'Int16':\n        this.setInt16(offset, value, littleEndian);\n        break;\n      case 'Uint16':\n        this.setUint16(offset, value, littleEndian);\n        break;\n      case 'Int32':\n        this.setInt32(offset, value, littleEndian);\n        break;\n      case 'Uint32':\n        this.setUint32(offset, value, littleEndian);\n        break;\n      case 'Float32':\n        this.setFloat32(offset, value, littleEndian);\n        break;\n      case 'Float64':\n        this.setFloat64(offset, value, littleEndian);\n        break;\n      case 'BigInt64':\n        this.setBigInt64(offset, value, littleEndian);\n        break;\n      case 'BigUint64':\n        this.setBigUint64(offset, value, littleEndian);\n        break;\n      case 'String':\n        this.setString(offset, value, size);\n        break;\n      default:\n        this.setArray(offset, value, size, type);\n        break;\n    }\n    return this;\n  }\n\n  /**\n   * @param {number} offset\n   * @param {ArrayLike} value\n   * @param {number} size\n   * @param {string} type\n   * @returns {RecordArray}\n   */\n  setArray(offset, value, size, type) {\n    const array = new typedArrays[type](this.buffer, this.byteOffset + offset, size);\n    if (value.length < array.length) array.fill(0);\n    array.set(value);\n    return this;\n  }\n\n  /**\n   * @param {number} offset\n   * @param {Collection} value\n   * @param {number} size\n   * @returns {void}\n   */\n  setString(offset, value, size) {\n    if (value.length === size) {\n      this.byteView.set(value, offset);\n    } else {\n      this.byteView.subarray(offset, offset + size)\n        .fill(0)\n        .set(value);\n    }\n  }\n\n  /**\n   * @type {number} The amount of structs in the array.\n   * @example\n   * const people = new RecordArray([\n   *   { name: 'age', type: 'Uint8' },\n   *   { name: 'score', type: 'Float32' },\n   * ], 20);\n   *\n   * people.size\n   * //=> 20\n   */\n  get size() {\n    return this.buffer.byteLength >> this.offset;\n  }\n\n  /**\n   * Returns the byte offset in the ArrayBuffer of a given field.\n   *\n   * @param {number} index the index of the record\n   * @param {string} field the name of the field\n   * @returns {number} the byte offset\n   */\n  getByteOffset(index, field) {\n    return (index << this.offset) + this.schema[field].start;\n  }\n\n  /**\n   * The object representation of a given record.\n   *\n   * @param {number} index the index of the record\n   * @returns {Object}\n   * @example\n   * const people = new RecordArray([\n   *   { name: 'age', type: 'Uint8' },\n   *   { name: 'score', type: 'Float32' },\n   * ], 20);\n   *\n   * person.set(0, 'age', 10).set(0, 'score', 5.0).toObject(0);\n   * //=> { age: 10, score: 5.0 }\n   */\n  toObject(index) {\n    const { fields } = this;\n    const result = {};\n    for (let i = 0; i < fields.length; i++) {\n      const { name } = fields[i];\n      result[name] = this.get(index, name);\n    }\n    return result;\n  }\n\n  /**\n   * Stores a given object as a record at a given index.\n   *\n   * @param {number} index the index of the record\n   * @param {Object} object the object to be stored\n   * @returns {RecordArray}\n   * @example\n   * const people = new RecordArray([\n   *   { name: 'age', type: 'Uint8' },\n   *   { name: 'score', type: 'Float32' },\n   * ], 20);\n   *\n   * person.set(0, 'age', 10).set(0, 'score', 5.0).toObject(0);\n   * //=> { age: 10, score: 5.0 }\n   */\n  fromObject(index, object) {\n    const { fields } = this;\n    for (let i = 0; i < fields.length; i++) {\n      const { name } = fields[i];\n      if (Reflect.has(object, name)) this.set(index, name, object[name]);\n    }\n    return this;\n  }\n\n  /**\n   * Returns the length of underlying ArrayBuffer required to hold the given amount of records.\n   *\n   * @param {Array<RecordField>} fields an array field descriptions\n   * @param {number} [size] the amount of structs in the array\n   * @returns {number}\n   */\n  static getLength(fields, size) {\n    const lastField = fields[fields.length - 1];\n    if (!lastField.end) this.initialize(fields);\n    return size << Math.ceil(Math.log2(lastField.end));\n  }\n\n  /**\n   * @private\n   * @param {Array} fields\n   * @returns {void}\n   */\n  static initialize(fields) {\n    let lastOffset = 0;\n    for (let i = 0; i < fields.length; i++) {\n      const field = fields[i];\n      const { type } = field;\n      let fieldSize = field.size;\n      if (!Reflect.has(fieldSizes, type)) {\n        throw TypeError(`Type \"${type}\" is not a valid type.`);\n      }\n      const isArray = Reflect.has(typedArrays, type);\n      if (isArray) {\n        const bytesPerElement = typedArrays[type].BYTES_PER_ELEMENT;\n        lastOffset = utilities.getGTEMultiple(lastOffset, bytesPerElement);\n        fieldSize *= bytesPerElement;\n      }\n      field.start = lastOffset;\n      lastOffset += (fieldSize || fieldSizes[type]);\n      field.end = lastOffset;\n    }\n  }\n}\n\nmodule.exports = RecordArray;\n","/**\n * @name Comparator\n * @function\n * @param {*} a\n * @param {*} b\n * @returns {number}\n */\n\n/**\n * Creates a SortedCollection class extending a given Array-like class.\n *\n * @param {CollectionConstructor} Base\n * @returns {SortedCollection}\n * @example\n *\n * const SortedCollection = Grid(Uint32Array);\n */\nfunction SortedMixin(Base) {\n  /**\n   * Extends TypedArrays  to handle sorted data.\n   *\n   * @extends CollectionConstructor\n   */\n  class SortedCollection extends Base {\n    /**\n     * Uses binary search to quickly check if the element is the array.\n     *\n     * @private\n     * @param {*} element the element to check\n     * @returns {boolean} whether the element is in the array\n     */\n    includes(element) {\n      return !!~this.indexOf(element);\n    }\n\n    /**\n     * Looks for the index of a given element in the array or -1\n     *\n     * @private\n     * @param {*} element the element to look for\n     * @returns {number} the element's index in the array or -1\n     */\n    indexOf(element) {\n      return this.constructor.getIndex(this, element);\n    }\n\n    /**\n     * Checks if the array is sorted.\n     *\n     * @returns {boolean} whether the array is sorted\n     * @example\n     *\n     * //=> SortedCollection [ 2, 3, 4, 5, 9 ];\n     * sortedCollection.isSorted();\n     * //=> true\n     * sortedCollection.reverse();\n     * sortedCollection.isSorted();\n     * //=> false;\n     */\n    isSorted() {\n      return this.constructor.isSorted(this);\n    }\n\n    /**\n     * Checks if the array has duplicating elements.\n     *\n     * @returns {boolean} whether the array has duplicating elements\n     * @example\n     *\n     * //=> SortedCollection [ 2, 3, 3, 4, 5, 9 ];\n     * sortedCollection.isUnique();\n     * //=> false;\n     */\n    isUnique() {\n      return this.constructor.isUnique(this);\n    }\n\n    /**\n     * Returns a range of elements of the array that are greater or equal to the provided\n     * starting element and less or equal to the provided ending element.\n     *\n     * @param {*} start the starting element\n     * @param {*} end the ending element\n     * @param {boolean} [subarray=false] return a subarray\n     *                                   instead of copying resulting value with slice\n     * @returns {SortedCollection} the resulting range of elements\n     * @example\n     *\n     * //=> SortedCollection [ 2, 3, 4, 5, 9 ];\n     * sortedCollection.range(3, 5);\n     * // => [ 3, 4, 5 ]\n     * sortedCollection.range(undefined, 4);\n     * // => [ 2, 3, 4 ]\n     * sortedCollection.range(4);\n     * // => [ 4, 5, 8 ]\n     */\n    range(start, end, subarray) {\n      return this.constructor.getRange(this, start, end, this.constructor.compare, subarray);\n    }\n\n    /**\n     * Returns the rank of an element in the array.\n     *\n     * @param {*} element the element to look for\n     * @returns {number} the rank in the array\n     * @example\n     *\n     * //=> SortedCollection [ 2, 3, 4, 5, 9 ];\n     * sortedCollection.rank(1);\n     * // => 0\n     * sortedCollection.rank(6);\n     * // => 4\n     */\n    rank(element) {\n      return this.constructor.getIndex(this, element, this.constructor.compare, true);\n    }\n\n    /**\n     * The default comparator.\n     *\n     * @param {*} a the first value\n     * @param {*} b the second value\n     * @throws {RangeError} if the comparison is unstable\n     * @returns {number}\n     */\n    static compare(a, b) {\n      if (a > b) return 1;\n      if (a < b) return -1;\n      if (a === b) return 0;\n      throw new RangeError('Unstable comparison.');\n    }\n\n    /**\n     * Creates a new SortedCollection from a given array-like object.\n     *\n     * @private\n     * @param {*} arrayLike an array-like object to convert to a SortedCollection\n     * @param {Function} mapFn a map function to call on every element of the array\n     * @param {Object} thisArg the value to use as `this` when invoking the `mapFn`\n     * @returns {SortedCollection} a new SortedCollection\n     */\n    static from(arrayLike, mapFn, thisArg) {\n      const result = super.from(arrayLike, mapFn, thisArg);\n      result.sort();\n      return result;\n    }\n\n    /**\n     * Returns the difference of two sorted arrays,\n     * i.e. elements present in the first array but not in the second array.\n     * If `symmetric=true` finds the symmetric difference of two arrays, that is,\n     * the elements that are absent in one or another array.\n     *\n     * @param {Collection} a the first array\n     * @param {Collection} b the second array\n     * @param {boolean} [symmetric=false] whether to get symmetric difference.\n     * @param {Comparator} [comparator] the comparator static used to sort the arrays\n     * @param {Collection} [container] an array-like object to hold the results\n     * @returns {Array} the difference of the arrays\n     * @example\n     *\n     * SortedCollection.getDifference([1, 2, 3, 4, 8], [2, 4, 6, 7, 9]);\n     * //=> [ 1, 3, 8 ]\n     *\n     * // symmetric difference of sorted arrays:\n     * SortedCollection.getDifference(first, second, true);\n     * //=> [ 1, 3, 6, 7, 8, 9 ]\n\n     * // difference using a custom comparator:\n     * const customComparator = (a, b) => (a > b ? -1 : a < b ? 1 : 0);\n     * SortedCollection.getDifference([8, 4, 3, 2, 1], [9, 7, 6, 4, 2], false, customComparator);\n     * //=> [ 8, 3, 1 ]\n     */\n    static getDifference(a, b, symmetric, comparator = this.compare, container = []) {\n      let i = 0;\n      let j = 0;\n      while (i < a.length && j < b.length) {\n        const compared = comparator(a[i], b[j]);\n        if (compared > 0) {\n          if (symmetric) container[container.length] = b[j];\n          j++;\n        } else if (compared < 0) {\n          container[container.length] = a[i];\n          i++;\n        } else {\n          i++;\n          j++;\n        }\n      }\n      while (i < a.length) {\n        container[container.length] = a[i];\n        i++;\n      }\n      if (symmetric) {\n        while (j < b.length) {\n          container[container.length] = b[j];\n          j++;\n        }\n      }\n      return container;\n    }\n\n    /**\n     * Returns the amount of differing elements in the first array.\n     *\n     * @param {Collection} a the first array\n     * @param {Collection} b the second array\n     * @param {boolean} [symmetric=false] whether to use symmetric difference\n     * @param {Comparator} [comparator] the comparator static used to sort the arrays\n     * @returns {number} the amount of differing elements\n     * @example\n     *\n     * SortedCollection.getDifferenceScore([1, 2, 3, 4, 8], [2, 4, 6, 7, 9]);\n     * //=> 3\n     */\n    static getDifferenceScore(a, b, symmetric, comparator) {\n      const score = this.getIntersectionScore(a, b, comparator);\n      return symmetric ? (a.length + b.length) - (2 * score) : a.length - score;\n    }\n\n    /**\n     * Uses binary search to find the index of an element inside a sorted array.\n     *\n     * @param {Collection} arr the array to search\n     * @param {*} target the target value to search for\n     * @param {Comparator} [comparator] a custom comparator\n     * @param {boolean} [rank=false] whether to return the element's rank if the element isn't found\n     * @param {number} [start] the start position of the search\n     * @param {number} [end] the end position of the search\n     * @returns {number} the index of the searched element or it's rank\n     * @example\n     *\n     * SortedCollection.getIndex([1, 2, 3, 4, 8], 4);\n     * //=> 3\n     */\n    static getIndex(\n      arr, target, comparator = this.compare,\n      rank = false, start = 0, end = arr.length - 1,\n    ) {\n      let left = start;\n      let right = end;\n      let m;\n      while (left <= right) {\n        m = (left + right) >> 1;\n        const compared = comparator(arr[m], target);\n        if (compared < 0) {\n          left = m + 1;\n        } else if (compared > 0) {\n          right = m - 1;\n        } else {\n          return m;\n        }\n      }\n      return rank ? left : -1;\n    }\n\n    /**\n     * Returns the intersection of two sorted arrays.\n     *\n     * @param {Collection} a the first array\n     * @param {Collection} b the second array\n     * @param {Comparator} [comparator] the comparator static used to sort the arrays\n     * @param {Collection} [container] an array-like object to hold the results\n     * @returns {Array} the intersection of the arrays\n     * @example\n     *\n     * SortedCollection.getIntersection([1, 2, 3, 4, 8], [2, 4, 6, 7, 9]);\n     * //=> [ 2, 4 ]\n     *\n     * // intersection using a custom comparator:\n     * const customComparator = (a, b) => (a > b ? -1 : a < b ? 1 : 0);\n     * SortedCollection.getIntersection([8, 4, 3, 2, 1], [9, 7, 6, 4, 2], customComparator);\n     * //=> [ 4, 2 ]\n     */\n    static getIntersection(a, b, comparator = this.compare, container = []) {\n      let i = 0;\n      let j = 0;\n      while (i < a.length && j < b.length) {\n        const compared = comparator(a[i], b[j]);\n        if (compared > 0) {\n          j++;\n        } else if (compared < 0) {\n          i++;\n        } else {\n          container[container.length] = a[i];\n          i++;\n          j++;\n        }\n      }\n      return container;\n    }\n\n    /**\n     * Returns the amount of common elements in two sorted arrays.\n     *\n     * @param {Collection} a the first array\n     * @param {Collection} b the second array\n     * @param {Comparator} [comparator] the comparator static used to sort the arrays\n     * @returns {number} the amount of different elements\n     * @example\n     *\n     * SortedCollection.getIntersection([1, 2, 3, 4, 8], [2, 4, 6, 7, 9]);\n     * //=> 2\n     */\n    static getIntersectionScore(a, b, comparator = this.compare) {\n      let score = 0;\n      let i = 0;\n      let j = 0;\n      while (i < a.length && j < b.length) {\n        const compared = comparator(a[i], b[j]);\n        if (compared > 0) {\n          j++;\n        } else if (compared < 0) {\n          i++;\n        } else {\n          score++;\n          i++;\n          j++;\n        }\n      }\n      return score;\n    }\n\n    /**\n     * Returns a range of elements of a sorted array from the start through the end inclusively.\n     *\n     * @param {Collection} arr the array\n     * @param {number} [start] the starting item\n     * @param {number} [end] the ending item\n     * @param {Comparator} [comparator] a custom comparator\n     * @param {boolean} [subarray] return a subarray instead of copying resulting value with slice\n     * @returns {Collection} the range of items\n     * @example\n     *\n     * SortedCollection.getRange([1, 2, 3, 4, 8], 2, 4);\n     * //=> [ 2, 3, 4 ]\n     *\n     * const customComparator = (a, b) => (a > b ? -1 : a < b ? 1 : 0);\n     * SortedCollection.getRange([8, 4, 3, 2, 1], 8, 3, customComparator);\n     * //=> [ 8, 4, 3 ]\n     */\n    static getRange(arr, start, end, comparator, subarray) {\n      const startIndex = start === undefined ? 0 : this.getIndex(arr, start, comparator, true);\n      const endIndex = end === undefined ? arr.length\n        : this.getIndex(arr, end, comparator, true, startIndex) + 1;\n      const method = subarray ? 'subarray' : 'slice';\n      return arr[method](startIndex, endIndex);\n    }\n\n    /**\n     * Returns the union of two sorted arrays as a sorted array.\n     *\n     * @param {Collection} a the first array\n     * @param {Collection} b the second array\n     * @param {boolean} [unique=false] whether to avoid duplicating items when merging unique arrays\n     * @param {Comparator} [comparator] the comparator static used to sort the arrays\n     * @param {Collection} [container] an array-like object to hold the results\n     * @returns {Array} the union of the arrays\n     * @example\n     *\n     * SortedCollection.getUnion([1, 2, 3, 4, 8], [2, 4, 6, 7, 9]);\n     * //=> [ 1, 2, 2, 3, 4, 4, 6, 7, 8, 9 ]\n     *\n     * // union of sorted arrays without duplicates:\n     * SortedCollection.getUnion([1, 2, 3, 4, 8], [2, 4, 6, 7, 9], true);\n     * //=> [ 1, 2, 3, 4, 6, 7, 8, 9 ]\n     *\n     * //union using a custom comparator:\n     * SortedCollection.getUnion([8, 4, 3, 2, 1], [9, 7, 6, 4, 2], true, customComparator);\n     * //=> [ 9, 8, 7, 6, 4, 3, 2, 1 ]\n     */\n    static getUnion(a, b, unique, comparator = this.compare, container = []) {\n      let i = 0;\n      let j = 0;\n      while (i < a.length && j < b.length) {\n        const compared = comparator(a[i], b[j]);\n        if (compared > 0) {\n          container[container.length] = b[j];\n          j++;\n        } else if (compared < 0) {\n          container[container.length] = a[i];\n          i++;\n        } else {\n          container[container.length] = a[i];\n          if (!unique) container[container.length] = b[j];\n          i++;\n          j++;\n        }\n      }\n      while (i < a.length) {\n        container[container.length] = a[i];\n        i++;\n      }\n      while (j < b.length) {\n        container[container.length] = b[j];\n        j++;\n      }\n      return container;\n    }\n\n\n    /**\n     * Returns an array of unique elements from a sorted array.\n     *\n     * @param {Collection} arr the sorted array\n     * @param {Comparator} [comparator] a custom comparator\n     * @param {Collection} [container] an array-like object to hold the results\n     * @returns {Array} the sorted array without duplicates\n     * @example\n     *\n     * SortedCollection.getUnique([1, 1, 2, 2, 3, 4]);\n     * //=> [ 1, 2, 3, 4 ]\n     */\n    static getUnique(arr, comparator = this.compare, container = []) {\n      container[0] = arr[0];\n      for (let i = 1; i < arr.length; i++) {\n        if (comparator(arr[i - 1], arr[i]) !== 0) {\n          container[container.length] = arr[i];\n        }\n      }\n      return container;\n    }\n\n    /**\n     * Creates a new SortedCollection instance with a variable number of arguments,\n     * regardless of number or type of the arguments\n     *\n     * @private\n     * @param {...*} elements the elements of which to create the array\n     * @returns {SortedCollection} the new SortedCollection\n     */\n    static of(...elements) {\n      const result = super.of(...elements);\n      result.sort();\n      return result;\n    }\n\n    /**\n     * Checks whether an array is sorted according to a provided comparator.\n     *\n     * @param {Array} arr the array to check\n     * @param {Comparator} [comparator] a custom comparator\n     * @returns {boolean} whether the array is sorted\n     *\n     * @example\n     *\n     * SortedCollection.isSorted([1, 2, 3, 4, 8]);\n     * //=> true\n     */\n    static isSorted(arr, comparator = this.compare) {\n      for (let i = 1; i < arr.length; i++) {\n        if (comparator(arr[i - 1], arr[i]) > 0) return false;\n      }\n      return true;\n    }\n\n    /**\n     * Checks whether an array has any duplicating elements.\n     *\n     * @param {Array} arr the array to check\n     * @param {Comparator} [comparator] a custom comparator\n     * @returns {boolean} whether the array has duplicating elements\n     * @example\n     *\n     * SortedCollection.isUnique([1, 2, 2, 3, 4]);\n     * //=> false\n     */\n    static isUnique(arr, comparator = this.compare) {\n      for (let i = 1; i < arr.length; i++) {\n        if (comparator(arr[i - 1], arr[i]) === 0) return false;\n      }\n      return true;\n    }\n  }\n\n  return SortedCollection;\n}\n\nmodule.exports = SortedMixin;\n","const SortedMixin = require('./sorted-collection');\n\n/**\n * Extends Array to handle sorted data.\n *\n * @extends SortedCollection\n */\nclass SortedArray extends SortedMixin(Array) {\n  /**\n   * Returns a merger of the array with one or more provided sorted arrays.\n   *\n   * @private\n   * @param {...Array} arrays sorted array(s) to merge\n   * @returns {SortedArray} a new SortedArray\n   */\n  concat(...arrays) {\n    let result = this;\n    for (let i = 0; i < arrays.length; i++) {\n      result = this.constructor.getUnion(\n        result, arrays[i], this.unique, this.constructor.compare, new this.constructor(),\n      );\n    }\n    return result;\n  }\n\n  /**\n   * Adds provided elements to the array preserving the sorted order of the array.\n   *\n   * @private\n   * @param {...*} elements the elements to add to the array\n   * @returns {number} the new length of the array\n   */\n  push(...elements) {\n    const { compare } = this.constructor;\n    const m = this.length;\n    if (!m) return super.push(...elements.sort(compare));\n    const toAdd = this.unique ? elements.filter(el => !~this.indexOf(el)) : elements;\n    const n = toAdd.length;\n    if (!n) return m;\n    toAdd.sort(compare);\n    for (let i = n - 1; i >= 0; i--) {\n      let j;\n      const last = this[m - 1];\n      for (j = m - 2; j >= 0 && compare(this[j], toAdd[i]) === 1; j--) {\n        this[j + 1] = this[j];\n      }\n      if (j !== m - 2 || compare(last, toAdd[i]) === 1) {\n        this[j + 1] = toAdd[i];\n        toAdd[i] = last;\n      }\n    }\n    return super.push(...toAdd);\n  }\n\n  /**\n   * Implements in-place replacement of the array elements.\n   *\n   * @param {Collection} arr an array of new elements to use\n   * @returns {SortedArray}\n   * @example\n   *\n   * //=> SortedArray [ 2, 3, 4, 5, 9 ];\n   * sortedArray.set([1, 2, 3]);\n   * //=> SortedArray [ 1, 2, 3 ]\n   */\n  set(arr) {\n    this.length = arr.length;\n    for (let i = 0; i < arr.length; i++) {\n      this[i] = arr[i];\n    }\n    return this;\n  }\n\n  /**\n   * Sorts the array with a provided compare function.\n   *\n   * @private\n   * @param {Comparator} compareFunction the function to use for comparison\n   * @returns {this}\n   */\n  sort(compareFunction = this.constructor.compare) {\n    return super.sort(compareFunction);\n  }\n\n  /**\n   * Changes the array by removing existing elements and adding new ones.\n   *\n   * @private\n   * @param {number} start the index at which to start changing the array\n   * @param {number} deleteCount the amount of old elements to delete\n   * @param {...*} elements the elements to add to the array\n   * @returns {SortedArray} an array of deleted elements\n   */\n  splice(start, deleteCount, ...elements) {\n    const deletedElements = super.splice(start, deleteCount);\n    this.push(...elements);\n    return deletedElements;\n  }\n\n  /**\n   * Removes duplicating elements from the array.\n   *\n   * @returns {SortedArray}\n   * @example\n   *\n   * //=> SortedArray [ 2, 2, 3, 4, 5, 5, 9 ];\n   * sortedArray.uniquify();\n   * // => SortedArray [ 2, 3, 4, 5, 9 ]\n   */\n  uniquify() {\n    return this.set(this.constructor.getUnique(this, this.constructor.compare,\n      new this.constructor()));\n  }\n\n  /**\n   * Adds provided elements to the array preserving the sorted order of the array.\n   *\n   * @private\n   * @param {...*} elements the elements to add to the array\n   * @returns {number} the new length of the array\n   */\n  unshift(...elements) {\n    return this.push(...elements);\n  }\n}\n\nmodule.exports = SortedArray;\n","/**\n * Creates a SymmetricGrid class extending a given Array-like class.\n *\n * @param {CollectionConstructor} Base\n * @returns {SymmetricGrid}\n * @example\n *\n * const SymmetricGrid = SymmetricGridMixin(Array);\n */\nfunction SymmetricGridMixin(Base) {\n  /**\n   * A grid to handle symmetric or triangular matrices\n   * using half the space required for a normal grid.\n   *\n   * @extends CollectionConstructor\n   */\n  class SymmetricGrid extends Base {\n    /**\n     * Passes all arguments to the Base class except if called with a special set of grid options,\n     * in that case creates and empty grid of specified parameters.\n     *\n     * @param {Object} [options]\n     * @param {number} [options.rows=2] the number of rows\n     * @param {*} [options.pad=0] the initial value of cells\n     * @param {...*} [args]\n     * @example\n     *\n     * new SymmetricGrid('a')\n     * //=> SymmetricGrid ['a']\n     *\n     * new SymmetricGrid(2)\n     * //=> SymmetricGrid [undefined, undefined]\n     *\n     * new SymmetricGrid({ rows: 3 })\n     * //=> SymmetricGrid [0, 0, 0, 0]\n     *\n     * new SymmetricGrid({ rows: 3, pad: 1 })\n     * //=> SymmetricGrid [1, 1, 1, 1]\n     */\n    constructor(options = {}, ...args) {\n      const { rows = 2, pad = 0 } = options;\n      if (args.length) {\n        super(...args);\n      } else {\n        super(SymmetricGrid.getLength(rows));\n        this.fill(pad);\n      }\n      Object.defineProperties(this, {\n        pad: { value: pad, writable: true },\n        columns: { value: rows },\n        rows: { value: rows },\n        lastCoordinates: { value: Object.seal({ row: 0, column: 0 }) },\n      });\n    }\n\n    /**\n     * Returns an element from given coordinates.\n     *\n     * @param {number} row\n     * @param {number} column\n     * @returns {*}\n     * @example\n     *\n     * const a = SymmetricGrid({ rows: 3, pad: 3});\n     * a.get(0, 1);\n     * //=> 3\n     */\n    get(row, column) {\n      return this[this.constructor.getIndex(row, column)];\n    }\n\n    /**\n     * Sets the element at given coordinates.\n     * Proxies to TypedArray#set if the first parameter is Array-like\n     * and the grid is based on a TypedArray.\n     *\n     * @param {number|Collection} row\n     * @param {number} [column]\n     * @param {*} [value]\n     * @returns {SymmetricGrid} the instance\n     * @example\n     *\n     * const a = SymmetricGrid({ rows: 3, pad: 3});\n     * a.set(0, 1, 5);\n     * a.get(0, 1);\n     * //=> 5\n     */\n    set(row, column, value) {\n      if (row.length && super.set) {\n        super.set(row, column);\n        return this;\n      }\n      this[this.constructor.getIndex(row, column)] = value;\n      return this;\n    }\n\n    /**\n     * Implements in-place replacement of the grid elements if it's based on Array.\n     * Proxies to TypedArray#set if the grid is based on a TypedArray.\n     *\n     * @param {Collection} array\n     * @param {number} [offset]\n     * @returns {void}\n     */\n    setArray(array, offset) {\n      if (super.set) {\n        super.set(array, offset);\n      } else {\n        this.length = array.length;\n        for (let i = 0; i < array.length; i++) {\n          this[i] = array[i];\n        }\n      }\n    }\n\n    /**\n     * Gets coordinates of an element at specified index.\n     *\n     * @param {number} index\n     * @returns {Coordinates} coordinates\n     * @example\n     * const a = SymmetricGrid({ rows: 3, pad: 3});\n     * a.getCoordinates(1);\n     * //=> [0, 1]\n     * a.getCoordinates(2);\n     * //=> [1, 1]\n     */\n    getCoordinates(index) {\n      const row = (Math.sqrt((index << 3) + 1) - 1) >> 1;\n      this.lastCoordinates.row = row;\n      this.lastCoordinates.column = index - ((row * (row + 1)) >> 1);\n      return this.lastCoordinates;\n    }\n\n    /**\n     * Returns an array of arrays where each nested array correspond to a row in the grid.\n     *\n     * @returns {Array<Array<*>>}\n     * @example\n     *\n     * const a = SymmetricGrid.from([[1, 2, 4], [2, 3, 5], [4, 5, 6]])\n     * //=> SymmetricGrid [1, 2, 3, 4, 5, 6]\n     * a.toArrays();\n     * //=> Array [[1, 2, 4], [2, 3, 5], [4, 5, 6]]\n     */\n    toArrays() {\n      const { rows } = this;\n      const arrays = new Array(rows).fill(0).map(() => []);\n      let k = 0;\n      for (let i = 0; i < rows; i++) {\n        for (let j = 0; j <= i; j++) {\n          arrays[i][j] = this[k];\n          arrays[j][i] = this[k];\n          k++;\n        }\n      }\n      return arrays;\n    }\n\n    /**\n     * @type {CollectionConstructor}\n     */\n    static get [Symbol.species]() {\n      return Base;\n    }\n\n    /**\n     * Returns an array index of an element at given coordinates.\n     *\n     * @param {number} row\n     * @param {number} column\n     * @returns {*}\n     * @example\n     *\n     * const a = SymmetricGrid({ rows: 3 });\n     * a.get(1, 0);\n     * //=> 1\n     * a.get(0, 1);\n     * //=> 1\n     */\n    static getIndex(row, column) {\n      const [x, y] = row >= column ? [column, row] : [row, column];\n      return x + (((y + 1) * y) >> 1);\n    }\n\n    /**\n     * Returns the length of underlying Array required to hold the grid.\n     *\n     * @param {number} rows\n     * @returns {number}\n     */\n    static getLength(rows) {\n      return ((rows + 1) * rows) >> 1;\n    }\n\n    /**\n     * Creates a grid from an array of arrays.\n     *\n     * @param {Array<Array<*>>} arrays\n     * @param {*} [pad=0] the value to pad the arrays to create equal sized rows\n     * @returns {SymmetricGrid}\n     *\n     * const a = SymmetricGrid.from([[1, 2, 4], [2, 3, 5], [4, 5, 6]])\n     * //=> SymmetricGrid [1, 2, 3, 4, 5, 6]\n     * a.get(1, 0);\n     * //=> 2\n     * a.get(2, 1);\n     * //=> 4\n     */\n    static fromArrays(arrays, pad = 0) {\n      const rows = arrays.length;\n      const grid = new this({ rows, pad });\n      let k = 0;\n      for (let i = 0; i < rows; i++) {\n        for (let j = 0; j <= i; j++) {\n          grid[k] = arrays[i][j];\n          k++;\n        }\n      }\n      return grid;\n    }\n  }\n\n  return SymmetricGrid;\n}\n\nmodule.exports = SymmetricGridMixin;\n","/**\n * Implements Adjacency List data structure for unweighted graphs.\n *\n * @extends Uint32Array\n */\nclass UnweightedAdjacencyList extends Uint32Array {\n  /**\n   * @param {Object} [options]\n   * @param {number} [options.vertices=2] the maximum amount of vertices in the graph\n   * @param {number} [options.edges=2] the maximum amount of edges in the graph\n   * @param {...*} args\n   */\n  constructor(options = {}, ...args) {\n    let { vertices, edges } = options;\n    if (args.length) {\n      if (!vertices && args[0].length) {\n        vertices = UnweightedAdjacencyList.getVertexCount(args[0]);\n        edges = args[0].length - vertices - 1;\n      }\n      super(...args);\n    } else {\n      vertices = vertices || 2;\n      edges = edges || 2;\n      super((vertices + edges) + 1);\n    }\n    Object.defineProperties(this, {\n      vertices: { value: vertices },\n      edges: { value: edges },\n    });\n\n    if (!args.length) this.setOffsets();\n  }\n\n  /**\n   * Adds an edge between two vertices.\n   *\n   * @param {number} x the starting vertex\n   * @param {number} y the ending vertex\n   * @throws {RangeError} if the list is full\n   * @returns {UnweightedAdjacencyList}\n   */\n  addEdge(x, y) {\n    const { undirected } = this.constructor;\n    if (this.hasEdge(x, y)) return this;\n    // the list is full\n    if (this.isFull()) throw new RangeError('The list is full.');\n    this.setEdge(x, y);\n    if (undirected) this.setEdge(y, x);\n    return this;\n  }\n\n  /**\n   * Removes an edge between two vertices.\n   *\n   * @param {number} x the starting vertex\n   * @param {number} y the ending vertex\n   * @returns {UnweightedAdjacencyList}\n   */\n  removeEdge(x, y) {\n    const { undirected } = this.constructor;\n    this.unsetEdge(x, y);\n    if (undirected) this.unsetEdge(y, x);\n    return this;\n  }\n\n  /**\n   * Checks if there is an edge between two vertices.\n   *\n   * @param {number} x the starting vertex\n   * @param {number} y the ending vertex\n   * @returns {boolean}\n   */\n  hasEdge(x, y) {\n    return !!this.getEdge(x, y);\n  }\n\n  /**\n   * Returns 1 if the edge between the given vertices exists, 0 otherwise.\n   *\n   * @param {number} x the starting vertex\n   * @param {number} y the ending vertex\n   * @returns {number}\n   */\n  getEdge(x, y) {\n    const offset = this[x];\n    const nextOffset = this[x + 1];\n    // no out edges from x\n    if (offset === nextOffset) return 0;\n    for (let i = offset; i < nextOffset; i++) {\n      if (this[i] === y) return 1;\n    }\n    return 0;\n  }\n\n  /**\n   * @private\n   * @param {number} x the starting vertex\n   * @param {number} y the ending vertex\n   * @returns {UnweightedAdjacencyList}\n   */\n  setEdge(x, y) {\n    const { vertices } = this;\n\n    // shift values\n    for (let i = this[vertices]; i > this[x]; i--) {\n      [this[i], this[i - 1]] = [this[i - 1], this[i]];\n    }\n    // set edge\n    this[this[x]] = y;\n\n    // update offsets\n    for (let i = x + 1; i <= vertices; i++) {\n      this[i] += 1;\n    }\n    return this;\n  }\n\n  /**\n   * @private\n   * @param {number} x the starting vertex\n   * @param {number} y the ending vertex\n   * @returns {UnweightedAdjacencyList}\n   */\n  unsetEdge(x, y) {\n    const offset = this[x];\n    const nextOffset = this[x + 1];\n    // no out edges from x\n    if (offset === nextOffset) return this;\n    let edgeIndex = 0;\n    for (let i = offset; i < nextOffset; i++) {\n      if (this[i] === y) {\n        edgeIndex = i;\n        break;\n      }\n    }\n    // there is no such edge\n    if (!edgeIndex) return this;\n    // shift value\n    for (let i = edgeIndex; i < this[this.vertices]; i++) {\n      this[i] = this[i + 1];\n    }\n\n    // update offsets\n    for (let i = x + 1; i <= this.vertices; i++) {\n      this[i] -= 1;\n    }\n\n    return this;\n  }\n\n  /**\n   * Iterates over outgoing edges of a vertex.\n   *\n   * @generator\n   * @param {number} vertex the vertex\n   * @yields {number}\n   */\n  * outEdges(vertex) {\n    const offset = this[vertex];\n    const nextOffset = this[vertex + 1];\n    if (offset !== nextOffset) {\n      for (let i = nextOffset - 1; i >= offset; i--) {\n        yield this[i];\n      }\n    }\n  }\n\n  /**\n   * Iterates over incoming edges of a vertex.\n   *\n   * @generator\n   * @param {number} vertex the vertex\n   * @yields {number}\n   */\n  * inEdges(vertex) {\n    const { vertices } = this;\n    let edge = 0;\n    let nextVertex = 1;\n    for (let i = vertices + 1; i < this[vertices]; i++) {\n      while (i >= this[nextVertex]) {\n        edge++;\n        nextVertex++;\n      }\n      if (this[i] === vertex) yield edge;\n    }\n  }\n\n  /**\n   * @private\n   * @returns {void}\n   */\n  setOffsets() {\n    const lastElement = this.vertices + 1;\n    for (let i = 0; i < lastElement; i++) {\n      this[i] = lastElement;\n    }\n  }\n\n  /**\n   * Checks whether the list is full--all available edges are set.\n   *\n   * @returns {boolean}\n   */\n  isFull() {\n    return this[this.vertices] >= this.length;\n  }\n\n  /**\n   * Creates a larger copy of the graph with a space\n   * for a specified amount of additional vertices and edges.\n   *\n   * @param {number} [vertices=0] the amount of additional vertices\n   * @param {number} [edges=1] the amount of additional edges\n   * @returns {UnweightedAdjacencyList}\n   */\n  grow(vertices = 0, edges = 1) {\n    const copy = new this.constructor({\n      vertices: this.vertices + vertices,\n      edges: this.edges + edges,\n    });\n\n    if (!vertices) {\n      copy.set(this);\n    } else {\n      const offset = this[this.vertices];\n      const newSize = this.vertices + vertices;\n      const newOffset = offset + vertices;\n      for (let i = 0; i <= newSize; i++) {\n        copy[i] = i < this.vertices ? this[i] + vertices : newOffset;\n      }\n      copy.set(this.subarray(this.vertices + 1), newSize + 1);\n    }\n    return copy;\n  }\n\n  /**\n   * Returns the length of underlying TypedArray required to hold the graph.\n   *\n   * @param {number} vertices\n   * @param {number} edges\n   * @returns {number}\n   */\n  static getLength(vertices, edges) {\n    return vertices + edges + 1;\n  }\n\n  /**\n   * Derives the vertex count of an adjacency list stored as an array-like object.\n   *\n   * @param {Collection} array\n   * @returns {number}\n   */\n  static getVertexCount(array) {\n    let vertices = 0;\n    while (array[vertices] <= array[vertices + 1]) {\n      vertices++;\n    }\n    return vertices;\n  }\n\n  /**\n   * @type {CollectionConstructor}\n   */\n  static get [Symbol.species]() {\n    return Uint32Array;\n  }\n\n  /**\n   * Creates an adjacency list from a given grid or adjacency matrix.\n   *\n   * @param {Grid|BinaryGrid|SymmetricGrid} grid\n   * @returns {UnweightedAdjacencyList}\n   */\n  static fromGrid(grid) {\n    const vertices = grid.rows;\n    const offset = vertices + 1;\n    const empty = grid.pad || 0;\n    const array = new Array(offset).fill(offset);\n    let edges = 0;\n    for (let i = 0; i < vertices; i++) {\n      array[i + 1] = i === 0 ? offset : array[i];\n      for (let j = 0; j < vertices; j++) {\n        if (grid.get(i, j) !== empty) {\n          array.push(j);\n          array[i + 1] += 1;\n          edges++;\n        }\n      }\n    }\n    const graph = new this({ vertices, edges });\n    graph.set(array);\n    return graph;\n  }\n}\n\n/**\n * Whether the graph is undirected.\n * @type {boolean}\n */\nUnweightedAdjacencyList.undirected = false;\n\n/**\n * Whether the graph is weighted.\n * @type {boolean}\n */\nUnweightedAdjacencyList.weighted = false;\n\nmodule.exports = UnweightedAdjacencyList;\n","const BinaryGrid = require('./binary-grid');\n\n/**\n * Implements Adjacency Matrix for unweighted graphs.\n *\n * @extends BinaryGrid\n */\nclass UnweightedAdjacencyMatrix extends BinaryGrid {\n  /**\n   * @param {Object} [options]\n   * @param {number} [options.vertices=2] the maximum number of vertices\n   * @param {...*} [args]\n   */\n  constructor(options = {}, ...args) {\n    const { vertices = 2 } = options;\n    super({ rows: vertices, columns: vertices }, ...args);\n    Object.defineProperties(this, {\n      vertices: { value: vertices },\n    });\n  }\n\n  /**\n   * Adds an edge between two vertices.\n   *\n   * @param {number} x the starting vertex\n   * @param {number} y the ending vertex\n   * @returns {UnweightedAdjacencyMatrix}\n   */\n  addEdge(x, y) {\n    const { undirected } = this.constructor;\n    this.set(x, y);\n    if (undirected) this.set(y, x);\n    return this;\n  }\n\n  /**\n   * Removes an edge between two vertices.\n   *\n   * @param {number} x the starting vertex\n   * @param {number} y the ending vertex\n   * @returns {UnweightedAdjacencyMatrix}\n   */\n  removeEdge(x, y) {\n    const { undirected } = this.constructor;\n    this.set(x, y, 0);\n    if (undirected) this.set(y, x, 0);\n    return this;\n  }\n\n  /**\n   * Checks if there is an edge between two vertices.\n   *\n   * @param {number} x the starting vertex\n   * @param {number} y the ending vertex\n   * @returns {boolean}\n   */\n  hasEdge(x, y) {\n    return !!this.get(x, y);\n  }\n\n  /**\n   * Returns 1 if the edge between the given vertices exists, 0 otherwise.\n   *\n   * @param {number} x the starting vertex\n   * @param {number} y the ending vertex\n   * @returns {number}\n   */\n  getEdge(x, y) {\n    return this.get(x, y);\n  }\n\n  /**\n   * Iterates over outgoing edges of a vertex.\n   *\n   * @generator\n   * @param {number} vertex the vertex\n   * @yields {number}\n   */\n  * outEdges(vertex) {\n    const { columns, offset } = this;\n    const start = vertex << offset;\n    const end = start + columns;\n    for (let i = start; i < end; i++) {\n      const bucket = i >> 4;\n      const position = i - (bucket << 4);\n      const value = (this[bucket] >> position) & 1;\n      if (value) yield i - start;\n    }\n  }\n\n  /**\n   * Iterates over incoming edges of a vertex.\n   *\n   * @generator\n   * @param {number} vertex the vertex\n   * @yields {number}\n   */\n  * inEdges(vertex) {\n    const { rows, offset } = this;\n    for (let i = 0; i < rows; i++) {\n      const index = (i << offset) + vertex;\n      const bucket = index >> 4;\n      const position = index - (bucket << 4);\n      const value = (this[bucket] >> position) & 1;\n      if (value) yield i;\n    }\n  }\n\n  /**\n   * Returns the length of underlying TypedArray required to hold the graph.\n   *\n   * @param {number} vertices\n   * @returns {number}\n   */\n  static getLength(vertices) {\n    return super.getLength(vertices, vertices);\n  }\n\n  /**\n   * Creates an adjacency matrix from a given adjacency list.\n   *\n   * @param {UnweightedAdjacencyList} list\n   * @returns {UnweightedAdjacencyMatrix}\n   */\n  static fromList(list) {\n    const { vertices } = list;\n    const graph = new this({ vertices });\n    for (let i = 0; i < vertices; i++) {\n      const offset = list[i];\n      const nextOffset = list[i + 1];\n      if (offset === nextOffset) continue;\n      for (let j = nextOffset - 1; j >= offset; j--) {\n        graph.addEdge(i, list[j]);\n      }\n    }\n    return graph;\n  }\n}\n\n/**\n * Whether the graph is undirected.\n * @type {boolean}\n */\nUnweightedAdjacencyMatrix.undirected = false;\n\n/**\n * Whether the graph is weighted.\n * @type {boolean}\n */\nUnweightedAdjacencyMatrix.weighted = false;\n\nmodule.exports = UnweightedAdjacencyMatrix;\n","/**\n * Creates a WeightedAdjacencyList class extending a given TypedArray class.\n *\n * @param {CollectionConstructor} Base\n * @returns {WeightedAdjacencyList}\n */\nfunction WeightedAdjacencyListMixin(Base) {\n  /**\n   * Implements Adjacency List data structure for weighted graphs.\n   *\n   * @extends CollectionConstructor\n   */\n  class WeightedAdjacencyList extends Base {\n    /**\n     * @param {Object} [options]\n     * @param {number} [options.vertices=2] the maximum amount of vertices in the graph\n     * @param {number} [options.edges=2] the maximum amount of edges in the graph\n     * @param {...*} args\n     */\n    constructor(options = {}, ...args) {\n      let { vertices, edges } = options;\n      if (args.length) {\n        if (!vertices && args[0].length) {\n          vertices = WeightedAdjacencyList.getVertexCount(args[0]);\n          edges = args[0].length - vertices - 1;\n        }\n        super(...args);\n      } else {\n        vertices = vertices || 2;\n        edges = edges || 4;\n        super((vertices + (edges << 1)) + 1);\n      }\n      Object.defineProperties(this, {\n        vertices: { value: vertices },\n        edges: { value: edges },\n      });\n\n      if (!args.length) this.setOffsets();\n    }\n\n    /**\n     * Adds an edge between two vertices.\n     *\n     * @param {number} x the starting vertex\n     * @param {number} y the ending vertex\n     * @param {number} weight the weight\n     * @throws {RangeError} if the list is full\n     * @returns {WeightedAdjacencyList}\n     */\n    addEdge(x, y, weight) {\n      const { undirected } = this.constructor;\n      if (this.hasEdge(x, y)) return this;\n      // the list is full\n      if (this.isFull()) throw new RangeError('The list is full.');\n      this.setEdge(x, y, weight);\n      if (undirected) this.setEdge(y, x, weight);\n      return this;\n    }\n\n    /**\n     * Removes an edge between two vertices.\n     *\n     * @param {number} x the starting vertex\n     * @param {number} y the ending vertex\n     * @returns {WeightedAdjacencyList}\n     */\n    removeEdge(x, y) {\n      const { undirected } = this.constructor;\n      this.unsetEdge(x, y);\n      if (undirected) this.unsetEdge(y, x);\n      return this;\n    }\n\n    /**\n     * Checks if there is an edge between two vertices.\n     *\n     * @param {number} x the starting vertex\n     * @param {number} y the ending vertex\n     * @returns {boolean}\n     */\n    hasEdge(x, y) {\n      return !Number.isNaN(this.getEdge(x, y));\n    }\n\n\n    /**\n     * Returns the weight of the edge between given vertices\n     * or NaN if the edge doesn't exist.\n     *\n     * @param {number} x the starting vertex\n     * @param {number} y the ending vertex\n     * @returns {number}\n     */\n    getEdge(x, y) {\n      const offset = this[x];\n      const nextOffset = this[x + 1];\n      // no out edges from x\n      if (offset === nextOffset) return NaN;\n      for (let i = offset; i < nextOffset; i += 2) {\n        if (this[i] === y) return this[i + 1];\n      }\n      return NaN;\n    }\n\n    /**\n     * @private\n     * @param {number} x the starting vertex\n     * @param {number} y the ending vertex\n     * @param {number} weight the weight\n     * @returns {WeightedAdjacencyList}\n     */\n    setEdge(x, y, weight) {\n      const { vertices } = this;\n\n      // shift values\n      for (let i = this[vertices]; i > this[x]; i -= 2) {\n        [this[i], this[i + 1], this[i - 1], this[i - 2]] = [this[i - 2], this[i - 1], this[i], this[i + 1]];\n      }\n      // set edge\n      this[this[x]] = y;\n      this[this[x] + 1] = weight;\n\n      // update offsets\n      for (let i = x + 1; i <= vertices; i++) {\n        this[i] += 2;\n      }\n      return this;\n    }\n\n    /**\n     * @private\n     * @param {number} x the starting vertex\n     * @param {number} y the ending vertex\n     * @returns {WeightedAdjacencyList}\n     */\n    unsetEdge(x, y) {\n      const offset = this[x];\n      const nextOffset = this[x + 1];\n      // no out edges from x\n      if (offset === nextOffset) return this;\n      let edgeIndex = 0;\n      for (let i = offset; i < nextOffset; i += 2) {\n        if (this[i] === y) {\n          edgeIndex = i;\n          break;\n        }\n      }\n      // there is no such edge\n      if (!edgeIndex) return this;\n      // shift value\n      for (let i = edgeIndex; i < this[this.vertices]; i += 2) {\n        this[i] = this[i + 2];\n        this[i + 1] = this[i + 3];\n      }\n\n      // update offsets\n      for (let i = x + 1; i <= this.vertices; i++) {\n        this[i] -= 2;\n      }\n\n      return this;\n    }\n\n    /**\n     * Iterates over outgoing edges of a vertex.\n     *\n     * @generator\n     * @param {number} vertex the vertex\n     * @yields {number}\n     */\n    * outEdges(vertex) {\n      const offset = this[vertex];\n      const nextOffset = this[vertex + 1];\n      if (offset !== nextOffset) {\n        for (let i = nextOffset - 2; i >= offset; i -= 2) {\n          yield this[i];\n        }\n      }\n    }\n\n    /**\n     * Iterates over incoming edges of a vertex.\n     *\n     * @generator\n     * @param {number} vertex the vertex\n     * @yields {number}\n     */\n    * inEdges(vertex) {\n      const { vertices } = this;\n      let edge = 0;\n      let nextVertex = 1;\n      for (let i = vertices + 1; i < this[vertices]; i += 2) {\n        while (i >= this[nextVertex]) {\n          edge++;\n          nextVertex++;\n        }\n        if (this[i] === vertex) yield edge;\n      }\n    }\n\n    /**\n     * @private\n     * @returns {void}\n     */\n    setOffsets() {\n      const lastElement = this.vertices + 1;\n      for (let i = 0; i < lastElement; i++) {\n        this[i] = lastElement;\n      }\n    }\n\n    /**\n     * Checks whether the list is full--all available edges are set.\n     *\n     * @returns {boolean}\n     */\n    isFull() {\n      return this[this.vertices] >= this.length;\n    }\n\n    /**\n     * Creates a larger copy of the graph with a space\n     * for a specified amount of additional vertices and edges.\n     *\n     * @param {number} [vertices=0] the amount of additional vertices\n     * @param {number} [edges=1] the amount of additional edges\n     * @returns {WeightedAdjacencyList}\n     */\n    grow(vertices = 0, edges = 1) {\n      const copy = new this.constructor({\n        vertices: this.vertices + vertices,\n        edges: this.edges + edges,\n      });\n\n      if (!vertices) {\n        copy.set(this);\n      } else {\n        const offset = this[this.vertices];\n        const newSize = this.vertices + vertices;\n        const newOffset = offset + vertices;\n        for (let i = 0; i <= newSize; i++) {\n          copy[i] = i < this.vertices ? this[i] + vertices : newOffset;\n        }\n        copy.set(this.subarray(this.vertices + 1), newSize + 1);\n      }\n      return copy;\n    }\n\n    /**\n     * Returns the length of underlying TypedArray required to hold the graph.\n     *\n     * @param {number} vertices\n     * @param {number} edges\n     * @returns {number}\n     */\n    static getLength(vertices, edges) {\n      return vertices + (edges << 1) + 1;\n    }\n\n    /**\n     * Derives the vertex count of an adjacency list stored as an array-like object.\n     *\n     * @param {Collection} array\n     * @returns {number}\n     */\n    static getVertexCount(array) {\n      let vertices = 0;\n      while (array[vertices] <= array[vertices + 1]) {\n        vertices++;\n      }\n      return vertices;\n    }\n\n    /**\n     * @type {CollectionConstructor}\n     */\n    static get [Symbol.species]() {\n      return Base;\n    }\n\n    /**\n     * Creates an adjacency list from a given grid or adjacency matrix.\n     *\n     * @param {Grid|BinaryGrid|SymmetricGrid} grid\n     * @returns {WeightedAdjacencyList}\n     */\n    static fromGrid(grid) {\n      const vertices = grid.rows;\n      const offset = vertices + 1;\n      const empty = grid.pad || 0;\n      const array = new Array(offset).fill(offset);\n      let edges = 0;\n      for (let i = 0; i < vertices; i++) {\n        array[i + 1] = i === 0 ? offset : array[i];\n        for (let j = 0; j < vertices; j++) {\n          const weight = grid.get(i, j);\n          if (weight !== empty) {\n            array.push(j, weight);\n            array[i + 1] += 2;\n            edges++;\n          }\n        }\n      }\n      const graph = new this({ vertices, edges });\n      graph.set(array);\n      return graph;\n    }\n  }\n\n  /**\n   * Whether the graph is undirected.\n   * @type {boolean}\n   */\n  WeightedAdjacencyList.undirected = false;\n\n  /**\n   * Whether the graph is weighted.\n   * @type {boolean}\n   */\n  WeightedAdjacencyList.weighted = true;\n\n  return WeightedAdjacencyList;\n}\n\n\nmodule.exports = WeightedAdjacencyListMixin;\n","const GridMixin = require('./grid');\nconst SymmetricGridMixin = require('./symmetric-grid');\n\n/**\n * Creates a WeightedAdjacencyMatrix class extending a given Array-like class.\n *\n * @param {CollectionConstructor} Base\n * @param {boolean} [undirected=false]\n * @returns {WeightedAdjacencyMatrix}\n */\nfunction WeightedAdjacencyMatrixMixin(Base, undirected = false) {\n  const Grid = undirected ? SymmetricGridMixin(Base) : GridMixin(Base);\n\n  /**\n   * Implements Adjacency Matrix for weighted graphs.\n   *\n   * @extends Grid\n   */\n  class WeightedAdjacencyMatrix extends Grid {\n    /**\n     * @param {Object} [options]\n     * @param {number} [options.vertices=2] the maximum number of vertices\n     * @param {*} [options.pad=0] the initial value of all edges\n     * @param {...*} [args]\n     */\n    constructor(options = {}, ...args) {\n      const { vertices = 2, pad = 0 } = options;\n      super({ rows: vertices, columns: vertices, pad }, ...args);\n      Object.defineProperties(this, {\n        vertices: { value: vertices },\n      });\n    }\n\n    /**\n     * Adds an edge between two vertices.\n     *\n     * @param {number} x the starting vertex\n     * @param {number} y the ending vertex\n     * @param {number} weight\n     * @returns {WeightedAdjacencyMatrix}\n     */\n    addEdge(x, y, weight) {\n      this.set(x, y, weight);\n      return this;\n    }\n\n    /**\n     * Removes an edge between two vertices.\n     *\n     * @param {number} x the starting vertex\n     * @param {number} y the ending vertex\n     * @returns {WeightedAdjacencyMatrix}\n     */\n    removeEdge(x, y) {\n      this.set(x, y, this.pad);\n      return this;\n    }\n\n    /**\n     * Checks if there is an edge between two vertices.\n     *\n     * @param {number} x the starting vertex\n     * @param {number} y the ending vertex\n     * @returns {boolean}\n     */\n    hasEdge(x, y) {\n      return this.get(x, y) !== this.pad;\n    }\n\n    /**\n     * Returns the weight of the edge between given vertices if it exists.\n     *\n     * @param {number} x the starting vertex\n     * @param {number} y the ending vertex\n     * @returns {number}\n     */\n    getEdge(x, y) {\n      return this.get(x, y);\n    }\n\n    /**\n     * Iterates over outgoing edges of a vertex.\n     *\n     * @generator\n     * @param {number} vertex the vertex\n     * @yields {number}\n     */\n    * outEdges(vertex) {\n      const { vertices } = this;\n      for (let i = 0; i < vertices; i++) {\n        if (this.hasEdge(vertex, i)) yield i;\n      }\n    }\n\n    /**\n     * Iterates over incoming edges of a vertex.\n     *\n     * @generator\n     * @param {number} vertex the vertex\n     * @yields {number}\n     */\n    * inEdges(vertex) {\n      const { vertices } = this;\n      for (let i = 0; i < vertices; i++) {\n        if (this.hasEdge(i, vertex)) yield i;\n      }\n    }\n\n    /**\n     * Returns the length of underlying Array required to hold the graph.\n     *\n     * @param {number} vertices\n     * @returns {number}\n     */\n    static getLength(vertices) {\n      return super.getLength(vertices, vertices);\n    }\n\n    /**\n     * Creates an adjacency matrix from a given adjacency list.\n     *\n     * @param {WeightedAdjacencyList} list\n     * @param {number} [pad=0]\n     * @returns {WeightedAdjacencyMatrix}\n     */\n    static fromList(list, pad = 0) {\n      const { vertices } = list;\n      const graph = new this({ vertices, pad });\n      for (let i = 0; i < vertices; i++) {\n        const offset = list[i];\n        const nextOffset = list[i + 1];\n        if (offset === nextOffset) continue;\n        for (let j = nextOffset - 2; j >= offset; j -= 2) {\n          graph.addEdge(i, list[j], list[j + 1]);\n        }\n      }\n      return graph;\n    }\n  }\n\n  /**\n   * Whether the graph is undirected.\n   * @type {boolean}\n   */\n  WeightedAdjacencyMatrix.undirected = undirected;\n\n  /**\n   * Whether the graph is weighted.\n   * @type {boolean}\n   */\n  WeightedAdjacencyMatrix.weighted = true;\n\n  return WeightedAdjacencyMatrix;\n}\n\n\nmodule.exports = WeightedAdjacencyMatrixMixin;\n","/**\n * @param {Class<ObjectView>} ObjectViewClass\n * @returns {Class<ArrayView>}\n */\nfunction ArrayViewMixin(ObjectViewClass) {\n  if (!ObjectViewClass.isInitialized) ObjectViewClass.initialize();\n\n  /**\n   * @extends ObjectView\n   */\n  class ArrayView extends ObjectViewClass {\n    /**\n     * Returns an object at a given index.\n     *\n     * @param {number} index\n     * @returns {ObjectView}\n     */\n    get(index) {\n      const { objectLength } = this.constructor;\n      return new ObjectViewClass(\n        this.buffer, this.byteOffset + (index * objectLength), objectLength,\n      );\n    }\n\n    /**\n     * Sets an object at a given index.\n     *\n     * @param {number} index\n     * @param {Object} value\n     * @returns {ArrayView}\n     */\n    set(index, value) {\n      this.setObject(index * this.constructor.objectLength, value, this.constructor);\n      return this;\n    }\n\n    /**\n     * Sets an object view at a given index.\n     *\n     * @param {number} index\n     * @param {ObjectView} value\n     * @returns {ArrayView}\n     */\n    setView(index, value) {\n      const { objectLength } = this.constructor;\n      new Uint8Array(this.buffer, this.byteOffset + (index * objectLength), objectLength)\n        .set(new Uint8Array(value.buffer, value.byteOffset, value.length));\n      return this;\n    }\n\n    /**\n     * Returns the amount of available objects in the array.\n     *\n     * @type {number}\n     */\n    get size() {\n      return this.byteLength / this.constructor.objectLength;\n    }\n\n\n    /**\n     * Allows iterating over numbers stored in the instance.\n     *\n     * @yields {number}\n     */\n    * [Symbol.iterator]() {\n      const { size } = this;\n      for (let i = 0; i < size; i++) {\n        yield this.get(i);\n      }\n    }\n\n    /**\n     * Returns an array representation of the array view.\n     *\n     * @returns {Array<Object>}\n     */\n    toObject() {\n      return this.getArray(0, this.constructor, this.size);\n    }\n\n    /**\n     * Creates an array view from a given array of objects.\n     *\n     * @param {ArrayLike<Object>} value\n     * @param {ArrayView} [array]\n     * @returns {ArrayView}\n     */\n    static from(value, array) {\n      const arrayView = array || this.of(value.length);\n      const { size } = arrayView;\n      for (let i = 0; i < size; i++) {\n        arrayView.set(i, value[i]);\n      }\n      return arrayView;\n    }\n\n    /**\n     * Returns the byte length of an array view to hold a given amount of objects.\n     *\n     * @param {number} size\n     * @returns {number}\n     */\n    static getLength(size) {\n      return size * this.objectLength;\n    }\n\n    /**\n     * Creates an empty array view of specified size.\n     *\n     * @param {number} size\n     * @returns {ArrayView}\n     */\n    static of(size = 1) {\n      const buffer = new ArrayBuffer(this.getLength(size));\n      return new this(buffer);\n    }\n  }\n\n  return ArrayView;\n}\n\n\nmodule.exports = ArrayViewMixin;\n","/**\n * @private\n */\nconst getters = {\n  int8: 'getInt8',\n  uint8: 'getUint8',\n  int16: 'getInt16',\n  uint16: 'getUint16',\n  int32: 'getInt32',\n  uint32: 'getUint32',\n  float32: 'getFloat32',\n  float64: 'getFloat64',\n  bigint64: 'getBigInt64',\n  biguint64: 'getBigUint64',\n};\n\n/**\n * @private\n */\nconst setters = {\n  int8: 'setInt8',\n  uint8: 'setUint8',\n  int16: 'setInt16',\n  uint16: 'setUint16',\n  int32: 'setInt32',\n  uint32: 'setUint32',\n  float32: 'setFloat32',\n  float64: 'setFloat64',\n  bigint64: 'setBigInt64',\n  biguint64: 'setBigUint64',\n};\n\n/**\n * @private\n */\nconst offsets = {\n  int8: 0,\n  uint8: 0,\n  int16: 1,\n  uint16: 1,\n  int32: 2,\n  uint32: 2,\n  float32: 2,\n  float64: 3,\n  bigint64: 3,\n  biguint64: 3,\n};\n\n/**\n * @param {string} type\n * @param {boolean} [littleEndian]\n * @returns {Class<TypedArrayView>}\n */\nfunction TypedArrayViewMixin(type, littleEndian) {\n  /**\n   * @extends DataView\n   */\n  class TypedArrayView extends DataView {\n    /**\n     * Returns a number at a given index.\n     *\n     * @param {number} index\n     * @returns {number}\n     */\n    get(index) {\n      const { typeGetter, offset, littleEndian: le } = this.constructor;\n      return this[typeGetter](index << offset, le);\n    }\n\n    /**\n     * Sets a number at a given index.\n     *\n     * @param {number} index\n     * @param {number} value\n     * @returns {TypedArrayView}\n     */\n    set(index, value) {\n      const { typeSetter, offset, littleEndian: le } = this.constructor;\n      this[typeSetter](index << offset, value, le);\n      return this;\n    }\n\n    /**\n     * Returns the amount of available numbers in the array.\n     *\n     * @type {number}\n     */\n    get size() {\n      return this.byteLength >> this.constructor.offset;\n    }\n\n\n    /**\n     * Allows iterating over numbers stored in the instance.\n     *\n     * @yields {number}\n     */\n    * [Symbol.iterator]() {\n      const { size } = this;\n      for (let i = 0; i < size; i++) {\n        yield this.get(i);\n      }\n    }\n\n    /**\n     * Returns an array representation of the array view.\n     *\n     * @returns {Array<number>}\n     */\n    toObject() {\n      return [...this];\n    }\n\n    /**\n     * Returns the byte length of an array view to hold a given amount of numbers.\n     *\n     * @param {number} size\n     * @returns {number}\n     */\n    static getLength(size) {\n      return size << this.offset;\n    }\n\n    /**\n     * Creates an array view from a given array of numbers.\n     *\n     * @param {ArrayLike<number>} value\n     * @param {TypedArrayView} [array]\n     * @returns {TypedArrayView}\n     */\n    static from(value, array) {\n      const dataArray = array || this.of(value.length);\n      const { size } = dataArray;\n      for (let i = 0; i < size; i++) {\n        dataArray.set(i, value[i]);\n      }\n      return dataArray;\n    }\n\n    /**\n     * Creates an empty array view of specified size.\n     *\n     * @param {number} size\n     * @returns {TypedArrayView}\n     */\n    static of(size = 1) {\n      const buffer = new ArrayBuffer(this.getLength(size));\n      return new this(buffer);\n    }\n  }\n\n  /**\n   * @private\n   * @type {string}\n   */\n  TypedArrayView.typeGetter = getters[type];\n\n  /**\n   * @private\n   * @type {string}\n   */\n  TypedArrayView.typeSetter = setters[type];\n\n  /**\n   * @private\n   * @type {number}\n   */\n  TypedArrayView.offset = offsets[type];\n\n  /**\n   * @private\n   * @type {boolean}\n   */\n  TypedArrayView.littleEndian = !!littleEndian;\n\n  return TypedArrayView;\n}\n\nmodule.exports = TypedArrayViewMixin;\n","const StringView = require('./string-view');\nconst DataArrayMixin = require('./array-view');\nconst TypedArrayViewMixin = require('./typed-array-view');\n\n/**\n * @typedef {('int8' | 'uint8' | 'int16' | 'uint16'\n * | 'int32' | 'uint32' | 'float32' | 'float64'\n * | 'bigint64' | 'biguint64' | 'string' | 'array' | 'object' | 'typedarray'\n * | Class<ArrayView>|Class<ObjectView>|Class<TypedArrayView>)} ObjectViewFieldType\n */\n\n/**\n * @typedef {Object} ObjectViewField\n * @property {ObjectViewFieldType} type\n * @property {number} [size] the maximum size in bytes for a string type\n * @property {boolean} [littleEndian]\n * @property {number} [start]\n * @property {number} [length]\n * @property {Class<ArrayView>|Class<ObjectView>|Class<TypedArrayView>} [ctor]\n */\n\n/**\n * @private\n */\nconst fieldSizes = {\n  int8: 1,\n  uint8: 1,\n  int16: 2,\n  uint16: 2,\n  int32: 4,\n  uint32: 4,\n  float32: 4,\n  float64: 8,\n  bigint64: 8,\n  biguint64: 8,\n  string: 0,\n};\n\n/**\n * @extends DataView\n */\nclass ObjectView extends DataView {\n  /**\n   * Returns the value of a given field.\n   *\n   * @param {string} field the name of the field\n   * @returns {*} value of the field\n   */\n  get(field) {\n    const {\n      type, littleEndian, start, ctor, length,\n    } = this.constructor.schema[field];\n    switch (type) {\n      case 'int8': return this.getInt8(start);\n      case 'uint8': return this.getUint8(start);\n      case 'int16': return this.getInt16(start, littleEndian);\n      case 'uint16': return this.getUint16(start, littleEndian);\n      case 'int32': return this.getInt32(start, littleEndian);\n      case 'uint32': return this.getUint32(start, littleEndian);\n      case 'float32': return this.getFloat32(start, littleEndian);\n      case 'float64': return this.getFloat64(start, littleEndian);\n      case 'bigint64': return this.getBigInt64(start, littleEndian);\n      case 'biguint64': return this.getBigUint64(start, littleEndian);\n      default: return this.getView(start, length, ctor);\n    }\n  }\n\n  /**\n   * @private\n   * @param {number} position\n   * @param {Class<ArrayView>|Class<ObjectView>} ctor\n   * @param {number} size\n   * @returns {Array<Object>}\n   */\n  getArray(position, ctor, size) {\n    const { schema, objectLength } = ctor;\n    const result = new Array(size);\n    for (let i = 0; i < size; i++) {\n      result[i] = this.getObject(schema, position + (i * objectLength));\n    }\n    return result;\n  }\n\n  /**\n   * @private\n   * @param {number} position\n   * @param {Class<TypedArrayView>} ctor\n   * @param {number} size\n   * @returns {Array<number>}\n   */\n  getTypedArray(position, ctor, size) {\n    const { typeGetter, offset, littleEndian } = ctor;\n    const result = new Array(size);\n    for (let i = 0; i < size; i++) {\n      result[i] = this[typeGetter](position + (i << offset), littleEndian);\n    }\n    return result;\n  }\n\n  /**\n   * @private\n   * @param {object} schema\n   * @param {number} offset\n   * @returns {Object}\n   */\n  getObject(schema, offset) {\n    const fields = Object.keys(schema);\n    const result = {};\n    for (let i = 0; i < fields.length; i++) {\n      const name = fields[i];\n      const {\n        type, littleEndian, start, ctor: Ctor, length, size,\n      } = schema[name];\n      let value;\n      const position = offset + start;\n      switch (type) {\n        case 'int8': value = this.getInt8(position); break;\n        case 'uint8': value = this.getUint8(position); break;\n        case 'int16': value = this.getInt16(position, littleEndian); break;\n        case 'uint16': value = this.getUint16(position, littleEndian); break;\n        case 'int32': value = this.getInt32(position, littleEndian); break;\n        case 'uint32': value = this.getUint32(position, littleEndian); break;\n        case 'float32': value = this.getFloat32(position, littleEndian); break;\n        case 'float64': value = this.getFloat64(position, littleEndian); break;\n        case 'bigint64': value = this.getBigInt64(position, littleEndian); break;\n        case 'biguint64': value = this.getBigUint64(position, littleEndian); break;\n        case 'string': value = new StringView(this.buffer, this.byteOffset + position, length).toString(); break;\n        case 'typedarray': value = this.getTypedArray(position, Ctor, size); break;\n        case 'array': value = this.getArray(position, Ctor, size); break;\n        default: value = this.getObject(Ctor.schema, position);\n      }\n      result[name] = value;\n    }\n    return result;\n  }\n\n  /**\n   * @private\n   * @param {number} position\n   * @param {number} length\n   * @param {Class<ArrayView>|Class<TypedArrayView>\n   *   |Class<ObjectView>|Class<StringView>} [Ctor=StringView]\n   * @returns {ArrayView|TypedArrayView|ObjectView|StringView}\n   */\n  getView(position, length, Ctor = StringView) {\n    return new Ctor(this.buffer, this.byteOffset + position, length);\n  }\n\n  /**\n   * Sets a value to a field.\n   *\n   * @param {string} field the name of the field\n   * @param {*} value the value to be set\n   * @returns {ObjectView}\n   */\n  set(field, value) {\n    return this.setValue(field, value);\n  }\n\n  /**\n   * @private\n   * @param {number} position\n   * @param {ArrayLike<object>} value\n   * @param {Class<ArrayView>|Class<ObjectView>} ctor\n   * @param {number} size\n   * @returns {void}\n   */\n  setArray(position, value, ctor, size) {\n    const { fields, schema } = ctor;\n    const max = (size < value.length ? size : value.length);\n    for (let i = 0; i < max; i++) {\n      for (let j = 0; j < fields.length; j++) {\n        const name = fields[j];\n        this.setValue(name, value[i][name], schema, position + (i * ctor.objectLength));\n      }\n    }\n  }\n\n  /**\n   * @private\n   * @param {number} position\n   * @param {Object} value\n   * @param {Class<ObjectView>} ctor\n   * @returns {void}\n   */\n  setObject(position, value, ctor) {\n    const { fields, schema } = ctor;\n    for (let i = 0; i < fields.length; i++) {\n      const name = fields[i];\n      if (Reflect.has(value, name)) this.setValue(name, value[name], schema, position);\n    }\n  }\n\n  /**\n   * @private\n   * @param {number} position\n   * @param {string} value\n   * @param {number} length\n   * @returns {void}\n   */\n  setString(position, value, length) {\n    new Uint8Array(this.buffer, this.byteOffset + position, length)\n      .fill(0)\n      .set(StringView.fromString(value));\n  }\n\n  /**\n   * @private\n   * @param {number} position\n   * @param {ArrayLike<number>} value\n   * @param {Class<TypedArrayView>} ctor\n   * @param {number} size\n   * @returns {void}\n   */\n  setTypedArray(position, value, ctor, size) {\n    const { typeSetter, offset, littleEndian } = ctor;\n    const max = (size < value.length ? size : value.length);\n    for (let i = 0; i < max; i++) {\n      this[typeSetter](position + (i << offset), value[i], littleEndian);\n    }\n  }\n\n  /**\n   * @private\n   * @param {string} field\n   * @param {*} value\n   * @param {*} [schema]\n   * @param {number} [offset=0]\n   * @returns {ObjectView}\n   */\n  setValue(field, value, schema = this.constructor.schema, offset = 0) {\n    const {\n      type, littleEndian, start, ctor, length, size,\n    } = schema[field];\n    const position = offset + start;\n    switch (type) {\n      case 'int8':\n        this.setInt8(position, value);\n        break;\n      case 'uint8':\n        this.setUint8(position, value);\n        break;\n      case 'int16':\n        this.setInt16(position, value, littleEndian);\n        break;\n      case 'uint16':\n        this.setUint16(position, value, littleEndian);\n        break;\n      case 'int32':\n        this.setInt32(position, value, littleEndian);\n        break;\n      case 'uint32':\n        this.setUint32(position, value, littleEndian);\n        break;\n      case 'float32':\n        this.setFloat32(position, value, littleEndian);\n        break;\n      case 'float64':\n        this.setFloat64(position, value, littleEndian);\n        break;\n      case 'bigint64':\n        this.setBigInt64(position, value, littleEndian);\n        break;\n      case 'biguint64':\n        this.setBigUint64(position, value, littleEndian);\n        break;\n      case 'string':\n        this.setString(position, value, length);\n        break;\n      case 'typedarray':\n        this.setTypedArray(position, value, ctor, size);\n        break;\n      case 'array':\n        this.setArray(position, value, ctor, size);\n        break;\n      default:\n        this.setObject(position, value, ctor);\n        break;\n    }\n    return this;\n  }\n\n  /**\n   * Sets an ObjectView value to a field.\n   *\n   * @param {string} field\n   * @param {ObjectView|ArrayView|TypedArrayView|StringView} value\n   * @returns {ObjectView}\n   */\n  setView(field, value) {\n    const { start } = this.constructor.schema[field];\n    new Uint8Array(this.buffer, this.byteOffset, this.byteLength)\n      .set(\n        new Uint8Array(value.buffer, value.byteOffset, value.byteLength),\n        start,\n      );\n    return this;\n  }\n\n  /**\n   * Returns an Object corresponding to the object view.\n   *\n   * @returns {Object}\n   */\n  toObject() {\n    return this.getObject(this.constructor.schema, 0);\n  }\n\n  /**\n   * Assigns fields of a given object to the provided object view\n   * or a new object view.\n   *\n   * @param {Object} object the object to take data from\n   * @param {ObjectView} [view] the object view to assign fields to\n   * @returns {ObjectView}\n   */\n  static from(object, view) {\n    const objectView = view || new this(new ArrayBuffer(this.getLength()));\n    objectView.setObject(0, object, objectView.constructor);\n    return objectView;\n  }\n\n  /**\n   * Returns the byte length of an object view.\n   *\n   * @returns {number}\n   */\n  static getLength() {\n    if (!this.isInitialized) this.initialize();\n    return this.objectLength;\n  }\n\n  /**\n   * @private\n   * @returns {void}\n   */\n  static initialize() {\n    const { schema } = this;\n    const fields = Object.keys(schema);\n    let lastOffset = 0;\n    for (let i = 0; i < fields.length; i++) {\n      const name = fields[i];\n      const field = schema[name];\n      const { type, size, littleEndian } = field;\n      let byteSize = 0;\n      const isPrimitive = typeof type === 'string';\n      const isTypedArray = isPrimitive && !!size;\n      const isArray = !isTypedArray && !!size;\n      // account for wrong primitive type\n      if (isPrimitive && !Reflect.has(fieldSizes, type)) {\n        throw TypeError(`Type \"${type}\" is not a valid type.`);\n      }\n      if (isTypedArray) {\n        field.ctor = TypedArrayViewMixin(type, littleEndian);\n        field.type = 'typedarray';\n        byteSize = field.ctor.getLength(size);\n      } else if (isArray) {\n        field.ctor = DataArrayMixin(type);\n        field.type = 'array';\n        byteSize = field.ctor.getLength(size);\n      } else if (!isPrimitive) {\n        field.type = 'object';\n        field.ctor = type;\n        byteSize = type.getLength();\n      }\n      field.start = lastOffset;\n      field.length = field.length || byteSize || fieldSizes[type];\n      lastOffset += field.length;\n    }\n    this.objectLength = lastOffset;\n    this.fields = fields;\n    this.isInitialized = true;\n  }\n}\n/**\n * @private\n * @type {Array<ObjectViewField>}\n */\nObjectView.fields = undefined;\n\n/**\n * @private\n */\nObjectView.schema = undefined;\n\n/**\n * @private\n */\nObjectView.objectLength = 0;\n\n/** @type {boolean} */\nObjectView.isInitialized = false;\n\nmodule.exports = ObjectView;\n","const BitField = require('./lib/bit-field');\nconst GraphMixin = require('./lib/graph');\nconst GridMixin = require('./lib/grid');\nconst BinaryHeap = require('./lib/binary-heap.js');\nconst Pool = require('./lib/pool');\nconst RankedBitArray = require('./lib/ranked-bit-array');\nconst RecordArray = require('./lib/record-array');\nconst SortedArray = require('./lib/sorted-array');\nconst SortedMixin = require('./lib/sorted-collection');\nconst SymmetricGridMixin = require('./lib/symmetric-grid');\nconst UnweightedAdjacencyList = require('./lib/unweighted-adjacency-list');\nconst UnweightedAdjacencyMatrix = require('./lib/unweighted-adjacency-matrix');\nconst WeightedAdjacencyListMixin = require('./lib/weighted-adjacency-list');\nconst WeightedAdjacencyMatrixMixin = require('./lib/weighted-adjacency-matrix');\nconst ArrayViewMixin = require('./lib/array-view');\nconst ObjectView = require('./lib/object-view');\nconst StringView = require('./lib/string-view');\nconst TypedArrayViewMixin = require('./lib/typed-array-view');\n\n/**\n * @external ArrayBuffer\n * @see {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer|ArrayBuffer}\n */\n\n/**\n * @external DataView\n * @see {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DataView|DataView}\n */\n\n/**\n * @external TypedArray\n * @see {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray|TypedArray}\n */\n\nmodule.exports = {\n  BitField,\n  GraphMixin,\n  GridMixin,\n  BinaryHeap,\n  Pool,\n  RankedBitArray,\n  RecordArray,\n  SortedArray,\n  SortedMixin,\n  SymmetricGridMixin,\n  UnweightedAdjacencyList,\n  UnweightedAdjacencyMatrix,\n  WeightedAdjacencyListMixin,\n  WeightedAdjacencyMatrixMixin,\n  ArrayViewMixin,\n  ObjectView,\n  StringView,\n  TypedArrayViewMixin,\n};\n","<!-- <svelte:options immutable={true} /> -->\n<!-- <svelte:component class=\".container\"  this={Sokoban} /> -->\n<script>\nexport let mapGrid;\nexport let level;\nimport { onMount } from 'svelte';\nimport { quintOut } from 'svelte/easing';\nimport { crossfade } from 'svelte/transition';\nimport { flip } from 'svelte/animate';\n\nimport { GridMixin } from 'structurae';\n\nimport hotkeys from 'hotkeys-js';\n\nconst directions = {left: {row: 0, column: -1, str: 'left'}, down: {row: 1, column: 0, str: 'down'}, right: {row: 0, column: 1, str: 'right'}, up: {row: -1, column: 0, str: 'up'}};\n\nfunction getRandomImageIndex(tileKey) {\n  const max = {C: 6, W: 4, ' ': 3, P: 5};\n  const min = {C: 2, W: 1, ' ': 1, P: 0};\n  const random = Math.max(Math.floor(Math.random() * Math.floor(max[tileKey])), min[tileKey]);\n  return tileKey === 'P' ? random : ('0' + random).slice(-2);\n}\n\nconst imageBasePath = \"sokoban/images/\";\nconst crate = {key: 'C', imagePrefix: 'Crates/crate_', imageIndex: getRandomImageIndex('C'), imageSuffix: '.png'};\nconst wall = {key: 'W', imagePrefix: 'Blocks/block_', imageIndex: getRandomImageIndex('W'), imageSuffix: '.png'};\nconst blank = {key: ' ', imagePrefix: 'Ground/ground_', imageIndex: getRandomImageIndex(' '), imageSuffix: '.png'};\nconst goal = {key: 'G', imagePrefix: 'Ground/ground_', imageIndex: blank.imageIndex, imageSuffix: '_goal.png'};\nconst player = {key: 'P', get imagePrefix() { return 'Player/' + this.direction.str + '/' }, imageIndex: 0, maxImageIndex: 5, imageSuffix: '.png',\n                get image() { return imageBasePath + this.imagePrefix + (this.moves % this.maxImageIndex) + this.imageSuffix;},\n                moves: 0, position: {row: 0, column: 0}, direction: directions.down, standingOn: blank};\n\nconst tileTypeDict = {};\ntileTypeDict['C'] = crate;\ntileTypeDict['G'] = goal;\ntileTypeDict['W'] = wall;\ntileTypeDict[' '] = blank;\nObject.values(tileTypeDict).forEach(tileType => {\n  tileType.image = imageBasePath + tileType.imagePrefix + tileType.imageIndex + tileType.imageSuffix;\n})\ntileTypeDict['P'] = player;\n\nlet goalTiles = [];\nlet map = [];\nlet rowIndex = 0;\nlet columns = 0;\nlet i = 0;\nmapGrid.forEach(row => {\n  let newRow = [];\n  let column = 0;\n  row.forEach(cell => {\n    const movableEntityTypes = \"PC\";\n    const cellKey = cell === 'B' ? 'C' : cell; //Block is a confusing name for the crates, so I'm translating the 'B' from the suggested map format of this exercise into a 'C'.\n    const movableEntity = (! movableEntityTypes.includes(cellKey)) ? null : {\n      key: cellKey,\n      initialLocationIndex: i,\n      initialPos: {row: rowIndex, column: column},\n    };\n    const fixedTile = { //fixed location on the grid\n      gridLocation: i,\n      initialKey: (! movableEntityTypes.includes(cellKey)) ? cellKey : blank.key,\n      entity: movableEntity,\n      moveEntityTo(destTile) {\n        if (destTile.entity) {\n          alert(`Warning! Entity of ${destTile} replaced by entity of ${this}.`);\n        }\n        destTile.entity = this.entity;\n        this.entity = null;\n        if (this.key === player.key) {\n          player.tile = this;\n        }\n        },\n      get id() { return this.entity ? this.entity.initialLocationIndex : -this.gridLocation },\n      get key() { return this.entity ? this.entity.key : this.initialKey },\n      floorKey: blank.key, index: i, position: {row: rowIndex, column: column},\n      get image() {\n        return this.isTraversable ? \"\" : tileTypeDict[this.key].image;\n      },\n      get backgroundImage() {\n        return this.isTraversable ? tileTypeDict[this.key].image : tileTypeDict[this.floorKey].image;\n      },\n      get isTraversable() { return this.key === ' ' || this.key === 'G'},\n      get hasCrate() { return this.key === 'C' && this.floorKey === 'G'},\n    }\n    if (cellKey === player.key) {\n      player.position = fixedTile.position;\n      player.standingOn = fixedTile;\n    }\n    if (cellKey === 'G') {\n      fixedTile.floorKey = 'G'; //used for the css background-image of the tile. Now we can see the goal tile below the crate.\n      goalTiles.push(fixedTile);\n    }\n    newRow.push(fixedTile);\n    i++;\n    column++;\n    columns = Math.max(column, columns);\n  })\n  rowIndex++;\n  map.push(newRow);\n})\n\nconst ArrayGrid = GridMixin(Array);\nlet grid = ArrayGrid.fromArrays(map); //Won't make a copy of the values, so changing things in grid will update map\nconst tileArray = map.flat();\n$: levelComplete = goalTiles.every(goalTile => goalTile.hasCrate);\n\n$: if(levelComplete) {\n  alert(\"Level Complete!\");\n  console.log(\"Level Complete!\");\n}\n\n// $: canMoveUp = canMoveInDirection(directions.up, player.position);\n\nfunction canMoveInDirection(relativeCoordinates, fromCoordinates) {\n  const params = {fromCoordinates: fromCoordinates, relativeCoordinates: relativeCoordinates};\n  params.targetCoordinates = {row: fromCoordinates.row + relativeCoordinates.row, column: fromCoordinates.column + relativeCoordinates.column};\n  params.beyondTargetCoordinates = {row: params.targetCoordinates.row + relativeCoordinates.row, column: params.targetCoordinates.column + relativeCoordinates.column};\n  if (params.targetCoordinates.row < 0 || params.targetCoordinates.column < 0) {\n    return {canMove : false, ...params}\n  } else if (params.targetCoordinates.row > grid.rows || params.targetCoordinates.column > grid.columns) {\n    return {canMove : false, ...params}\n  }\n  params.targetTile = grid.get(params.targetCoordinates.row, params.targetCoordinates.column);\n  params.beyondTargetTile = grid.get(params.beyondTargetCoordinates.row, params.beyondTargetCoordinates.column);\n  if (params.targetTile.isTraversable) {\n    return {canMove : true, ...params}\n  } else if (params.targetTile.key === crate.key && params.beyondTargetTile.isTraversable ) {\n      return {canMove : true, ...params}\n  } else {\n    return {canMove : false, ...params}\n  }\n}\nconst setPlayerReady = function() {\n  playerReady = true;\n}\nfunction TryMove(direction) {\n  if (playerReady) {\n    if (player.direction != direction) {\n      player.direction = direction;\n      player.moves++;\n      return;\n    }\n    const result = canMoveInDirection(direction, player.position);\n    if (result.canMove) {\n      // console.log(\"Moving!\")\n      player.moves++;\n      playerReady = false;\n      let animationWait = setTimeout(setPlayerReady, 250);\n      // grid.get(player.position.row, player.position.column).key = player.standingOn.floorKey;\n      if (result.targetTile.key === crate.key) {\n        const reachedGoalTile = result.beyondTargetTile.key === goal.key;\n        result.targetTile.moveEntityTo(result.beyondTargetTile);\n        if (reachedGoalTile) {\n          goalTiles = goalTiles;\n          console.log(goalTiles);\n        }\n      }\n      player.standingOn.moveEntityTo(result.targetTile);\n      player.standingOn = result.targetTile;\n      player.position = result.targetCoordinates;\n      map = map; //tells Svelte the map grid changed, since set() hides this from Svelte. Svelte would however pick up grid[index] = player.key\n    } else {\n      playerReady = false;\n      let animationWait = setTimeout(setPlayerReady, 250);\n      console.log(\"Can't go in that direction!\")\n    }\n    player.tile = player.tile;\n  } else {\n    console.log(\"Busy with animation!\");\n  }\n}\n\nfunction extraClassesFor(cell) {\n  if (goalTiles.some(function(goalPos) {\n      return goalPos.position.row === cell.position.row && goalPos.position.column === cell.position.column;\n    })) {\n      return \"goal\"\n  }\n  return \"\"\n}\n\nfunction extraStylesFor(cell) {\n  if (cell.floorKey === goal.key && cell.key != player.key) {\n    // return \"background-size: 100%; background-image: url(\" + tileTypeDict[cell.floorKey].image + \");\";\n  }\n  return \"\";\n}\nlet playerMoving = false;\nlet playerReady = true;\n// $: playerReady = !playerMoving && !levelComplete;\n// $: if (hotkeys && playerReady != null) {\n//         hotkeys.setScope(playerReady ? \"ready\" : \"waiting\");\n//       }\n\n// $: if(hotkeys && (hotkeysScope || true) { //trying to get Svelte to run the code in here whenever hotkeysScope changes, but not before hotkeys is defined.\n//     hotkeys.deleteScope(\"waiting\");\n//     hotkeys.deleteScope(\"ready\");\n//     hotkeys.setScope(hotkeysScope);\n// }\n\nconst backgroundSubareas = [];\n\nconst calculateGoalOffsets = function(onresize) {\n  for(let i=0;i<backgroundSubareas.length;i++) {\n      const {location, overlay} = backgroundSubareas[i];\n      overlay.style.setProperty(\"--offset-left\", location.offsetLeft + \"px\")\n      overlay.style.setProperty(\"--offset-top\", location.offsetTop + \"px\");\n    }\n}\n\nonMount(async () => {\n  const goalBackgroundElement = document.createElement(\"div\");\n  const goalBackgroundImage = document.createElement(\"img\");\n  goalBackgroundImage.src = tileTypeDict[goal.key].image;\n  goalBackgroundElement.appendChild(goalBackgroundImage);\n  goalBackgroundElement.classList.add(\"background-subarea\");\n  const goalElements = document.getElementsByClassName(\"goal\");\n  for(let i=0; i<goalElements.length; i++) {\n    const goalElem = goalElements[i];\n    let newElem = goalBackgroundElement;\n    if (i < goalElements.length - 1) {\n      newElem = goalBackgroundElement.cloneNode(true);\n    }\n    newElem.style.setProperty(\"--offset-left\", goalElem.offsetLeft + \"px\");\n    newElem.style.setProperty(\"--offset-top\", goalElem.offsetTop + \"px\");\n    goalElem.parentElement.insertBefore(newElem, goalElem);\n    newElem.style.setProperty(\"left\", \"var(--offset-left)\");\n    newElem.style.setProperty(\"top\", \"var(--offset-top)\");\n    backgroundSubareas.push({location: goalElem, overlay: newElem});\n  }\n  window.onresize = calculateGoalOffsets;\n  const module = await import('hotkeys-js');\n  hotkeys('left, right, up, down',  //this would break server-side rendering if outside of onMount, due to reliance on 'document'.\n  'ready', function(event, handler) {\n    switch (handler.key) {\n      /****************\n      *   Arrow keys  *\n      ****************/\n      case 'left':\n          TryMove(directions.left);\n        break;\n      case 'up':\n          TryMove(directions.up);\n        break;\n      case 'right':\n          TryMove(directions.right);\n        break;\n      case 'down':\n          TryMove(directions.down);\n        break;\n      /****************\n      * Other events  *\n      ****************/\n      }\n    return false;\n  });\n  hotkeys.setScope('ready');\n});\n\n\nfunction whizz(node, { from, to }, params) {\n  const dx = from.left - to.left;\n  const dy = from.top - to.top;\n\n  const d = Math.sqrt(dx * dx + dy * dy);\n\n  const rotation = Math.abs(dy) > 14 ? 0 : dx < 0 ? 360 : -360;\n\n  return {\n    delay: 0,\n    duration: Math.sqrt(d) * 120,\n    easing: params.easing || quintOut,\n    css: (t, u) =>\n      `transform: translate(${u * dx}px, ${u * dy}px) rotate(${t*rotation}deg);`\n  };\n}\n\nconst animations = function() {\n  const tiles = new Map(); //this is just to practice using Closures.\n  const closureBreakout = {};\n  closureBreakout.starting = function(tile) {\n    tiles.set(tile.id, true);\n    playerMoving = tile.key === player.key || playerMoving;\n  };\n  closureBreakout.ending = function(tile) {\n    tiles.delete(tile.id);\n    if (tile.key === player.key) {\n      if (!playerMoving) {\n        console.log(\"Player animation ended but we thought that they were already done with the animation.\")\n      }\n      playerMoving = false;\n    }\n  }\n  closureBreakout.canceled = function(tile) {\n    tiles.set(tile.id, false);\n    if (tile.key === player.key) {\n      if (!playerMoving) {\n        console.log(\"Player animation canceled but we thought that they were already done with the animation.\")\n      }\n      playerMoving = false;\n    }\n  }\n  return closureBreakout;\n}(); //Don't miss the ();\n\n\n</script>\n\n<style>\n\n* {\n  box-sizing: border-box;\n}\n\n#sokoban {\n  margin: 0 auto;\n  padding: 0;\n  max-width: 100%;\n}\n\n:global(.background-subarea) {\n  /* display: block */\n  position: absolute;\n  /* max-height: attr(height);\n  max-width: attr(width); */\n  height: var(--tile-height);\n  width: var(--tile-width);\n  z-index: 0;\n  /*transform: none; it took me way too long to get this idea. */\n  /*CSS transitions*/\n  transition-property: none !important;\n  /*CSS transforms*/\n  transform: none !important;\n  /*CSS animations*/\n  animation: none !important;\n  /*flex-item:*/\n  /* background-image: var(--goal-background); */\n  /* background-size: auto 100%; */\n  /* background-size: var(--tile-height) var(--tile-width) */\n  }\n  :global(.background-subarea > img) {\n    object-fit: contain;\n  }\n\n.flex-container {\n  padding: 0;\n  margin: 0 auto;\n  list-style: none;\n  display: flex;\n  flex-flow: row;\n  flex-wrap: wrap;\n  justify-content: center;\n  width: var(--width);\n  /* height: var(--height); */\n  /* line-height:30px; */\n}\ndiv.flex-item > img {\n  /* position: absolute; */\n  object-fit: cover;\n}\ndiv.flex-item {\n    margin: 0px;\n    text-align: center;\n    /* flex: 0 1 auto; */\n    flex: 0 0 var(--tile-width);\n    width: var(--tile-width);\n    height: var(--tile-width);\n    z-index: 2;\n}\n/* div.flex-item:before {\n    content:'';\n    float:left;\n    padding-top: var(--ratio);\n} */\n#gameView {\n  z-index: 0;\n  background-repeat: repeat;\n  background-size: var(--tile-width);\n  background-image: var(--floor-background);\n}\n\n</style>\n\n<!-- <svelte:window on:keyup|preventDefault={handleInput}/> -->\n<figure id=\"sokoban\" style=\"\n  --columns: {columns};\n  --rows: {rowIndex};\n  --ratio: calc(var(--columns) / var(--rows));\n  --width: calc(100vmin - 0em);\n  --tile-width: calc(var(--width) / var(--columns));\n  --goal-background: url(/{tileTypeDict[goal.key].image});\n  --floor-background: url(/{tileTypeDict[blank.key].image});\n  \">\n<div id=\"gameView\" class=\"flex-container\">\n<!-- ☞ 83a0fe03-58ac-465b-a847-eee93bedb6a0 -->\n<!-- {#each {length: highest_tile_index} as tile, i} -->\n  <!-- <div class=\"flex-container\" > -->\n{#each tileArray as tile (tile.id)}\n<div class=\"flex-item {extraClassesFor(tile)}\" animate:whizz=\"{{duration: 150, easing: quintOut}}\"\n  on:animationstart={animations.starting(tile)} on:animationend={animations.ending(tile)} on:animationcancel={animations.canceled(tile)}>\n  <!-- bind:clientWidth={tileWidth} bind:clientHeight={tileHeight} -->\n  {#if tile.image && tile.key === player.key}\n    <img src=\"{player.image}\" style={extraStylesFor(tile)} alt=\"{tile.key}\"\n      id=\"player\" class=\"id-{tile.id} tile-index-{tile.index} row-{tile.position.row} column-{tile.position.column}\" />\n  {:else if tile.image}\n    <img src=\"{tile.image}\" style={extraStylesFor(tile)} alt=\"{tile.key}\"\n      class=\"id-{tile.id} tile-index-{tile.index} row-{tile.position.row} column-{tile.position.column}\" />\n  {/if}\n</div>\n{:else}\n  <div class=\"flex-container\">\n\t  <p class=\"flex-item\">No mapGrid provided!</p>\n  </div>\n{/each}\n</div>\n<figcaption class=\"text-center mx-auto\">{@html `Moves: ${player.moves}`}</figcaption>\n</figure>\n\n<!-- TODO: display correct image -->","<script context=\"module\">\n\texport async function preload({ params, query }) {\n\t\t// the `slug` parameter is available because\n\t\t// this file is called [slug].html\n\t\tconst res = await this.fetch(`levels/${params.slug}.json`);\n\t\tconst data = await res.json();\n\n\t\tif (res.status === 200) {\n\t\t\treturn { level: data };\n\t\t} else {\n\t\t\tthis.error(res.status, data.message);\n\t\t}\n\t}\n</script>\n\n<script>\n\timport Sokoban from '../../components/Sokoban.svelte';\n\texport let level;\n\tconst mapGrid = level.mapGrid;\n</script>\n\n<style>\n\t/*\n\t\tBy default, CSS is locally scoped to the component,\n\t\tand any unused styles are dead-code-eliminated.\n\t\tIn this page, Svelte can't know which elements are\n\t\tgoing to appear inside the {{{level.html}}} block,\n\t\tso we have to use the :global(...) modifier to target\n\t\tall elements inside\n\t*/\n\n\t\n\t.game_container {\n    display: grid;\n\t\t/* width: 80vmin;\n\t\theight: 80vmin; */\n\t\t/* margin-top: -16px; */\n    grid-template-areas: \"header header header\"\n    \"main main main\"\n    \"footer footer footer\";\n    grid-template-columns: 0px auto 0px;\n    grid-template-rows:0em auto 5em;\n  }\n\n  .header {\n    grid-area: header;\n  }\n  :global(#sokoban){\n    grid-area: main;\n  }\n  .footer {\n    grid-area: footer;\n  }\n\n\th3 {\n\t\tmargin: 0.5em auto;\n\t\t/* padding-bottom: 0.8em; */\n\t}\n\n</style>\n\n<svelte:head>\n\t<!-- <title>{level.name}</title> -->\n</svelte:head>\n\n<div class='game_container mx-auto'>\n\t<!-- <h3 class=\"header\">{level.name}</h3> -->\n\t<Sokoban {level} {mapGrid}/>\n\t{#if level.next != undefined}\n\t\t<div class=\"footer my-5 mx-auto\"><a rel=\"prefetch\" href=\"levels/{level.next}\"><button class=\"p-2 button\">Next Level</button></a></div>\n\t{/if}\n</div>"],"names":["quintOut","t","BigInt","window","Number","SIGN_BIT","BITWISE_SIZE","MAX_SIZE","TWO_TO_48","BitField","[object Object]","data","isInitialized","this","constructor","initialize","isBigInt","value","Array","isArray","encode","field","offsets","masks","one","fields","zero","mask","i","length","matcher","match","getMatcher","decode","toString","isSafe","result","current","size","name","selectedFields","map","Object","entries","number","Math","log2","n","two","high","low","mid","totalSize","reduce","lastOffset","push","keys","fieldName","fieldMask","fieldValue","Symbol","iterator","get","from","e","undefined","BinaryGrid","Uint16Array","options","args","columns","rows","offset","getOffset","super","defineProperties","lastPosition","seal","bucket","position","row","column","getBitPosition","set","index","static","species","ceil","heapify","siftDown","isHeap","getLeftIndex","getParentIndex","elements","siftUp","element","first","getRightIndex","pop","item","deletedItems","splice","update","last","items","compare","parent","leftIndex","has","start","nextIndex","rightIndex","parentIndex","a","b","arrayLike","mapFn","thisArg","heap","of","VertexHeap","BinaryHeap","w","Base","undirected","Graph","colors","vertices","vertex","fill","isDFS","gray","white","black","resetColors","processing","pull","setGray","edge","outEdges","isGray","setBlack","traverse","end","isAcyclic","isNonNegative","weighted","predecessors","distances","Infinity","searchTopological","searchDijkstra","searchBellmanFord","searchUnweighted","path","unshift","lastPredecessor","isFound","isBlack","weight","getEdge","shift","distance","Grid","pad","writable","lastCoordinates","getIndex","array","withPadding","begin","Uint32Array","beginning","slice","j","arrays","grid","ArrayBuffer","getLength","1","2","4","8","16","32","64","128","256","512","1024","2048","4096","8192","16384","32768","65536","131072","262144","524288","1048576","2097152","4194304","8388608","16777216","33554432","67108864","134217728","268435456","536870912","1073741824","2147483648","popCount32","getLSBIndex","getGTEMultiple","base","BitArray","nextAvailable","record","utilities","setBit","change","masked","localRank","middle","left","right","bucketRankId","rank","ZERO_CHAR","String","fromCharCode","StringView","Uint8Array","toChar","getCharStart","point","startCharIndex","startIndex","pattern","replacement","currentIndex","search","searchValue","fromIndex","searchShiftOr","searchNaive","wordLength","max","outer","m","m1","r","indexStart","indexEnd","sub","subarray","getCharEnd","decoder","fromCodePoint","decoded","indexOf","string","encoded","encoder","view","buffer","code","codePointAt","Int8Array","TextEncoder","TextDecoder","fieldSizes","Int8","Uint8","Int16","Uint16","Int32","Uint32","Float32","Float64","BigInt64","BigUint64","Uint8ClampedArray","Int16Array","Int32Array","Float32Array","Float64Array","BigInt64Array","BigUint64Array","typedArrays","DataView","byteOffset","byteLength","lastField","schema","byteView","type","littleEndian","getByteOffset","getInt8","getUint8","getInt16","getUint16","getInt32","getUint32","getFloat32","getFloat64","getBigInt64","getBigUint64","getString","getArray","setInt8","setUint8","setInt16","setUint16","setInt32","setUint32","setFloat32","setFloat64","setBigInt64","setBigUint64","setString","setArray","object","Reflect","fieldSize","TypeError","bytesPerElement","BYTES_PER_ELEMENT","isSorted","isUnique","getRange","RangeError","sort","symmetric","comparator","container","compared","score","getIntersectionScore","arr","target","endIndex","unique","SortedMixin","getUnion","toAdd","filter","el","compareFunction","deleteCount","deletedElements","getUnique","SymmetricGrid","sqrt","k","x","y","UnweightedAdjacencyList","edges","getVertexCount","setOffsets","hasEdge","isFull","setEdge","unsetEdge","nextOffset","edgeIndex","nextVertex","lastElement","copy","newSize","newOffset","empty","graph","UnweightedAdjacencyMatrix","list","addEdge","WeightedAdjacencyList","isNaN","NaN","SymmetricGridMixin","GridMixin","WeightedAdjacencyMatrix","ObjectViewClass","objectLength","setObject","arrayView","getters","int8","uint8","int16","uint16","int32","uint32","float32","float64","bigint64","biguint64","setters","TypedArrayView","typeGetter","le","typeSetter","dataArray","ObjectView","ctor","getView","getObject","Ctor","getTypedArray","setValue","fromString","setTypedArray","objectView","byteSize","isPrimitive","isTypedArray","TypedArrayViewMixin","DataArrayMixin","GraphMixin","Pool","RankedBitArray","RecordArray","SortedArray","WeightedAdjacencyListMixin","WeightedAdjacencyMatrixMixin","ArrayViewMixin","tile","image","extraStylesFor","key","id","player","extraClassesFor","animations","starting","ending","canceled","duration","easing","moves","tileArray","rowIndex","tileTypeDict","goal","blank","imageBasePath","getRandomImageIndex","tileKey","random","floor","C","W"," ","P","whizz","node","to","params","dx","dy","top","d","rotation","abs","delay","css","u","mapGrid","level","directions","str","down","up","crate","imagePrefix","imageIndex","imageSuffix","wall","direction","maxImageIndex","standingOn","values","forEach","tileType","goalTiles","newRow","cell","cellKey","movableEntity","includes","initialLocationIndex","initialPos","fixedTile","gridLocation","initialKey","entity","destTile","alert","floorKey","isTraversable","backgroundImage","hasCrate","fromArrays","flat","setPlayerReady","playerReady","TryMove","relativeCoordinates","fromCoordinates","targetCoordinates","beyondTargetCoordinates","canMove","targetTile","beyondTargetTile","canMoveInDirection","setTimeout","reachedGoalTile","moveEntityTo","$$invalidate","console","log","playerMoving","backgroundSubareas","calculateGoalOffsets","onresize","location","overlay","style","setProperty","offsetLeft","offsetTop","onMount","async","goalBackgroundElement","document","createElement","goalBackgroundImage","src","appendChild","classList","add","goalElements","getElementsByClassName","goalElem","newElem","cloneNode","parentElement","insertBefore","import","hotkeys","event","handler","setScope","tiles","Map","closureBreakout","delete","levelComplete","every","goalTile","some","goalPos","next","preload","query","res","fetch","slug","json","status","error","message"],"mappings":"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"}